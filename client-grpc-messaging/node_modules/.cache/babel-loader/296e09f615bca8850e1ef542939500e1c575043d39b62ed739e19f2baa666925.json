{"ast":null,"code":"var extendStatics = function (e, r) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, r) {\n    e.__proto__ = r;\n  } || function (e, r) {\n    for (var t in r) if (Object.prototype.hasOwnProperty.call(r, t)) e[t] = r[t];\n  };\n  return extendStatics(e, r);\n};\nfunction __extends(e, r) {\n  if (typeof r !== \"function\" && r !== null) throw new TypeError(\"Class extends value \" + String(r) + \" is not a constructor or null\");\n  extendStatics(e, r);\n  function __() {\n    this.constructor = e;\n  }\n  e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());\n}\nfunction __generator(e, r) {\n  var t = {\n      label: 0,\n      sent: function () {\n        if (s[0] & 1) throw s[1];\n        return s[1];\n      },\n      trys: [],\n      ops: []\n    },\n    i,\n    n,\n    s,\n    h;\n  return h = {\n    next: verb(0),\n    throw: verb(1),\n    return: verb(2)\n  }, typeof Symbol === \"function\" && (h[Symbol.iterator] = function () {\n    return this;\n  }), h;\n  function verb(e) {\n    return function (r) {\n      return step([e, r]);\n    };\n  }\n  function step(a) {\n    if (i) throw new TypeError(\"Generator is already executing.\");\n    while (h && (h = 0, a[0] && (t = 0)), t) try {\n      if (i = 1, n && (s = a[0] & 2 ? n[\"return\"] : a[0] ? n[\"throw\"] || ((s = n[\"return\"]) && s.call(n), 0) : n.next) && !(s = s.call(n, a[1])).done) return s;\n      if (n = 0, s) a = [a[0] & 2, s.value];\n      switch (a[0]) {\n        case 0:\n        case 1:\n          s = a;\n          break;\n        case 4:\n          t.label++;\n          return {\n            value: a[1],\n            done: false\n          };\n        case 5:\n          t.label++;\n          n = a[1];\n          a = [0];\n          continue;\n        case 7:\n          a = t.ops.pop();\n          t.trys.pop();\n          continue;\n        default:\n          if (!(s = t.trys, s = s.length > 0 && s[s.length - 1]) && (a[0] === 6 || a[0] === 2)) {\n            t = 0;\n            continue;\n          }\n          if (a[0] === 3 && (!s || a[1] > s[0] && a[1] < s[3])) {\n            t.label = a[1];\n            break;\n          }\n          if (a[0] === 6 && t.label < s[1]) {\n            t.label = s[1];\n            s = a;\n            break;\n          }\n          if (s && t.label < s[2]) {\n            t.label = s[2];\n            t.ops.push(a);\n            break;\n          }\n          if (s[2]) t.ops.pop();\n          t.trys.pop();\n          continue;\n      }\n      a = r.call(e, t);\n    } catch (e) {\n      a = [6, e];\n      n = 0;\n    } finally {\n      i = s = 0;\n    }\n    if (a[0] & 5) throw a[1];\n    return {\n      value: a[0] ? a[1] : void 0,\n      done: true\n    };\n  }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (e, r, t) {\n  var i = new Error(t);\n  return i.name = \"SuppressedError\", i.error = e, i.suppressed = r, i;\n};\nvar TreeNode = function () {\n  function TreeNode(e, r, t) {\n    if (t === void 0) {\n      t = 1;\n    }\n    this.t = undefined;\n    this.i = undefined;\n    this.h = undefined;\n    this.u = e;\n    this.o = r;\n    this.l = t;\n  }\n  TreeNode.prototype.v = function () {\n    var e = this;\n    var r = e.h.h === e;\n    if (r && e.l === 1) {\n      e = e.i;\n    } else if (e.t) {\n      e = e.t;\n      while (e.i) {\n        e = e.i;\n      }\n    } else {\n      if (r) {\n        return e.h;\n      }\n      var t = e.h;\n      while (t.t === e) {\n        e = t;\n        t = e.h;\n      }\n      e = t;\n    }\n    return e;\n  };\n  TreeNode.prototype.p = function () {\n    var e = this;\n    if (e.i) {\n      e = e.i;\n      while (e.t) {\n        e = e.t;\n      }\n      return e;\n    } else {\n      var r = e.h;\n      while (r.i === e) {\n        e = r;\n        r = e.h;\n      }\n      if (e.i !== r) {\n        return r;\n      } else return e;\n    }\n  };\n  TreeNode.prototype.T = function () {\n    var e = this.h;\n    var r = this.i;\n    var t = r.t;\n    if (e.h === this) e.h = r;else if (e.t === this) e.t = r;else e.i = r;\n    r.h = e;\n    r.t = this;\n    this.h = r;\n    this.i = t;\n    if (t) t.h = this;\n    return r;\n  };\n  TreeNode.prototype.I = function () {\n    var e = this.h;\n    var r = this.t;\n    var t = r.i;\n    if (e.h === this) e.h = r;else if (e.t === this) e.t = r;else e.i = r;\n    r.h = e;\n    r.i = this;\n    this.h = r;\n    this.t = t;\n    if (t) t.h = this;\n    return r;\n  };\n  return TreeNode;\n}();\nvar TreeNodeEnableIndex = function (e) {\n  __extends(TreeNodeEnableIndex, e);\n  function TreeNodeEnableIndex() {\n    var r = e !== null && e.apply(this, arguments) || this;\n    r.O = 1;\n    return r;\n  }\n  TreeNodeEnableIndex.prototype.T = function () {\n    var r = e.prototype.T.call(this);\n    this.M();\n    r.M();\n    return r;\n  };\n  TreeNodeEnableIndex.prototype.I = function () {\n    var r = e.prototype.I.call(this);\n    this.M();\n    r.M();\n    return r;\n  };\n  TreeNodeEnableIndex.prototype.M = function () {\n    this.O = 1;\n    if (this.t) {\n      this.O += this.t.O;\n    }\n    if (this.i) {\n      this.O += this.i.O;\n    }\n  };\n  return TreeNodeEnableIndex;\n}(TreeNode);\nvar ContainerIterator = function () {\n  function ContainerIterator(e) {\n    if (e === void 0) {\n      e = 0;\n    }\n    this.iteratorType = e;\n  }\n  ContainerIterator.prototype.equals = function (e) {\n    return this.C === e.C;\n  };\n  return ContainerIterator;\n}();\nvar Base = function () {\n  function Base() {\n    this._ = 0;\n  }\n  Object.defineProperty(Base.prototype, \"length\", {\n    get: function () {\n      return this._;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Base.prototype.size = function () {\n    return this._;\n  };\n  Base.prototype.empty = function () {\n    return this._ === 0;\n  };\n  return Base;\n}();\nvar Container = function (e) {\n  __extends(Container, e);\n  function Container() {\n    return e !== null && e.apply(this, arguments) || this;\n  }\n  return Container;\n}(Base);\nfunction throwIteratorAccessError() {\n  throw new RangeError(\"Iterator access denied!\");\n}\nvar TreeContainer = function (e) {\n  __extends(TreeContainer, e);\n  function TreeContainer(r, t) {\n    if (r === void 0) {\n      r = function (e, r) {\n        if (e < r) return -1;\n        if (e > r) return 1;\n        return 0;\n      };\n    }\n    if (t === void 0) {\n      t = false;\n    }\n    var i = e.call(this) || this;\n    i.N = undefined;\n    i.g = r;\n    i.enableIndex = t;\n    i.S = t ? TreeNodeEnableIndex : TreeNode;\n    i.A = new i.S();\n    return i;\n  }\n  TreeContainer.prototype.m = function (e, r) {\n    var t = this.A;\n    while (e) {\n      var i = this.g(e.u, r);\n      if (i < 0) {\n        e = e.i;\n      } else if (i > 0) {\n        t = e;\n        e = e.t;\n      } else return e;\n    }\n    return t;\n  };\n  TreeContainer.prototype.B = function (e, r) {\n    var t = this.A;\n    while (e) {\n      var i = this.g(e.u, r);\n      if (i <= 0) {\n        e = e.i;\n      } else {\n        t = e;\n        e = e.t;\n      }\n    }\n    return t;\n  };\n  TreeContainer.prototype.j = function (e, r) {\n    var t = this.A;\n    while (e) {\n      var i = this.g(e.u, r);\n      if (i < 0) {\n        t = e;\n        e = e.i;\n      } else if (i > 0) {\n        e = e.t;\n      } else return e;\n    }\n    return t;\n  };\n  TreeContainer.prototype.k = function (e, r) {\n    var t = this.A;\n    while (e) {\n      var i = this.g(e.u, r);\n      if (i < 0) {\n        t = e;\n        e = e.i;\n      } else {\n        e = e.t;\n      }\n    }\n    return t;\n  };\n  TreeContainer.prototype.R = function (e) {\n    while (true) {\n      var r = e.h;\n      if (r === this.A) return;\n      if (e.l === 1) {\n        e.l = 0;\n        return;\n      }\n      if (e === r.t) {\n        var t = r.i;\n        if (t.l === 1) {\n          t.l = 0;\n          r.l = 1;\n          if (r === this.N) {\n            this.N = r.T();\n          } else r.T();\n        } else {\n          if (t.i && t.i.l === 1) {\n            t.l = r.l;\n            r.l = 0;\n            t.i.l = 0;\n            if (r === this.N) {\n              this.N = r.T();\n            } else r.T();\n            return;\n          } else if (t.t && t.t.l === 1) {\n            t.l = 1;\n            t.t.l = 0;\n            t.I();\n          } else {\n            t.l = 1;\n            e = r;\n          }\n        }\n      } else {\n        var t = r.t;\n        if (t.l === 1) {\n          t.l = 0;\n          r.l = 1;\n          if (r === this.N) {\n            this.N = r.I();\n          } else r.I();\n        } else {\n          if (t.t && t.t.l === 1) {\n            t.l = r.l;\n            r.l = 0;\n            t.t.l = 0;\n            if (r === this.N) {\n              this.N = r.I();\n            } else r.I();\n            return;\n          } else if (t.i && t.i.l === 1) {\n            t.l = 1;\n            t.i.l = 0;\n            t.T();\n          } else {\n            t.l = 1;\n            e = r;\n          }\n        }\n      }\n    }\n  };\n  TreeContainer.prototype.G = function (e) {\n    if (this._ === 1) {\n      this.clear();\n      return;\n    }\n    var r = e;\n    while (r.t || r.i) {\n      if (r.i) {\n        r = r.i;\n        while (r.t) r = r.t;\n      } else {\n        r = r.t;\n      }\n      var t = e.u;\n      e.u = r.u;\n      r.u = t;\n      var i = e.o;\n      e.o = r.o;\n      r.o = i;\n      e = r;\n    }\n    if (this.A.t === r) {\n      this.A.t = r.h;\n    } else if (this.A.i === r) {\n      this.A.i = r.h;\n    }\n    this.R(r);\n    var n = r.h;\n    if (r === n.t) {\n      n.t = undefined;\n    } else n.i = undefined;\n    this._ -= 1;\n    this.N.l = 0;\n    if (this.enableIndex) {\n      while (n !== this.A) {\n        n.O -= 1;\n        n = n.h;\n      }\n    }\n  };\n  TreeContainer.prototype.P = function (e) {\n    var r = typeof e === \"number\" ? e : undefined;\n    var t = typeof e === \"function\" ? e : undefined;\n    var i = typeof e === \"undefined\" ? [] : undefined;\n    var n = 0;\n    var s = this.N;\n    var h = [];\n    while (h.length || s) {\n      if (s) {\n        h.push(s);\n        s = s.t;\n      } else {\n        s = h.pop();\n        if (n === r) return s;\n        i && i.push(s);\n        t && t(s, n, this);\n        n += 1;\n        s = s.i;\n      }\n    }\n    return i;\n  };\n  TreeContainer.prototype.q = function (e) {\n    while (true) {\n      var r = e.h;\n      if (r.l === 0) return;\n      var t = r.h;\n      if (r === t.t) {\n        var i = t.i;\n        if (i && i.l === 1) {\n          i.l = r.l = 0;\n          if (t === this.N) return;\n          t.l = 1;\n          e = t;\n          continue;\n        } else if (e === r.i) {\n          e.l = 0;\n          if (e.t) {\n            e.t.h = r;\n          }\n          if (e.i) {\n            e.i.h = t;\n          }\n          r.i = e.t;\n          t.t = e.i;\n          e.t = r;\n          e.i = t;\n          if (t === this.N) {\n            this.N = e;\n            this.A.h = e;\n          } else {\n            var n = t.h;\n            if (n.t === t) {\n              n.t = e;\n            } else n.i = e;\n          }\n          e.h = t.h;\n          r.h = e;\n          t.h = e;\n          t.l = 1;\n        } else {\n          r.l = 0;\n          if (t === this.N) {\n            this.N = t.I();\n          } else t.I();\n          t.l = 1;\n          return;\n        }\n      } else {\n        var i = t.t;\n        if (i && i.l === 1) {\n          i.l = r.l = 0;\n          if (t === this.N) return;\n          t.l = 1;\n          e = t;\n          continue;\n        } else if (e === r.t) {\n          e.l = 0;\n          if (e.t) {\n            e.t.h = t;\n          }\n          if (e.i) {\n            e.i.h = r;\n          }\n          t.i = e.t;\n          r.t = e.i;\n          e.t = t;\n          e.i = r;\n          if (t === this.N) {\n            this.N = e;\n            this.A.h = e;\n          } else {\n            var n = t.h;\n            if (n.t === t) {\n              n.t = e;\n            } else n.i = e;\n          }\n          e.h = t.h;\n          r.h = e;\n          t.h = e;\n          t.l = 1;\n        } else {\n          r.l = 0;\n          if (t === this.N) {\n            this.N = t.T();\n          } else t.T();\n          t.l = 1;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        r.M();\n        t.M();\n        e.M();\n      }\n      return;\n    }\n  };\n  TreeContainer.prototype.D = function (e, r, t) {\n    if (this.N === undefined) {\n      this._ += 1;\n      this.N = new this.S(e, r, 0);\n      this.N.h = this.A;\n      this.A.h = this.A.t = this.A.i = this.N;\n      return this._;\n    }\n    var i;\n    var n = this.A.t;\n    var s = this.g(n.u, e);\n    if (s === 0) {\n      n.o = r;\n      return this._;\n    } else if (s > 0) {\n      n.t = new this.S(e, r);\n      n.t.h = n;\n      i = n.t;\n      this.A.t = i;\n    } else {\n      var h = this.A.i;\n      var a = this.g(h.u, e);\n      if (a === 0) {\n        h.o = r;\n        return this._;\n      } else if (a < 0) {\n        h.i = new this.S(e, r);\n        h.i.h = h;\n        i = h.i;\n        this.A.i = i;\n      } else {\n        if (t !== undefined) {\n          var u = t.C;\n          if (u !== this.A) {\n            var f = this.g(u.u, e);\n            if (f === 0) {\n              u.o = r;\n              return this._;\n            } else if (f > 0) {\n              var o = u.v();\n              var d = this.g(o.u, e);\n              if (d === 0) {\n                o.o = r;\n                return this._;\n              } else if (d < 0) {\n                i = new this.S(e, r);\n                if (o.i === undefined) {\n                  o.i = i;\n                  i.h = o;\n                } else {\n                  u.t = i;\n                  i.h = u;\n                }\n              }\n            }\n          }\n        }\n        if (i === undefined) {\n          i = this.N;\n          while (true) {\n            var c = this.g(i.u, e);\n            if (c > 0) {\n              if (i.t === undefined) {\n                i.t = new this.S(e, r);\n                i.t.h = i;\n                i = i.t;\n                break;\n              }\n              i = i.t;\n            } else if (c < 0) {\n              if (i.i === undefined) {\n                i.i = new this.S(e, r);\n                i.i.h = i;\n                i = i.i;\n                break;\n              }\n              i = i.i;\n            } else {\n              i.o = r;\n              return this._;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      var l = i.h;\n      while (l !== this.A) {\n        l.O += 1;\n        l = l.h;\n      }\n    }\n    this.q(i);\n    this._ += 1;\n    return this._;\n  };\n  TreeContainer.prototype.F = function (e, r) {\n    while (e) {\n      var t = this.g(e.u, r);\n      if (t < 0) {\n        e = e.i;\n      } else if (t > 0) {\n        e = e.t;\n      } else return e;\n    }\n    return e || this.A;\n  };\n  TreeContainer.prototype.clear = function () {\n    this._ = 0;\n    this.N = undefined;\n    this.A.h = undefined;\n    this.A.t = this.A.i = undefined;\n  };\n  TreeContainer.prototype.updateKeyByIterator = function (e, r) {\n    var t = e.C;\n    if (t === this.A) {\n      throwIteratorAccessError();\n    }\n    if (this._ === 1) {\n      t.u = r;\n      return true;\n    }\n    var i = t.p().u;\n    if (t === this.A.t) {\n      if (this.g(i, r) > 0) {\n        t.u = r;\n        return true;\n      }\n      return false;\n    }\n    var n = t.v().u;\n    if (t === this.A.i) {\n      if (this.g(n, r) < 0) {\n        t.u = r;\n        return true;\n      }\n      return false;\n    }\n    if (this.g(n, r) >= 0 || this.g(i, r) <= 0) return false;\n    t.u = r;\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByPos = function (e) {\n    if (e < 0 || e > this._ - 1) {\n      throw new RangeError();\n    }\n    var r = this.P(e);\n    this.G(r);\n    return this._;\n  };\n  TreeContainer.prototype.eraseElementByKey = function (e) {\n    if (this._ === 0) return false;\n    var r = this.F(this.N, e);\n    if (r === this.A) return false;\n    this.G(r);\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByIterator = function (e) {\n    var r = e.C;\n    if (r === this.A) {\n      throwIteratorAccessError();\n    }\n    var t = r.i === undefined;\n    var i = e.iteratorType === 0;\n    if (i) {\n      if (t) e.next();\n    } else {\n      if (!t || r.t === undefined) e.next();\n    }\n    this.G(r);\n    return e;\n  };\n  TreeContainer.prototype.getHeight = function () {\n    if (this._ === 0) return 0;\n    function traversal(e) {\n      if (!e) return 0;\n      return Math.max(traversal(e.t), traversal(e.i)) + 1;\n    }\n    return traversal(this.N);\n  };\n  return TreeContainer;\n}(Container);\nvar TreeIterator = function (e) {\n  __extends(TreeIterator, e);\n  function TreeIterator(r, t, i) {\n    var n = e.call(this, i) || this;\n    n.C = r;\n    n.A = t;\n    if (n.iteratorType === 0) {\n      n.pre = function () {\n        if (this.C === this.A.t) {\n          throwIteratorAccessError();\n        }\n        this.C = this.C.v();\n        return this;\n      };\n      n.next = function () {\n        if (this.C === this.A) {\n          throwIteratorAccessError();\n        }\n        this.C = this.C.p();\n        return this;\n      };\n    } else {\n      n.pre = function () {\n        if (this.C === this.A.i) {\n          throwIteratorAccessError();\n        }\n        this.C = this.C.p();\n        return this;\n      };\n      n.next = function () {\n        if (this.C === this.A) {\n          throwIteratorAccessError();\n        }\n        this.C = this.C.v();\n        return this;\n      };\n    }\n    return n;\n  }\n  Object.defineProperty(TreeIterator.prototype, \"index\", {\n    get: function () {\n      var e = this.C;\n      var r = this.A.h;\n      if (e === this.A) {\n        if (r) {\n          return r.O - 1;\n        }\n        return 0;\n      }\n      var t = 0;\n      if (e.t) {\n        t += e.t.O;\n      }\n      while (e !== r) {\n        var i = e.h;\n        if (e === i.i) {\n          t += 1;\n          if (i.t) {\n            t += i.t.O;\n          }\n        }\n        e = i;\n      }\n      return t;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TreeIterator.prototype.isAccessible = function () {\n    return this.C !== this.A;\n  };\n  return TreeIterator;\n}(ContainerIterator);\nvar OrderedMapIterator = function (e) {\n  __extends(OrderedMapIterator, e);\n  function OrderedMapIterator(r, t, i, n) {\n    var s = e.call(this, r, t, n) || this;\n    s.container = i;\n    return s;\n  }\n  Object.defineProperty(OrderedMapIterator.prototype, \"pointer\", {\n    get: function () {\n      if (this.C === this.A) {\n        throwIteratorAccessError();\n      }\n      var e = this;\n      return new Proxy([], {\n        get: function (r, t) {\n          if (t === \"0\") return e.C.u;else if (t === \"1\") return e.C.o;\n          r[0] = e.C.u;\n          r[1] = e.C.o;\n          return r[t];\n        },\n        set: function (r, t, i) {\n          if (t !== \"1\") {\n            throw new TypeError(\"prop must be 1\");\n          }\n          e.C.o = i;\n          return true;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  OrderedMapIterator.prototype.copy = function () {\n    return new OrderedMapIterator(this.C, this.A, this.container, this.iteratorType);\n  };\n  return OrderedMapIterator;\n}(TreeIterator);\nvar OrderedMap = function (e) {\n  __extends(OrderedMap, e);\n  function OrderedMap(r, t, i) {\n    if (r === void 0) {\n      r = [];\n    }\n    var n = e.call(this, t, i) || this;\n    var s = n;\n    r.forEach(function (e) {\n      s.setElement(e[0], e[1]);\n    });\n    return n;\n  }\n  OrderedMap.prototype.begin = function () {\n    return new OrderedMapIterator(this.A.t || this.A, this.A, this);\n  };\n  OrderedMap.prototype.end = function () {\n    return new OrderedMapIterator(this.A, this.A, this);\n  };\n  OrderedMap.prototype.rBegin = function () {\n    return new OrderedMapIterator(this.A.i || this.A, this.A, this, 1);\n  };\n  OrderedMap.prototype.rEnd = function () {\n    return new OrderedMapIterator(this.A, this.A, this, 1);\n  };\n  OrderedMap.prototype.front = function () {\n    if (this._ === 0) return;\n    var e = this.A.t;\n    return [e.u, e.o];\n  };\n  OrderedMap.prototype.back = function () {\n    if (this._ === 0) return;\n    var e = this.A.i;\n    return [e.u, e.o];\n  };\n  OrderedMap.prototype.lowerBound = function (e) {\n    var r = this.m(this.N, e);\n    return new OrderedMapIterator(r, this.A, this);\n  };\n  OrderedMap.prototype.upperBound = function (e) {\n    var r = this.B(this.N, e);\n    return new OrderedMapIterator(r, this.A, this);\n  };\n  OrderedMap.prototype.reverseLowerBound = function (e) {\n    var r = this.j(this.N, e);\n    return new OrderedMapIterator(r, this.A, this);\n  };\n  OrderedMap.prototype.reverseUpperBound = function (e) {\n    var r = this.k(this.N, e);\n    return new OrderedMapIterator(r, this.A, this);\n  };\n  OrderedMap.prototype.forEach = function (e) {\n    this.P(function (r, t, i) {\n      e([r.u, r.o], t, i);\n    });\n  };\n  OrderedMap.prototype.setElement = function (e, r, t) {\n    return this.D(e, r, t);\n  };\n  OrderedMap.prototype.getElementByPos = function (e) {\n    if (e < 0 || e > this._ - 1) {\n      throw new RangeError();\n    }\n    var r = this.P(e);\n    return [r.u, r.o];\n  };\n  OrderedMap.prototype.find = function (e) {\n    var r = this.F(this.N, e);\n    return new OrderedMapIterator(r, this.A, this);\n  };\n  OrderedMap.prototype.getElementByKey = function (e) {\n    var r = this.F(this.N, e);\n    return r.o;\n  };\n  OrderedMap.prototype.union = function (e) {\n    var r = this;\n    e.forEach(function (e) {\n      r.setElement(e[0], e[1]);\n    });\n    return this._;\n  };\n  OrderedMap.prototype[Symbol.iterator] = function () {\n    var e, r, t, i;\n    return __generator(this, function (n) {\n      switch (n.label) {\n        case 0:\n          e = this._;\n          r = this.P();\n          t = 0;\n          n.label = 1;\n        case 1:\n          if (!(t < e)) return [3, 4];\n          i = r[t];\n          return [4, [i.u, i.o]];\n        case 2:\n          n.sent();\n          n.label = 3;\n        case 3:\n          ++t;\n          return [3, 1];\n        case 4:\n          return [2];\n      }\n    });\n  };\n  return OrderedMap;\n}(TreeContainer);\nexport { OrderedMap };","map":{"version":3,"names":["extendStatics","e","r","Object","setPrototypeOf","__proto__","Array","t","prototype","hasOwnProperty","call","__extends","TypeError","String","__","constructor","create","__generator","label","sent","s","trys","ops","i","n","h","next","verb","throw","return","Symbol","iterator","step","a","done","value","pop","length","push","SuppressedError","Error","name","error","suppressed","TreeNode","undefined","u","o","l","v","p","T","I","TreeNodeEnableIndex","apply","arguments","O","M","ContainerIterator","iteratorType","equals","C","Base","_","defineProperty","get","enumerable","configurable","size","empty","Container","throwIteratorAccessError","RangeError","TreeContainer","cmp","N","g","enableIndex","S","A","m","B","j","k","R","G","clear","P","q","D","f","d","c","F","updateKeyByIterator","eraseElementByPos","eraseElementByKey","eraseElementByIterator","getHeight","traversal","Math","max","TreeIterator","pre","isAccessible","OrderedMapIterator","container","Proxy","set","copy","OrderedMap","forEach","setElement","begin","end","rBegin","rEnd","front","back","lowerBound","upperBound","reverseLowerBound","reverseUpperBound","getElementByPos","find","getElementByKey","union"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/tslib/tslib.es6.js","/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@js-sdsl/ordered-map/dist/esm/index.js","/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@js-sdsl/.build-data/copied-source/src/container/TreeContainer/Base/TreeNode.ts","/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@js-sdsl/.build-data/copied-source/src/container/ContainerBase/index.ts","/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@js-sdsl/.build-data/copied-source/src/utils/throwError.ts","/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@js-sdsl/.build-data/copied-source/src/container/TreeContainer/Base/index.ts","/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@js-sdsl/.build-data/copied-source/src/container/TreeContainer/Base/TreeIterator.ts","/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@js-sdsl/.build-data/copied-source/src/container/TreeContainer/OrderedMap.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends,\r\n    __assign,\r\n    __rest,\r\n    __decorate,\r\n    __param,\r\n    __metadata,\r\n    __awaiter,\r\n    __generator,\r\n    __createBinding,\r\n    __exportStar,\r\n    __values,\r\n    __read,\r\n    __spread,\r\n    __spreadArrays,\r\n    __spreadArray,\r\n    __await,\r\n    __asyncGenerator,\r\n    __asyncDelegator,\r\n    __asyncValues,\r\n    __makeTemplateObject,\r\n    __importStar,\r\n    __importDefault,\r\n    __classPrivateFieldGet,\r\n    __classPrivateFieldSet,\r\n    __classPrivateFieldIn,\r\n    __addDisposableResource,\r\n    __disposeResources,\r\n};\r\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __generator(thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nvar TreeNode = /** @class */function () {\n  function TreeNode(key, value, color) {\n    if (color === void 0) {\n      color = 1 /* TreeNodeColor.RED */;\n    }\n    this._left = undefined;\n    this._right = undefined;\n    this._parent = undefined;\n    this._key = key;\n    this._value = value;\n    this._color = color;\n  }\n  /**\n   * @description Get the pre node.\n   * @returns TreeNode about the pre node.\n   */\n  TreeNode.prototype._pre = function () {\n    var preNode = this;\n    var isRootOrHeader = preNode._parent._parent === preNode;\n    if (isRootOrHeader && preNode._color === 1 /* TreeNodeColor.RED */) {\n      preNode = preNode._right;\n    } else if (preNode._left) {\n      preNode = preNode._left;\n      while (preNode._right) {\n        preNode = preNode._right;\n      }\n    } else {\n      // Must be root and left is null\n      if (isRootOrHeader) {\n        return preNode._parent;\n      }\n      var pre = preNode._parent;\n      while (pre._left === preNode) {\n        preNode = pre;\n        pre = preNode._parent;\n      }\n      preNode = pre;\n    }\n    return preNode;\n  };\n  /**\n   * @description Get the next node.\n   * @returns TreeNode about the next node.\n   */\n  TreeNode.prototype._next = function () {\n    var nextNode = this;\n    if (nextNode._right) {\n      nextNode = nextNode._right;\n      while (nextNode._left) {\n        nextNode = nextNode._left;\n      }\n      return nextNode;\n    } else {\n      var pre = nextNode._parent;\n      while (pre._right === nextNode) {\n        nextNode = pre;\n        pre = nextNode._parent;\n      }\n      if (nextNode._right !== pre) {\n        return pre;\n      } else return nextNode;\n    }\n  };\n  /**\n   * @description Rotate left.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  TreeNode.prototype._rotateLeft = function () {\n    var PP = this._parent;\n    var V = this._right;\n    var R = V._left;\n    if (PP._parent === this) PP._parent = V;else if (PP._left === this) PP._left = V;else PP._right = V;\n    V._parent = PP;\n    V._left = this;\n    this._parent = V;\n    this._right = R;\n    if (R) R._parent = this;\n    return V;\n  };\n  /**\n   * @description Rotate right.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  TreeNode.prototype._rotateRight = function () {\n    var PP = this._parent;\n    var F = this._left;\n    var K = F._right;\n    if (PP._parent === this) PP._parent = F;else if (PP._left === this) PP._left = F;else PP._right = F;\n    F._parent = PP;\n    F._right = this;\n    this._parent = F;\n    this._left = K;\n    if (K) K._parent = this;\n    return F;\n  };\n  return TreeNode;\n}();\nvar TreeNodeEnableIndex = /** @class */function (_super) {\n  __extends(TreeNodeEnableIndex, _super);\n  function TreeNodeEnableIndex() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._subTreeSize = 1;\n    return _this;\n  }\n  /**\n   * @description Rotate left and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  TreeNodeEnableIndex.prototype._rotateLeft = function () {\n    var parent = _super.prototype._rotateLeft.call(this);\n    this._recount();\n    parent._recount();\n    return parent;\n  };\n  /**\n   * @description Rotate right and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  TreeNodeEnableIndex.prototype._rotateRight = function () {\n    var parent = _super.prototype._rotateRight.call(this);\n    this._recount();\n    parent._recount();\n    return parent;\n  };\n  TreeNodeEnableIndex.prototype._recount = function () {\n    this._subTreeSize = 1;\n    if (this._left) {\n      this._subTreeSize += this._left._subTreeSize;\n    }\n    if (this._right) {\n      this._subTreeSize += this._right._subTreeSize;\n    }\n  };\n  return TreeNodeEnableIndex;\n}(TreeNode);\n\nvar ContainerIterator = /** @class */function () {\n  /**\n   * @internal\n   */\n  function ContainerIterator(iteratorType) {\n    if (iteratorType === void 0) {\n      iteratorType = 0 /* IteratorType.NORMAL */;\n    }\n    this.iteratorType = iteratorType;\n  }\n  /**\n   * @param iter - The other iterator you want to compare.\n   * @returns Whether this equals to obj.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  ContainerIterator.prototype.equals = function (iter) {\n    return this._node === iter._node;\n  };\n  return ContainerIterator;\n}();\nvar Base = /** @class */function () {\n  function Base() {\n    /**\n     * @description Container's size.\n     * @internal\n     */\n    this._length = 0;\n  }\n  Object.defineProperty(Base.prototype, \"length\", {\n    /**\n     * @returns The size of the container.\n     * @example\n     * const container = new Vector([1, 2]);\n     * console.log(container.length); // 2\n     */\n    get: function () {\n      return this._length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.size()); // 2\n   */\n  Base.prototype.size = function () {\n    return this._length;\n  };\n  /**\n   * @returns Whether the container is empty.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  Base.prototype.empty = function () {\n    return this._length === 0;\n  };\n  return Base;\n}();\nvar Container = /** @class */function (_super) {\n  __extends(Container, _super);\n  function Container() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return Container;\n}(Base);\n\n/**\n * @description Throw an iterator access error.\n * @internal\n */\nfunction throwIteratorAccessError() {\n  throw new RangeError('Iterator access denied!');\n}\n\nvar TreeContainer = /** @class */function (_super) {\n  __extends(TreeContainer, _super);\n  /**\n   * @internal\n   */\n  function TreeContainer(cmp, enableIndex) {\n    if (cmp === void 0) {\n      cmp = function (x, y) {\n        if (x < y) return -1;\n        if (x > y) return 1;\n        return 0;\n      };\n    }\n    if (enableIndex === void 0) {\n      enableIndex = false;\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * @internal\n     */\n    _this._root = undefined;\n    _this._cmp = cmp;\n    _this.enableIndex = enableIndex;\n    _this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    _this._header = new _this._TreeNodeClass();\n    return _this;\n  }\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._lowerBound = function (curNode, key) {\n    var resNode = this._header;\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._upperBound = function (curNode, key) {\n    var resNode = this._header;\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._reverseLowerBound = function (curNode, key) {\n    var resNode = this._header;\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._reverseUpperBound = function (curNode, key) {\n    var resNode = this._header;\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._eraseNodeSelfBalance = function (curNode) {\n    while (true) {\n      var parentNode = curNode._parent;\n      if (parentNode === this._header) return;\n      if (curNode._color === 1 /* TreeNodeColor.RED */) {\n        curNode._color = 0 /* TreeNodeColor.BLACK */;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        var brother = parentNode._right;\n        if (brother._color === 1 /* TreeNodeColor.RED */) {\n          brother._color = 0 /* TreeNodeColor.BLACK */;\n          parentNode._color = 1 /* TreeNodeColor.RED */;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = parentNode._color;\n            parentNode._color = 0 /* TreeNodeColor.BLACK */;\n            brother._right._color = 0 /* TreeNodeColor.BLACK */;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            brother._left._color = 0 /* TreeNodeColor.BLACK */;\n            brother._rotateRight();\n          } else {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        var brother = parentNode._left;\n        if (brother._color === 1 /* TreeNodeColor.RED */) {\n          brother._color = 0 /* TreeNodeColor.BLACK */;\n          parentNode._color = 1 /* TreeNodeColor.RED */;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = parentNode._color;\n            parentNode._color = 0 /* TreeNodeColor.BLACK */;\n            brother._left._color = 0 /* TreeNodeColor.BLACK */;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            brother._right._color = 0 /* TreeNodeColor.BLACK */;\n            brother._rotateLeft();\n          } else {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._eraseNode = function (curNode) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    var swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left;\n      }\n      var key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      var value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    var _parent = swapNode._parent;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root._color = 0 /* TreeNodeColor.BLACK */;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent;\n      }\n    }\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._inOrderTraversal = function (param) {\n    var pos = typeof param === 'number' ? param : undefined;\n    var callback = typeof param === 'function' ? param : undefined;\n    var nodeList = typeof param === 'undefined' ? [] : undefined;\n    var index = 0;\n    var curNode = this._root;\n    var stack = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop();\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._insertNodeSelfBalance = function (curNode) {\n    while (true) {\n      var parentNode = curNode._parent;\n      if (parentNode._color === 0 /* TreeNodeColor.BLACK */) return;\n      var grandParent = parentNode._parent;\n      if (parentNode === grandParent._left) {\n        var uncle = grandParent._right;\n        if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n          uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) return;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            var GP = grandParent._parent;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n        } else {\n          parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          return;\n        }\n      } else {\n        var uncle = grandParent._left;\n        if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n          uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) return;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            var GP = grandParent._parent;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n        } else {\n          parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        parentNode._recount();\n        grandParent._recount();\n        curNode._recount();\n      }\n      return;\n    }\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._set = function (key, value, hint) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, 0 /* TreeNodeColor.BLACK */);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    var curNode;\n    var minNode = this._header._left;\n    var compareToMin = this._cmp(minNode._key, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      var maxNode = this._header._right;\n      var compareToMax = this._cmp(maxNode._key, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          var iterNode = hint._node;\n          if (iterNode !== this._header) {\n            var iterCmpRes = this._cmp(iterNode._key, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */if (iterCmpRes > 0) {\n                var preNode = iterNode._pre();\n                var preCmpRes = this._cmp(preNode._key, key);\n                if (preCmpRes === 0) {\n                  preNode._value = value;\n                  return this._length;\n                } else if (preCmpRes < 0) {\n                  curNode = new this._TreeNodeClass(key, value);\n                  if (preNode._right === undefined) {\n                    preNode._right = curNode;\n                    curNode._parent = preNode;\n                  } else {\n                    iterNode._left = curNode;\n                    curNode._parent = iterNode;\n                  }\n                }\n              }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      var parent_1 = curNode._parent;\n      while (parent_1 !== this._header) {\n        parent_1._subTreeSize += 1;\n        parent_1 = parent_1._parent;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._getTreeNodeByKey = function (curNode, key) {\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  };\n  TreeContainer.prototype.clear = function () {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  };\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  TreeContainer.prototype.updateKeyByIterator = function (iter, key) {\n    var node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    var nextKey = node._next()._key;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    var preKey = node._pre()._key;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (this._cmp(preKey, key) >= 0 || this._cmp(nextKey, key) <= 0) return false;\n    node._key = key;\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByPos = function (pos) {\n    if (pos < 0 || pos > this._length - 1) {\n      throw new RangeError();\n    }\n    var node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  };\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  TreeContainer.prototype.eraseElementByKey = function (key) {\n    if (this._length === 0) return false;\n    var curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByIterator = function (iter) {\n    var node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    var hasNoRight = node._right === undefined;\n    var isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  };\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  TreeContainer.prototype.getHeight = function () {\n    if (this._length === 0) return 0;\n    function traversal(curNode) {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  };\n  return TreeContainer;\n}(Container);\n\nvar TreeIterator = /** @class */function (_super) {\n  __extends(TreeIterator, _super);\n  /**\n   * @internal\n   */\n  function TreeIterator(node, header, iteratorType) {\n    var _this = _super.call(this, iteratorType) || this;\n    _this._node = node;\n    _this._header = header;\n    if (_this.iteratorType === 0 /* IteratorType.NORMAL */) {\n      _this.pre = function () {\n        if (this._node === this._header._left) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n      _this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n    } else {\n      _this.pre = function () {\n        if (this._node === this._header._right) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n      _this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n    }\n    return _this;\n  }\n  Object.defineProperty(TreeIterator.prototype, \"index\", {\n    /**\n     * @description Get the sequential index of the iterator in the tree container.<br/>\n     *              <strong>Note:</strong>\n     *              This function only takes effect when the specified tree container `enableIndex = true`.\n     * @returns The index subscript of the node in the tree.\n     * @example\n     * const st = new OrderedSet([1, 2, 3], true);\n     * console.log(st.begin().next().index);  // 1\n     */\n    get: function () {\n      var _node = this._node;\n      var root = this._header._parent;\n      if (_node === this._header) {\n        if (root) {\n          return root._subTreeSize - 1;\n        }\n        return 0;\n      }\n      var index = 0;\n      if (_node._left) {\n        index += _node._left._subTreeSize;\n      }\n      while (_node !== root) {\n        var _parent = _node._parent;\n        if (_node === _parent._right) {\n          index += 1;\n          if (_parent._left) {\n            index += _parent._left._subTreeSize;\n          }\n        }\n        _node = _parent;\n      }\n      return index;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TreeIterator.prototype.isAccessible = function () {\n    return this._node !== this._header;\n  };\n  return TreeIterator;\n}(ContainerIterator);\n\nvar OrderedMapIterator = /** @class */function (_super) {\n  __extends(OrderedMapIterator, _super);\n  function OrderedMapIterator(node, header, container, iteratorType) {\n    var _this = _super.call(this, node, header, iteratorType) || this;\n    _this.container = container;\n    return _this;\n  }\n  Object.defineProperty(OrderedMapIterator.prototype, \"pointer\", {\n    get: function () {\n      if (this._node === this._header) {\n        throwIteratorAccessError();\n      }\n      var self = this;\n      return new Proxy([], {\n        get: function (target, prop) {\n          if (prop === '0') return self._node._key;else if (prop === '1') return self._node._value;\n          target[0] = self._node._key;\n          target[1] = self._node._value;\n          return target[prop];\n        },\n        set: function (_, prop, newValue) {\n          if (prop !== '1') {\n            throw new TypeError('prop must be 1');\n          }\n          self._node._value = newValue;\n          return true;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  OrderedMapIterator.prototype.copy = function () {\n    return new OrderedMapIterator(this._node, this._header, this.container, this.iteratorType);\n  };\n  return OrderedMapIterator;\n}(TreeIterator);\nvar OrderedMap = /** @class */function (_super) {\n  __extends(OrderedMap, _super);\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedMap();\n   * new OrderedMap([[0, 1], [2, 1]]);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n   */\n  function OrderedMap(container, cmp, enableIndex) {\n    if (container === void 0) {\n      container = [];\n    }\n    var _this = _super.call(this, cmp, enableIndex) || this;\n    var self = _this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return _this;\n  }\n  OrderedMap.prototype.begin = function () {\n    return new OrderedMapIterator(this._header._left || this._header, this._header, this);\n  };\n  OrderedMap.prototype.end = function () {\n    return new OrderedMapIterator(this._header, this._header, this);\n  };\n  OrderedMap.prototype.rBegin = function () {\n    return new OrderedMapIterator(this._header._right || this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n  };\n\n  OrderedMap.prototype.rEnd = function () {\n    return new OrderedMapIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n  };\n\n  OrderedMap.prototype.front = function () {\n    if (this._length === 0) return;\n    var minNode = this._header._left;\n    return [minNode._key, minNode._value];\n  };\n  OrderedMap.prototype.back = function () {\n    if (this._length === 0) return;\n    var maxNode = this._header._right;\n    return [maxNode._key, maxNode._value];\n  };\n  OrderedMap.prototype.lowerBound = function (key) {\n    var resNode = this._lowerBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  };\n  OrderedMap.prototype.upperBound = function (key) {\n    var resNode = this._upperBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  };\n  OrderedMap.prototype.reverseLowerBound = function (key) {\n    var resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  };\n  OrderedMap.prototype.reverseUpperBound = function (key) {\n    var resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  };\n  OrderedMap.prototype.forEach = function (callback) {\n    this._inOrderTraversal(function (node, index, map) {\n      callback([node._key, node._value], index, map);\n    });\n  };\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n   * const iter = mp.begin();\n   * mp.setElement(1, 0);\n   * mp.setElement(3, 0, iter);  // give a hint will be faster.\n   */\n  OrderedMap.prototype.setElement = function (key, value, hint) {\n    return this._set(key, value, hint);\n  };\n  OrderedMap.prototype.getElementByPos = function (pos) {\n    if (pos < 0 || pos > this._length - 1) {\n      throw new RangeError();\n    }\n    var node = this._inOrderTraversal(pos);\n    return [node._key, node._value];\n  };\n  OrderedMap.prototype.find = function (key) {\n    var curNode = this._getTreeNodeByKey(this._root, key);\n    return new OrderedMapIterator(curNode, this._header, this);\n  };\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The specified key you want to get.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  OrderedMap.prototype.getElementByKey = function (key) {\n    var curNode = this._getTreeNodeByKey(this._root, key);\n    return curNode._value;\n  };\n  OrderedMap.prototype.union = function (other) {\n    var self = this;\n    other.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return this._length;\n  };\n  OrderedMap.prototype[Symbol.iterator] = function () {\n    var length, nodeList, i, node;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          length = this._length;\n          nodeList = this._inOrderTraversal();\n          i = 0;\n          _a.label = 1;\n        case 1:\n          if (!(i < length)) return [3 /*break*/, 4];\n          node = nodeList[i];\n          return [4 /*yield*/, [node._key, node._value]];\n        case 2:\n          _a.sent();\n          _a.label = 3;\n        case 3:\n          ++i;\n          return [3 /*break*/, 1];\n        case 4:\n          return [2 /*return*/];\n      }\n    });\n  };\n\n  return OrderedMap;\n}(TreeContainer);\n\nexport { OrderedMap };\n//# sourceMappingURL=index.js.map\n","export const enum TreeNodeColor {\n  RED = 1,\n  BLACK = 0\n}\n\nexport class TreeNode<K, V> {\n  _color: TreeNodeColor;\n  _key: K | undefined;\n  _value: V | undefined;\n  _left: TreeNode<K, V> | undefined = undefined;\n  _right: TreeNode<K, V> | undefined = undefined;\n  _parent: TreeNode<K, V> | undefined = undefined;\n  constructor(\n    key?: K,\n    value?: V,\n    color: TreeNodeColor = TreeNodeColor.RED\n  ) {\n    this._key = key;\n    this._value = value;\n    this._color = color;\n  }\n  /**\n   * @description Get the pre node.\n   * @returns TreeNode about the pre node.\n   */\n  _pre() {\n    let preNode: TreeNode<K, V> = this;\n    const isRootOrHeader = preNode._parent!._parent === preNode;\n    if (isRootOrHeader && preNode._color === TreeNodeColor.RED) {\n      preNode = preNode._right!;\n    } else if (preNode._left) {\n      preNode = preNode._left;\n      while (preNode._right) {\n        preNode = preNode._right;\n      }\n    } else {\n      // Must be root and left is null\n      if (isRootOrHeader) {\n        return preNode._parent!;\n      }\n      let pre = preNode._parent!;\n      while (pre._left === preNode) {\n        preNode = pre;\n        pre = preNode._parent!;\n      }\n      preNode = pre;\n    }\n    return preNode;\n  }\n  /**\n   * @description Get the next node.\n   * @returns TreeNode about the next node.\n   */\n  _next() {\n    let nextNode: TreeNode<K, V> = this;\n    if (nextNode._right) {\n      nextNode = nextNode._right;\n      while (nextNode._left) {\n        nextNode = nextNode._left;\n      }\n      return nextNode;\n    } else {\n      let pre = nextNode._parent!;\n      while (pre._right === nextNode) {\n        nextNode = pre;\n        pre = nextNode._parent!;\n      }\n      if (nextNode._right !== pre) {\n        return pre;\n      } else return nextNode;\n    }\n  }\n  /**\n   * @description Rotate left.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const PP = this._parent!;\n    const V = this._right!;\n    const R = V._left;\n\n    if (PP._parent === this) PP._parent = V;\n    else if (PP._left === this) PP._left = V;\n    else PP._right = V;\n\n    V._parent = PP;\n    V._left = this;\n\n    this._parent = V;\n    this._right = R;\n\n    if (R) R._parent = this;\n\n    return V;\n  }\n  /**\n   * @description Rotate right.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const PP = this._parent!;\n    const F = this._left!;\n    const K = F._right;\n\n    if (PP._parent === this) PP._parent = F;\n    else if (PP._left === this) PP._left = F;\n    else PP._right = F;\n\n    F._parent = PP;\n    F._right = this;\n\n    this._parent = F;\n    this._left = K;\n\n    if (K) K._parent = this;\n\n    return F;\n  }\n}\n\nexport class TreeNodeEnableIndex<K, V> extends TreeNode<K, V> {\n  _subTreeSize = 1;\n  /**\n   * @description Rotate left and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const parent = super._rotateLeft() as TreeNodeEnableIndex<K, V>;\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  /**\n   * @description Rotate right and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const parent = super._rotateRight() as TreeNodeEnableIndex<K, V>;\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  _recount() {\n    this._subTreeSize = 1;\n    if (this._left) {\n      this._subTreeSize += (this._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n    if (this._right) {\n      this._subTreeSize += (this._right as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n  }\n}\n","/**\n * @description The iterator type including `NORMAL` and `REVERSE`.\n */\nexport const enum IteratorType {\n  NORMAL = 0,\n  REVERSE = 1\n}\n\nexport abstract class ContainerIterator<T> {\n  /**\n   * @description The container pointed to by the iterator.\n   */\n  abstract readonly container: Container<T>;\n  /**\n   * @internal\n   */\n  abstract _node: unknown;\n  /**\n   * @description Iterator's type.\n   * @example\n   * console.log(container.end().iteratorType === IteratorType.NORMAL);  // true\n   */\n  readonly iteratorType: IteratorType;\n  /**\n   * @internal\n   */\n  protected constructor(iteratorType = IteratorType.NORMAL) {\n    this.iteratorType = iteratorType;\n  }\n  /**\n   * @param iter - The other iterator you want to compare.\n   * @returns Whether this equals to obj.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  equals(iter: ContainerIterator<T>) {\n    return this._node === iter._node;\n  }\n  /**\n   * @description Pointers to element.\n   * @returns The value of the pointer's element.\n   * @example\n   * const val = container.begin().pointer;\n   */\n  abstract get pointer(): T;\n  /**\n   * @description Set pointer's value (some containers are unavailable).\n   * @param newValue - The new value you want to set.\n   * @example\n   * (<LinkList<number>>container).begin().pointer = 1;\n   */\n  abstract set pointer(newValue: T);\n  /**\n   * @description Move `this` iterator to pre.\n   * @returns The iterator's self.\n   * @example\n   * const iter = container.find(1);  // container = [0, 1]\n   * const pre = iter.pre();\n   * console.log(pre === iter);  // true\n   * console.log(pre.equals(iter));  // true\n   * console.log(pre.pointer, iter.pointer); // 0, 0\n   */\n  abstract pre(): this;\n  /**\n   * @description Move `this` iterator to next.\n   * @returns The iterator's self.\n   * @example\n   * const iter = container.find(1);  // container = [1, 2]\n   * const next = iter.next();\n   * console.log(next === iter);  // true\n   * console.log(next.equals(iter));  // true\n   * console.log(next.pointer, iter.pointer); // 2, 2\n   */\n  abstract next(): this;\n  /**\n   * @description Get a copy of itself.\n   * @returns The copy of self.\n   * @example\n   * const iter = container.find(1);  // container = [1, 2]\n   * const next = iter.copy().next();\n   * console.log(next === iter);  // false\n   * console.log(next.equals(iter));  // false\n   * console.log(next.pointer, iter.pointer); // 2, 1\n   */\n  abstract copy(): ContainerIterator<T>;\n  abstract isAccessible(): boolean;\n}\n\nexport abstract class Base {\n  /**\n   * @description Container's size.\n   * @internal\n   */\n  protected _length = 0;\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.length); // 2\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.size()); // 2\n   */\n  size() {\n    return this._length;\n  }\n  /**\n   * @returns Whether the container is empty.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  empty() {\n    return this._length === 0;\n  }\n  /**\n   * @description Clear the container.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  abstract clear(): void;\n}\n\nexport abstract class Container<T> extends Base {\n  /**\n   * @returns Iterator pointing to the beginning element.\n   * @example\n   * const begin = container.begin();\n   * const end = container.end();\n   * for (const it = begin; !it.equals(end); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract begin(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the super end like c++.\n   * @example\n   * const begin = container.begin();\n   * const end = container.end();\n   * for (const it = begin; !it.equals(end); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract end(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the end element.\n   * @example\n   * const rBegin = container.rBegin();\n   * const rEnd = container.rEnd();\n   * for (const it = rBegin; !it.equals(rEnd); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract rBegin(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the super begin like c++.\n   * @example\n   * const rBegin = container.rBegin();\n   * const rEnd = container.rEnd();\n   * for (const it = rBegin; !it.equals(rEnd); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract rEnd(): ContainerIterator<T>;\n  /**\n   * @returns The first element of the container.\n   */\n  abstract front(): T | undefined;\n  /**\n   * @returns The last element of the container.\n   */\n  abstract back(): T | undefined;\n  /**\n   * @param element - The element you want to find.\n   * @returns An iterator pointing to the element if found, or super end if not found.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  abstract find(element: T): ContainerIterator<T>;\n  /**\n   * @description Iterate over all elements in the container.\n   * @param callback - Callback function like Array.forEach.\n   * @example\n   * container.forEach((element, index) => console.log(element, index));\n   */\n  abstract forEach(callback: (element: T, index: number, container: Container<T>) => void): void;\n  /**\n   * @description Gets the value of the element at the specified position.\n   * @example\n   * const val = container.getElementByPos(-1); // throw a RangeError\n   */\n  abstract getElementByPos(pos: number): T;\n  /**\n   * @description Removes the element at the specified position.\n   * @param pos - The element's position you want to remove.\n   * @returns The container length after erasing.\n   * @example\n   * container.eraseElementByPos(-1); // throw a RangeError\n   */\n  abstract eraseElementByPos(pos: number): number;\n  /**\n   * @description Removes element by iterator and move `iter` to next.\n   * @param iter - The iterator you want to erase.\n   * @returns The next iterator.\n   * @example\n   * container.eraseElementByIterator(container.begin());\n   * container.eraseElementByIterator(container.end()); // throw a RangeError\n   */\n  abstract eraseElementByIterator(\n    iter: ContainerIterator<T>\n  ): ContainerIterator<T>;\n  /**\n   * @description Using for `for...of` syntax like Array.\n   * @example\n   * for (const element of container) {\n   *   console.log(element);\n   * }\n   */\n  abstract [Symbol.iterator](): Generator<T, void>;\n}\n\n/**\n * @description The initial data type passed in when initializing the container.\n */\nexport type initContainer<T> = {\n  size?: number | (() => number);\n  length?: number;\n  forEach: (callback: (el: T) => void) => void;\n}\n","/**\n * @description Throw an iterator access error.\n * @internal\n */\nexport function throwIteratorAccessError() {\n  throw new RangeError('Iterator access denied!');\n}\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  enableIndex: boolean;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    this.enableIndex = enableIndex;\n    this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      const key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      const value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    let _parent = swapNode._parent as TreeNodeEnableIndex<K, V>;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n  }\n  protected _inOrderTraversal(): TreeNode<K, V>[];\n  protected _inOrderTraversal(pos: number): TreeNode<K, V>;\n  protected _inOrderTraversal(\n    callback: (node: TreeNode<K, V>, index: number, map: this) => void\n  ): TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    param?: number | ((node: TreeNode<K, V>, index: number, map: this) => void)\n  ) {\n    const pos = typeof param === 'number' ? param : undefined;\n    const callback = typeof param === 'function' ? param : undefined;\n    const nodeList = typeof param === 'undefined' ? <TreeNode<K, V>[]>[] : undefined;\n    let index = 0;\n    let curNode = this._root;\n    const stack: TreeNode<K, V>[] = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop()!;\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        (<TreeNodeEnableIndex<K, V>>parentNode)._recount();\n        (<TreeNodeEnableIndex<K, V>>grandParent)._recount();\n        (<TreeNodeEnableIndex<K, V>>curNode)._recount();\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _set(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, TreeNodeColor.BLACK);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return this._length;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      let parent = curNode._parent as TreeNodeEnableIndex<K, V>;\n      while (parent !== this._header) {\n        parent._subTreeSize += 1;\n        parent = parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  }\n  /**\n   * @internal\n   */\n  protected _getTreeNodeByKey(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    const nextKey = node._next()._key!;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (\n      this._cmp(preKey, key) >= 0 ||\n      this._cmp(nextKey, key) <= 0\n    ) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    function traversal(curNode: TreeNode<K, V> | undefined): number {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n","import { TreeNode } from './TreeNode';\nimport type { TreeNodeEnableIndex } from './TreeNode';\nimport { ContainerIterator, IteratorType } from '@/container/ContainerBase';\nimport TreeContainer from '@/container/TreeContainer/Base/index';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeIterator<K, V> extends ContainerIterator<K | [K, V]> {\n  abstract readonly container: TreeContainer<K, V>;\n  /**\n   * @internal\n   */\n  _node: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected constructor(\n    node: TreeNode<K, V>,\n    header: TreeNode<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(iteratorType);\n    this._node = node;\n    this._header = header;\n    if (this.iteratorType === IteratorType.NORMAL) {\n      this.pre = function () {\n        if (this._node === this._header._left) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n    } else {\n      this.pre = function () {\n        if (this._node === this._header._right) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n    }\n  }\n  /**\n   * @description Get the sequential index of the iterator in the tree container.<br/>\n   *              <strong>Note:</strong>\n   *              This function only takes effect when the specified tree container `enableIndex = true`.\n   * @returns The index subscript of the node in the tree.\n   * @example\n   * const st = new OrderedSet([1, 2, 3], true);\n   * console.log(st.begin().next().index);  // 1\n   */\n  get index() {\n    let _node = this._node as TreeNodeEnableIndex<K, V>;\n    const root = this._header._parent as TreeNodeEnableIndex<K, V>;\n    if (_node === this._header) {\n      if (root) {\n        return root._subTreeSize - 1;\n      }\n      return 0;\n    }\n    let index = 0;\n    if (_node._left) {\n      index += (_node._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n    while (_node !== root) {\n      const _parent = _node._parent as TreeNodeEnableIndex<K, V>;\n      if (_node === _parent._right) {\n        index += 1;\n        if (_parent._left) {\n          index += (_parent._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n        }\n      }\n      _node = _parent;\n    }\n    return index;\n  }\n  isAccessible() {\n    return this._node !== this._header;\n  }\n  // @ts-ignore\n  pre(): this;\n  // @ts-ignore\n  next(): this;\n}\n\nexport default TreeIterator;\n","import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport { TreeNode } from './Base/TreeNode';\nimport { initContainer, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass OrderedMapIterator<K, V> extends TreeIterator<K, V> {\n  container: OrderedMap<K, V>;\n  constructor(\n    node: TreeNode<K, V>,\n    header: TreeNode<K, V>,\n    container: OrderedMap<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(node, header, iteratorType);\n    this.container = container;\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    const self = this;\n    return new Proxy(<[K, V]><unknown>[], {\n      get(target, prop: '0' | '1') {\n        if (prop === '0') return self._node._key!;\n        else if (prop === '1') return self._node._value!;\n        target[0] = self._node._key!;\n        target[1] = self._node._value!;\n        return target[prop];\n      },\n      set(_, prop: '1', newValue: V) {\n        if (prop !== '1') {\n          throw new TypeError('prop must be 1');\n        }\n        self._node._value = newValue;\n        return true;\n      }\n    });\n  }\n  copy() {\n    return new OrderedMapIterator<K, V>(\n      this._node,\n      this._header,\n      this.container,\n      this.iteratorType\n    );\n  }\n  // @ts-ignore\n  equals(iter: OrderedMapIterator<K, V>): boolean;\n}\n\nexport type { OrderedMapIterator };\n\nclass OrderedMap<K, V> extends TreeContainer<K, V> {\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedMap();\n   * new OrderedMap([[0, 1], [2, 1]]);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n   */\n  constructor(\n    container: initContainer<[K, V]> = [],\n    cmp?: (x: K, y: K) => number,\n    enableIndex?: boolean\n  ) {\n    super(cmp, enableIndex);\n    const self = this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n  }\n  begin() {\n    return new OrderedMapIterator<K, V>(this._header._left || this._header, this._header, this);\n  }\n  end() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this);\n  }\n  rBegin() {\n    return new OrderedMapIterator<K, V>(\n      this._header._right || this._header,\n      this._header,\n      this,\n      IteratorType.REVERSE\n    );\n  }\n  rEnd() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this, IteratorType.REVERSE);\n  }\n  front() {\n    if (this._length === 0) return;\n    const minNode = this._header._left!;\n    return <[K, V]>[minNode._key, minNode._value];\n  }\n  back() {\n    if (this._length === 0) return;\n    const maxNode = this._header._right!;\n    return <[K, V]>[maxNode._key, maxNode._value];\n  }\n  lowerBound(key: K) {\n    const resNode = this._lowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  upperBound(key: K) {\n    const resNode = this._upperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseLowerBound(key: K) {\n    const resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseUpperBound(key: K) {\n    const resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  forEach(callback: (element: [K, V], index: number, map: OrderedMap<K, V>) => void) {\n    this._inOrderTraversal(function (node, index, map) {\n      callback(<[K, V]>[node._key, node._value], index, map);\n    });\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n   * const iter = mp.begin();\n   * mp.setElement(1, 0);\n   * mp.setElement(3, 0, iter);  // give a hint will be faster.\n   */\n  setElement(key: K, value: V, hint?: OrderedMapIterator<K, V>) {\n    return this._set(key, value, hint);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    return <[K, V]>[node._key, node._value];\n  }\n  find(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return new OrderedMapIterator<K, V>(curNode, this._header, this);\n  }\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The specified key you want to get.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  getElementByKey(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return curNode._value;\n  }\n  union(other: OrderedMap<K, V>) {\n    const self = this;\n    other.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return this._length;\n  }\n  * [Symbol.iterator]() {\n    const length = this._length;\n    const nodeList = this._inOrderTraversal();\n    for (let i = 0; i < length; ++i) {\n      const node = nodeList[i];\n      yield <[K, V]>[node._key, node._value];\n    }\n  }\n  // @ts-ignore\n  eraseElementByIterator(iter: OrderedMapIterator<K, V>): OrderedMapIterator<K, V>;\n}\n\nexport default OrderedMap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}