{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\nconst call_1 = require(\"./call\");\nconst channel_1 = require(\"./channel\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst client_interceptors_1 = require(\"./client-interceptors\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nfunction getErrorStackString(error) {\n  var _a;\n  return ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.split('\\n').slice(1).join('\\n')) || 'no stack trace available';\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n  constructor(address, credentials, options = {}) {\n    var _a, _b;\n    options = Object.assign({}, options);\n    this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n    delete options.interceptors;\n    this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n    delete options.interceptor_providers;\n    if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n      throw new Error('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n    }\n    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n    delete options.callInvocationTransformer;\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      const channelFactoryOverride = options.channelFactoryOverride;\n      delete options.channelFactoryOverride;\n      this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n    } else {\n      this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n    }\n  }\n  close() {\n    this[CHANNEL_SYMBOL].close();\n  }\n  getChannel() {\n    return this[CHANNEL_SYMBOL];\n  }\n  waitForReady(deadline, callback) {\n    const checkState = err => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n      let newState;\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n      if (newState === connectivity_state_1.ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n    setImmediate(checkState);\n  }\n  checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n    if (isFunction(arg1)) {\n      return {\n        metadata: new metadata_1.Metadata(),\n        options: {},\n        callback: arg1\n      };\n    } else if (isFunction(arg2)) {\n      if (arg1 instanceof metadata_1.Metadata) {\n        return {\n          metadata: arg1,\n          options: {},\n          callback: arg2\n        };\n      } else {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: arg1,\n          callback: arg2\n        };\n      }\n    } else {\n      if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {\n        throw new Error('Incorrect arguments passed');\n      }\n      return {\n        metadata: arg1,\n        options: arg2,\n        callback: arg3\n      };\n    }\n  }\n  makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n    var _a, _b;\n    const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n    const methodDefinition = {\n      path: method,\n      requestStream: false,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientUnaryCallImpl(),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n    const emitter = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    let responseMessage = null;\n    let receivedStatus = false;\n    let callerStackError = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');\n        }\n        responseMessage = message;\n      },\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === constants_1.Status.OK) {\n          if (responseMessage === null) {\n            const callerStack = getErrorStackString(callerStackError);\n            callProperties.callback((0, call_1.callErrorFromStatus)({\n              code: constants_1.Status.UNIMPLEMENTED,\n              details: 'No message received',\n              metadata: status.metadata\n            }, callerStack));\n          } else {\n            callProperties.callback(null, responseMessage);\n          }\n        } else {\n          const callerStack = getErrorStackString(callerStackError);\n          callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        emitter.emit('status', status);\n      }\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return emitter;\n  }\n  makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n    var _a, _b;\n    const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n    const methodDefinition = {\n      path: method,\n      requestStream: true,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientWritableStreamImpl(serialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n    const emitter = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    let responseMessage = null;\n    let receivedStatus = false;\n    let callerStackError = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');\n        }\n        responseMessage = message;\n        call.startRead();\n      },\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === constants_1.Status.OK) {\n          if (responseMessage === null) {\n            const callerStack = getErrorStackString(callerStackError);\n            callProperties.callback((0, call_1.callErrorFromStatus)({\n              code: constants_1.Status.UNIMPLEMENTED,\n              details: 'No message received',\n              metadata: status.metadata\n            }, callerStack));\n          } else {\n            callProperties.callback(null, responseMessage);\n          }\n        } else {\n          const callerStack = getErrorStackString(callerStackError);\n          callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        emitter.emit('status', status);\n      }\n    });\n    return emitter;\n  }\n  checkMetadataAndOptions(arg1, arg2) {\n    let metadata;\n    let options;\n    if (arg1 instanceof metadata_1.Metadata) {\n      metadata = arg1;\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n      metadata = new metadata_1.Metadata();\n    }\n    return {\n      metadata,\n      options\n    };\n  }\n  makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n    var _a, _b;\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition = {\n      path: method,\n      requestStream: false,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientReadableStreamImpl(deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n    const stream = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    let receivedStatus = false;\n    let callerStackError = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata) {\n        stream.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        stream.push(message);\n      },\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== constants_1.Status.OK) {\n          const callerStack = getErrorStackString(callerStackError);\n          stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        stream.emit('status', status);\n      }\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return stream;\n  }\n  makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n    var _a, _b;\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition = {\n      path: method,\n      requestStream: true,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n    const stream = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    let receivedStatus = false;\n    let callerStackError = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata) {\n        stream.emit('metadata', metadata);\n      },\n      onReceiveMessage(message) {\n        stream.push(message);\n      },\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== constants_1.Status.OK) {\n          const callerStack = getErrorStackString(callerStackError);\n          stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        stream.emit('status', status);\n      }\n    });\n    return stream;\n  }\n}\nexports.Client = Client;","map":{"version":3,"names":["call_1","require","channel_1","connectivity_state_1","constants_1","metadata_1","client_interceptors_1","CHANNEL_SYMBOL","Symbol","INTERCEPTOR_SYMBOL","INTERCEPTOR_PROVIDER_SYMBOL","CALL_INVOCATION_TRANSFORMER_SYMBOL","isFunction","arg","getErrorStackString","error","_a","stack","split","slice","join","Client","constructor","address","credentials","options","Object","assign","interceptors","_b","interceptor_providers","length","Error","callInvocationTransformer","channelOverride","channelFactoryOverride","ChannelImplementation","close","getChannel","waitForReady","deadline","callback","checkState","err","newState","getConnectivityState","e","ConnectivityState","READY","watchConnectivityState","setImmediate","checkOptionalUnaryResponseArguments","arg1","arg2","arg3","metadata","Metadata","makeUnaryRequest","method","serialize","deserialize","argument","checkedArguments","methodDefinition","path","requestStream","responseStream","requestSerialize","responseDeserialize","callProperties","call","ClientUnaryCallImpl","channel","callOptions","emitter","interceptorArgs","clientInterceptors","clientInterceptorProviders","callInterceptors","callInterceptorProviders","getInterceptingCall","responseMessage","receivedStatus","callerStackError","start","onReceiveMetadata","emit","onReceiveMessage","message","cancelWithStatus","Status","UNIMPLEMENTED","onReceiveStatus","status","code","OK","callerStack","callErrorFromStatus","details","sendMessage","halfClose","makeClientStreamRequest","ClientWritableStreamImpl","startRead","checkMetadataAndOptions","makeServerStreamRequest","ClientReadableStreamImpl","stream","push","makeBidiStreamRequest","ClientDuplexStreamImpl","exports"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/client.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ClientDuplexStream,\n  ClientDuplexStreamImpl,\n  ClientReadableStream,\n  ClientReadableStreamImpl,\n  ClientUnaryCall,\n  ClientUnaryCallImpl,\n  ClientWritableStream,\n  ClientWritableStreamImpl,\n  ServiceError,\n  callErrorFromStatus,\n  SurfaceCall,\n} from './call';\nimport { CallCredentials } from './call-credentials';\nimport { StatusObject } from './call-interface';\nimport { Channel, ChannelImplementation } from './channel';\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { Status } from './constants';\nimport { Metadata } from './metadata';\nimport { ClientMethodDefinition } from './make-client';\nimport {\n  getInterceptingCall,\n  Interceptor,\n  InterceptorProvider,\n  InterceptorArguments,\n  InterceptingCallInterface,\n} from './client-interceptors';\nimport {\n  ServerUnaryCall,\n  ServerReadableStream,\n  ServerWritableStream,\n  ServerDuplexStream,\n} from './server-call';\nimport { Deadline } from './deadline';\n\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\n\nfunction isFunction<ResponseType>(\n  arg: Metadata | CallOptions | UnaryCallback<ResponseType> | undefined\n): arg is UnaryCallback<ResponseType> {\n  return typeof arg === 'function';\n}\n\nexport interface UnaryCallback<ResponseType> {\n  (err: ServiceError | null, value?: ResponseType): void;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport interface CallOptions {\n  deadline?: Deadline;\n  host?: string;\n  parent?:\n    | ServerUnaryCall<any, any>\n    | ServerReadableStream<any, any>\n    | ServerWritableStream<any, any>\n    | ServerDuplexStream<any, any>;\n  propagate_flags?: number;\n  credentials?: CallCredentials;\n  interceptors?: Interceptor[];\n  interceptor_providers?: InterceptorProvider[];\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport interface CallProperties<RequestType, ResponseType> {\n  argument?: RequestType;\n  metadata: Metadata;\n  call: SurfaceCall;\n  channel: Channel;\n  methodDefinition: ClientMethodDefinition<RequestType, ResponseType>;\n  callOptions: CallOptions;\n  callback?: UnaryCallback<ResponseType>;\n}\n\nexport interface CallInvocationTransformer {\n  (callProperties: CallProperties<any, any>): CallProperties<any, any>; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\nexport type ClientOptions = Partial<ChannelOptions> & {\n  channelOverride?: Channel;\n  channelFactoryOverride?: (\n    address: string,\n    credentials: ChannelCredentials,\n    options: ClientOptions\n  ) => Channel;\n  interceptors?: Interceptor[];\n  interceptor_providers?: InterceptorProvider[];\n  callInvocationTransformer?: CallInvocationTransformer;\n};\n\nfunction getErrorStackString(error: Error): string {\n  return error.stack?.split('\\n').slice(1).join('\\n') || 'no stack trace available';\n}\n\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nexport class Client {\n  private readonly [CHANNEL_SYMBOL]: Channel;\n  private readonly [INTERCEPTOR_SYMBOL]: Interceptor[];\n  private readonly [INTERCEPTOR_PROVIDER_SYMBOL]: InterceptorProvider[];\n  private readonly [CALL_INVOCATION_TRANSFORMER_SYMBOL]?: CallInvocationTransformer;\n  constructor(\n    address: string,\n    credentials: ChannelCredentials,\n    options: ClientOptions = {}\n  ) {\n    options = Object.assign({}, options);\n    this[INTERCEPTOR_SYMBOL] = options.interceptors ?? [];\n    delete options.interceptors;\n    this[INTERCEPTOR_PROVIDER_SYMBOL] = options.interceptor_providers ?? [];\n    delete options.interceptor_providers;\n    if (\n      this[INTERCEPTOR_SYMBOL].length > 0 &&\n      this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0\n    ) {\n      throw new Error(\n        'Both interceptors and interceptor_providers were passed as options ' +\n          'to the client constructor. Only one of these is allowed.'\n      );\n    }\n    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\n      options.callInvocationTransformer;\n    delete options.callInvocationTransformer;\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      const channelFactoryOverride = options.channelFactoryOverride;\n      delete options.channelFactoryOverride;\n      this[CHANNEL_SYMBOL] = channelFactoryOverride(\n        address,\n        credentials,\n        options\n      );\n    } else {\n      this[CHANNEL_SYMBOL] = new ChannelImplementation(\n        address,\n        credentials,\n        options\n      );\n    }\n  }\n\n  close(): void {\n    this[CHANNEL_SYMBOL].close();\n  }\n\n  getChannel(): Channel {\n    return this[CHANNEL_SYMBOL];\n  }\n\n  waitForReady(deadline: Deadline, callback: (error?: Error) => void): void {\n    const checkState = (err?: Error) => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n      let newState;\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n      if (newState === ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(\n            newState,\n            deadline,\n            checkState\n          );\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n    setImmediate(checkState);\n  }\n\n  private checkOptionalUnaryResponseArguments<ResponseType>(\n    arg1: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    arg2?: CallOptions | UnaryCallback<ResponseType>,\n    arg3?: UnaryCallback<ResponseType>\n  ): {\n    metadata: Metadata;\n    options: CallOptions;\n    callback: UnaryCallback<ResponseType>;\n  } {\n    if (isFunction(arg1)) {\n      return { metadata: new Metadata(), options: {}, callback: arg1 };\n    } else if (isFunction(arg2)) {\n      if (arg1 instanceof Metadata) {\n        return { metadata: arg1, options: {}, callback: arg2 };\n      } else {\n        return { metadata: new Metadata(), options: arg1, callback: arg2 };\n      }\n    } else {\n      if (\n        !(\n          arg1 instanceof Metadata &&\n          arg2 instanceof Object &&\n          isFunction(arg3)\n        )\n      ) {\n        throw new Error('Incorrect arguments passed');\n      }\n      return { metadata: arg1, options: arg2, callback: arg3 };\n    }\n  }\n\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    options?: CallOptions | UnaryCallback<ResponseType>,\n    callback?: UnaryCallback<ResponseType>\n  ): ClientUnaryCall {\n    const checkedArguments =\n      this.checkOptionalUnaryResponseArguments<ResponseType>(\n        metadata,\n        options,\n        callback\n      );\n    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =\n      {\n        path: method,\n        requestStream: false,\n        responseStream: false,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize,\n      };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new ClientUnaryCallImpl(),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const emitter: ClientUnaryCall = callProperties.call;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    let responseMessage: ResponseType | null = null;\n    let receivedStatus = false;\n    let callerStackError: Error | null = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(Status.UNIMPLEMENTED, 'Too many responses received');\n        }\n        responseMessage = message;\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === Status.OK) {\n          if (responseMessage === null) {\n            const callerStack = getErrorStackString(callerStackError!);\n            callProperties.callback!(\n              callErrorFromStatus(\n                {\n                  code: Status.UNIMPLEMENTED,\n                  details: 'No message received',\n                  metadata: status.metadata,\n                },\n                callerStack\n              )\n            );\n          } else {\n            callProperties.callback!(null, responseMessage);\n          }\n        } else {\n          const callerStack = getErrorStackString(callerStackError!);\n          callProperties.callback!(callErrorFromStatus(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        emitter.emit('status', status);\n      },\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return emitter;\n  }\n\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    options?: CallOptions | UnaryCallback<ResponseType>,\n    callback?: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType> {\n    const checkedArguments =\n      this.checkOptionalUnaryResponseArguments<ResponseType>(\n        metadata,\n        options,\n        callback\n      );\n    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =\n      {\n        path: method,\n        requestStream: true,\n        responseStream: false,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize,\n      };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      metadata: checkedArguments.metadata,\n      call: new ClientWritableStreamImpl<RequestType>(serialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const emitter: ClientWritableStream<RequestType> =\n      callProperties.call as ClientWritableStream<RequestType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    let responseMessage: ResponseType | null = null;\n    let receivedStatus = false;\n    let callerStackError: Error | null = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(Status.UNIMPLEMENTED, 'Too many responses received');\n        }\n        responseMessage = message;\n        call.startRead();\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === Status.OK) {\n          if (responseMessage === null) {\n            const callerStack = getErrorStackString(callerStackError!);\n            callProperties.callback!(\n              callErrorFromStatus(\n                {\n                  code: Status.UNIMPLEMENTED,\n                  details: 'No message received',\n                  metadata: status.metadata,\n                },\n                callerStack\n              )\n            );\n          } else {\n            callProperties.callback!(null, responseMessage);\n          }\n        } else {\n          const callerStack = getErrorStackString(callerStackError!);\n          callProperties.callback!(callErrorFromStatus(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        emitter.emit('status', status);\n      },\n    });\n    return emitter;\n  }\n\n  private checkMetadataAndOptions(\n    arg1?: Metadata | CallOptions,\n    arg2?: CallOptions\n  ): { metadata: Metadata; options: CallOptions } {\n    let metadata: Metadata;\n    let options: CallOptions;\n    if (arg1 instanceof Metadata) {\n      metadata = arg1;\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n      metadata = new Metadata();\n    }\n    return { metadata, options };\n  }\n\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType>;\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType>;\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata?: Metadata | CallOptions,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType> {\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =\n      {\n        path: method,\n        requestStream: false,\n        responseStream: true,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize,\n      };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new ClientReadableStreamImpl<ResponseType>(deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const stream: ClientReadableStream<ResponseType> =\n      callProperties.call as ClientReadableStream<ResponseType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    let receivedStatus = false;\n    let callerStackError: Error | null = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata: Metadata) {\n        stream.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        stream.push(message);\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== Status.OK) {\n          const callerStack = getErrorStackString(callerStackError!);\n          stream.emit('error', callErrorFromStatus(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        stream.emit('status', status);\n      },\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return stream;\n  }\n\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType>;\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType>;\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata?: Metadata | CallOptions,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType> {\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =\n      {\n        path: method,\n        requestStream: true,\n        responseStream: true,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize,\n      };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      metadata: checkedArguments.metadata,\n      call: new ClientDuplexStreamImpl<RequestType, ResponseType>(\n        serialize,\n        deserialize\n      ),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const stream: ClientDuplexStream<RequestType, ResponseType> =\n      callProperties.call as ClientDuplexStream<RequestType, ResponseType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    let receivedStatus = false;\n    let callerStackError: Error | null = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata: Metadata) {\n        stream.emit('metadata', metadata);\n      },\n      onReceiveMessage(message: Buffer) {\n        stream.push(message);\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== Status.OK) {\n          const callerStack = getErrorStackString(callerStackError!);\n          stream.emit('error', callErrorFromStatus(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        stream.emit('status', status);\n      },\n    });\n    return stream;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}