{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\nconst http2 = require(\"http2\");\nconst util = require(\"util\");\nconst constants_1 = require(\"./constants\");\nconst server_call_1 = require(\"./server-call\");\nconst server_credentials_1 = require(\"./server-credentials\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst channelz_1 = require(\"./channelz\");\nconst server_interceptors_1 = require(\"./server-interceptors\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst MAX_CONNECTION_IDLE_MS = ~(1 << 31);\nconst {\n  HTTP2_HEADER_PATH\n} = http2.constants;\nconst TRACER_NAME = 'server';\nconst kMaxAge = Buffer.from('max_age');\nfunction noop() {}\n/**\n * Decorator to wrap a class method with util.deprecate\n * @param message The message to output if the deprecated method is called\n * @returns\n */\nfunction deprecate(message) {\n  return function (target, context) {\n    return util.deprecate(target, message);\n  };\n}\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`\n  };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\nlet Server = (() => {\n  var _a;\n  let _instanceExtraInitializers = [];\n  let _start_decorators;\n  return _a = class Server {\n    constructor(options) {\n      var _b, _c, _d, _e, _f, _g;\n      this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());\n      this.http2Servers = new Map();\n      this.sessionIdleTimeouts = new Map();\n      this.handlers = new Map();\n      this.sessions = new Map();\n      /**\n       * This field only exists to ensure that the start method throws an error if\n       * it is called twice, as it did previously.\n       */\n      this.started = false;\n      this.shutdown = false;\n      this.serverAddressString = 'null';\n      // Channelz Info\n      this.channelzEnabled = true;\n      this.options = options !== null && options !== void 0 ? options : {};\n      if (this.options['grpc.enable_channelz'] === 0) {\n        this.channelzEnabled = false;\n        this.channelzTrace = new channelz_1.ChannelzTraceStub();\n        this.callTracker = new channelz_1.ChannelzCallTrackerStub();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n      } else {\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n      }\n      this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () => this.getChannelzInfo(), this.channelzEnabled);\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n      this.maxConnectionAgeMs = (_b = this.options['grpc.max_connection_age_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n      this.maxConnectionAgeGraceMs = (_c = this.options['grpc.max_connection_age_grace_ms']) !== null && _c !== void 0 ? _c : UNLIMITED_CONNECTION_AGE_MS;\n      this.keepaliveTimeMs = (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;\n      this.keepaliveTimeoutMs = (_e = this.options['grpc.keepalive_timeout_ms']) !== null && _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;\n      this.sessionIdleTimeout = (_f = this.options['grpc.max_connection_idle_ms']) !== null && _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;\n      this.commonServerOptions = {\n        maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n      };\n      if ('grpc-node.max_session_memory' in this.options) {\n        this.commonServerOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      if ('grpc.max_concurrent_streams' in this.options) {\n        this.commonServerOptions.settings = {\n          maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n        };\n      }\n      this.interceptors = (_g = this.options.interceptors) !== null && _g !== void 0 ? _g : [];\n      this.trace('Server constructed');\n    }\n    getChannelzInfo() {\n      return {\n        trace: this.channelzTrace,\n        callTracker: this.callTracker,\n        listenerChildren: this.listenerChildrenTracker.getChildLists(),\n        sessionChildren: this.sessionChildrenTracker.getChildLists()\n      };\n    }\n    getChannelzSessionInfo(session) {\n      var _b, _c, _d;\n      const sessionInfo = this.sessions.get(session);\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n      const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n      let tlsInfo;\n      if (session.encrypted) {\n        const tlsSocket = sessionSocket;\n        const cipherInfo = tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== void 0 ? _b : null,\n          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n          localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n          remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n        };\n      } else {\n        tlsInfo = null;\n      }\n      const socketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: sessionInfo.keepAlivesSent,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== void 0 ? _c : null,\n        remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== void 0 ? _d : null\n      };\n      return socketInfo;\n    }\n    trace(text) {\n      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n    }\n    keepaliveTrace(text) {\n      logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + text);\n    }\n    addProtoService() {\n      throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n      if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n        throw new Error('addService() requires two objects as arguments');\n      }\n      const serviceKeys = Object.keys(service);\n      if (serviceKeys.length === 0) {\n        throw new Error('Cannot add an empty service to a server');\n      }\n      serviceKeys.forEach(name => {\n        const attrs = service[name];\n        let methodType;\n        if (attrs.requestStream) {\n          if (attrs.responseStream) {\n            methodType = 'bidi';\n          } else {\n            methodType = 'clientStream';\n          }\n        } else {\n          if (attrs.responseStream) {\n            methodType = 'serverStream';\n          } else {\n            methodType = 'unary';\n          }\n        }\n        let implFn = implementation[name];\n        let impl;\n        if (implFn === undefined && typeof attrs.originalName === 'string') {\n          implFn = implementation[attrs.originalName];\n        }\n        if (implFn !== undefined) {\n          impl = implFn.bind(implementation);\n        } else {\n          impl = getDefaultHandler(methodType, name);\n        }\n        const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n        if (success === false) {\n          throw new Error(`Method handler for ${attrs.path} already provided.`);\n        }\n      });\n    }\n    removeService(service) {\n      if (service === null || typeof service !== 'object') {\n        throw new Error('removeService() requires object as argument');\n      }\n      const serviceKeys = Object.keys(service);\n      serviceKeys.forEach(name => {\n        const attrs = service[name];\n        this.unregister(attrs.path);\n      });\n    }\n    bind(port, creds) {\n      throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    registerListenerToChannelz(boundAddress) {\n      return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {\n        return {\n          localAddress: boundAddress,\n          remoteAddress: null,\n          security: null,\n          remoteName: null,\n          streamsStarted: 0,\n          streamsSucceeded: 0,\n          streamsFailed: 0,\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastLocalStreamCreatedTimestamp: null,\n          lastRemoteStreamCreatedTimestamp: null,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null,\n          localFlowControlWindow: null,\n          remoteFlowControlWindow: null\n        };\n      }, this.channelzEnabled);\n    }\n    createHttp2Server(credentials) {\n      let http2Server;\n      if (credentials._isSecure()) {\n        const credentialsSettings = credentials._getSettings();\n        const secureServerOptions = Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), credentialsSettings), {\n          enableTrace: this.options['grpc-node.tls_enable_trace'] === 1\n        });\n        let areCredentialsValid = credentialsSettings !== null;\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.on('connection', socket => {\n          if (!areCredentialsValid) {\n            socket.destroy();\n          }\n        });\n        http2Server.on('secureConnection', socket => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', e => {\n            this.trace('An incoming TLS connection closed with error: ' + e.message);\n          });\n        });\n        const credsWatcher = options => {\n          if (options) {\n            http2Server.setSecureContext(options);\n          }\n          areCredentialsValid = options !== null;\n        };\n        credentials._addWatcher(credsWatcher);\n        http2Server.on('close', () => {\n          credentials._removeWatcher(credsWatcher);\n        });\n      } else {\n        http2Server = http2.createServer(this.commonServerOptions);\n      }\n      http2Server.setTimeout(0, noop);\n      this._setupHandlers(http2Server, credentials._getInterceptors());\n      return http2Server;\n    }\n    bindOneAddress(address, boundPortObject) {\n      this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n      const http2Server = this.createHttp2Server(boundPortObject.credentials);\n      return new Promise((resolve, reject) => {\n        const onError = err => {\n          this.trace('Failed to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address) + ' with error ' + err.message);\n          resolve({\n            port: 'port' in address ? address.port : 1,\n            error: err.message\n          });\n        };\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          const boundAddress = http2Server.address();\n          let boundSubchannelAddress;\n          if (typeof boundAddress === 'string') {\n            boundSubchannelAddress = {\n              path: boundAddress\n            };\n          } else {\n            boundSubchannelAddress = {\n              host: boundAddress.address,\n              port: boundAddress.port\n            };\n          }\n          const channelzRef = this.registerListenerToChannelz(boundSubchannelAddress);\n          this.listenerChildrenTracker.refChild(channelzRef);\n          this.http2Servers.set(http2Server, {\n            channelzRef: channelzRef,\n            sessions: new Set()\n          });\n          boundPortObject.listeningServers.add(http2Server);\n          this.trace('Successfully bound ' + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n          resolve({\n            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1\n          });\n          http2Server.removeListener('error', onError);\n        });\n      });\n    }\n    async bindManyPorts(addressList, boundPortObject) {\n      if (addressList.length === 0) {\n        return {\n          count: 0,\n          port: 0,\n          errors: []\n        };\n      }\n      if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {\n        /* If binding to port 0, first try to bind the first address, then bind\n         * the rest of the address list to the specific port that it binds. */\n        const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);\n        if (firstAddressResult.error) {\n          /* If the first address fails to bind, try the same operation starting\n           * from the second item in the list. */\n          const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);\n          return Object.assign(Object.assign({}, restAddressResult), {\n            errors: [firstAddressResult.error, ...restAddressResult.errors]\n          });\n        } else {\n          const restAddresses = addressList.slice(1).map(address => (0, subchannel_address_1.isTcpSubchannelAddress)(address) ? {\n            host: address.host,\n            port: firstAddressResult.port\n          } : address);\n          const restAddressResult = await Promise.all(restAddresses.map(address => this.bindOneAddress(address, boundPortObject)));\n          const allResults = [firstAddressResult, ...restAddressResult];\n          return {\n            count: allResults.filter(result => result.error === undefined).length,\n            port: firstAddressResult.port,\n            errors: allResults.filter(result => result.error).map(result => result.error)\n          };\n        }\n      } else {\n        const allResults = await Promise.all(addressList.map(address => this.bindOneAddress(address, boundPortObject)));\n        return {\n          count: allResults.filter(result => result.error === undefined).length,\n          port: allResults[0].port,\n          errors: allResults.filter(result => result.error).map(result => result.error)\n        };\n      }\n    }\n    async bindAddressList(addressList, boundPortObject) {\n      const bindResult = await this.bindManyPorts(addressList, boundPortObject);\n      if (bindResult.count > 0) {\n        if (bindResult.count < addressList.length) {\n          logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n        }\n        return bindResult.port;\n      } else {\n        const errorString = `No address added out of total ${addressList.length} resolved`;\n        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n        throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);\n      }\n    }\n    resolvePort(port) {\n      return new Promise((resolve, reject) => {\n        const resolverListener = {\n          onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {\n            // We only want one resolution result. Discard all future results\n            resolverListener.onSuccessfulResolution = () => {};\n            const addressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));\n            if (addressList.length === 0) {\n              reject(new Error(`No addresses resolved for port ${port}`));\n              return;\n            }\n            resolve(addressList);\n          },\n          onError: error => {\n            reject(new Error(error.details));\n          }\n        };\n        const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);\n        resolver.updateResolution();\n      });\n    }\n    async bindPort(port, boundPortObject) {\n      const addressList = await this.resolvePort(port);\n      if (boundPortObject.cancelled) {\n        this.completeUnbind(boundPortObject);\n        throw new Error('bindAsync operation cancelled by unbind call');\n      }\n      const portNumber = await this.bindAddressList(addressList, boundPortObject);\n      if (boundPortObject.cancelled) {\n        this.completeUnbind(boundPortObject);\n        throw new Error('bindAsync operation cancelled by unbind call');\n      }\n      return portNumber;\n    }\n    normalizePort(port) {\n      const initialPortUri = (0, uri_parser_1.parseUri)(port);\n      if (initialPortUri === null) {\n        throw new Error(`Could not parse port \"${port}\"`);\n      }\n      const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n      if (portUri === null) {\n        throw new Error(`Could not get a default scheme for port \"${port}\"`);\n      }\n      return portUri;\n    }\n    bindAsync(port, creds, callback) {\n      if (this.shutdown) {\n        throw new Error('bindAsync called after shutdown');\n      }\n      if (typeof port !== 'string') {\n        throw new TypeError('port must be a string');\n      }\n      if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n        throw new TypeError('creds must be a ServerCredentials object');\n      }\n      if (typeof callback !== 'function') {\n        throw new TypeError('callback must be a function');\n      }\n      this.trace('bindAsync port=' + port);\n      const portUri = this.normalizePort(port);\n      const deferredCallback = (error, port) => {\n        process.nextTick(() => callback(error, port));\n      };\n      /* First, if this port is already bound or that bind operation is in\n       * progress, use that result. */\n      let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n      if (boundPortObject) {\n        if (!creds._equals(boundPortObject.credentials)) {\n          deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);\n          return;\n        }\n        /* If that operation has previously been cancelled by an unbind call,\n         * uncancel it. */\n        boundPortObject.cancelled = false;\n        if (boundPortObject.completionPromise) {\n          boundPortObject.completionPromise.then(portNum => callback(null, portNum), error => callback(error, 0));\n        } else {\n          deferredCallback(null, boundPortObject.portNumber);\n        }\n        return;\n      }\n      boundPortObject = {\n        mapKey: (0, uri_parser_1.uriToString)(portUri),\n        originalUri: portUri,\n        completionPromise: null,\n        cancelled: false,\n        portNumber: 0,\n        credentials: creds,\n        listeningServers: new Set()\n      };\n      const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n      const completionPromise = this.bindPort(portUri, boundPortObject);\n      boundPortObject.completionPromise = completionPromise;\n      /* If the port number is 0, defer populating the map entry until after the\n       * bind operation completes and we have a specific port number. Otherwise,\n       * populate it immediately. */\n      if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n        completionPromise.then(portNum => {\n          const finalUri = {\n            scheme: portUri.scheme,\n            authority: portUri.authority,\n            path: (0, uri_parser_1.combineHostPort)({\n              host: splitPort.host,\n              port: portNum\n            })\n          };\n          boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);\n          boundPortObject.completionPromise = null;\n          boundPortObject.portNumber = portNum;\n          this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n          callback(null, portNum);\n        }, error => {\n          callback(error, 0);\n        });\n      } else {\n        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n        completionPromise.then(portNum => {\n          boundPortObject.completionPromise = null;\n          boundPortObject.portNumber = portNum;\n          callback(null, portNum);\n        }, error => {\n          callback(error, 0);\n        });\n      }\n    }\n    registerInjectorToChannelz() {\n      return (0, channelz_1.registerChannelzSocket)('injector', () => {\n        return {\n          localAddress: null,\n          remoteAddress: null,\n          security: null,\n          remoteName: null,\n          streamsStarted: 0,\n          streamsSucceeded: 0,\n          streamsFailed: 0,\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastLocalStreamCreatedTimestamp: null,\n          lastRemoteStreamCreatedTimestamp: null,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null,\n          localFlowControlWindow: null,\n          remoteFlowControlWindow: null\n        };\n      }, this.channelzEnabled);\n    }\n    createConnectionInjector(credentials) {\n      if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\n        throw new TypeError('creds must be a ServerCredentials object');\n      }\n      const server = this.createHttp2Server(credentials);\n      const channelzRef = this.registerInjectorToChannelz();\n      if (this.channelzEnabled) {\n        this.listenerChildrenTracker.refChild(channelzRef);\n      }\n      const sessionsSet = new Set();\n      this.http2Servers.set(server, {\n        channelzRef: channelzRef,\n        sessions: sessionsSet\n      });\n      return {\n        injectConnection: connection => {\n          server.emit('connection', connection);\n        },\n        drain: graceTimeMs => {\n          var _b, _c;\n          for (const session of sessionsSet) {\n            this.closeSession(session);\n          }\n          (_c = (_b = setTimeout(() => {\n            for (const session of sessionsSet) {\n              session.destroy(http2.constants.NGHTTP2_CANCEL);\n            }\n          }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n        },\n        destroy: () => {\n          this.closeServer(server);\n          for (const session of sessionsSet) {\n            this.closeSession(session);\n          }\n        }\n      };\n    }\n    closeServer(server, callback) {\n      this.trace('Closing server with address ' + JSON.stringify(server.address()));\n      const serverInfo = this.http2Servers.get(server);\n      server.close(() => {\n        if (serverInfo) {\n          this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);\n          (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);\n        }\n        this.http2Servers.delete(server);\n        callback === null || callback === void 0 ? void 0 : callback();\n      });\n    }\n    closeSession(session, callback) {\n      var _b;\n      this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\n      const sessionInfo = this.sessions.get(session);\n      const closeCallback = () => {\n        if (sessionInfo) {\n          this.sessionChildrenTracker.unrefChild(sessionInfo.ref);\n          (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);\n        }\n        callback === null || callback === void 0 ? void 0 : callback();\n      };\n      if (session.closed) {\n        queueMicrotask(closeCallback);\n      } else {\n        session.close(closeCallback);\n      }\n    }\n    completeUnbind(boundPortObject) {\n      for (const server of boundPortObject.listeningServers) {\n        const serverInfo = this.http2Servers.get(server);\n        this.closeServer(server, () => {\n          boundPortObject.listeningServers.delete(server);\n        });\n        if (serverInfo) {\n          for (const session of serverInfo.sessions) {\n            this.closeSession(session);\n          }\n        }\n      }\n      this.boundPorts.delete(boundPortObject.mapKey);\n    }\n    /**\n     * Unbind a previously bound port, or cancel an in-progress bindAsync\n     * operation. If port 0 was bound, only the actual bound port can be\n     * unbound. For example, if bindAsync was called with \"localhost:0\" and the\n     * bound port result was 54321, it can be unbound as \"localhost:54321\".\n     * @param port\n     */\n    unbind(port) {\n      this.trace('unbind port=' + port);\n      const portUri = this.normalizePort(port);\n      const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n      if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n        throw new Error('Cannot unbind port 0');\n      }\n      const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n      if (boundPortObject) {\n        this.trace('unbinding ' + boundPortObject.mapKey + ' originally bound as ' + (0, uri_parser_1.uriToString)(boundPortObject.originalUri));\n        /* If the bind operation is pending, the cancelled flag will trigger\n         * the unbind operation later. */\n        if (boundPortObject.completionPromise) {\n          boundPortObject.cancelled = true;\n        } else {\n          this.completeUnbind(boundPortObject);\n        }\n      }\n    }\n    /**\n     * Gracefully close all connections associated with a previously bound port.\n     * After the grace time, forcefully close all remaining open connections.\n     *\n     * If port 0 was bound, only the actual bound port can be\n     * drained. For example, if bindAsync was called with \"localhost:0\" and the\n     * bound port result was 54321, it can be drained as \"localhost:54321\".\n     * @param port\n     * @param graceTimeMs\n     * @returns\n     */\n    drain(port, graceTimeMs) {\n      var _b, _c;\n      this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);\n      const portUri = this.normalizePort(port);\n      const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n      if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n        throw new Error('Cannot drain port 0');\n      }\n      const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n      if (!boundPortObject) {\n        return;\n      }\n      const allSessions = new Set();\n      for (const http2Server of boundPortObject.listeningServers) {\n        const serverEntry = this.http2Servers.get(http2Server);\n        if (serverEntry) {\n          for (const session of serverEntry.sessions) {\n            allSessions.add(session);\n            this.closeSession(session, () => {\n              allSessions.delete(session);\n            });\n          }\n        }\n      }\n      /* After the grace time ends, send another goaway to all remaining sessions\n       * with the CANCEL code. */\n      (_c = (_b = setTimeout(() => {\n        for (const session of allSessions) {\n          session.destroy(http2.constants.NGHTTP2_CANCEL);\n        }\n      }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n    forceShutdown() {\n      for (const boundPortObject of this.boundPorts.values()) {\n        boundPortObject.cancelled = true;\n      }\n      this.boundPorts.clear();\n      // Close the server if it is still running.\n      for (const server of this.http2Servers.keys()) {\n        this.closeServer(server);\n      }\n      // Always destroy any available sessions. It's possible that one or more\n      // tryShutdown() calls are in progress. Don't wait on them to finish.\n      this.sessions.forEach((channelzInfo, session) => {\n        this.closeSession(session);\n        // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n        // recognize destroy(code) as a valid signature.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        session.destroy(http2.constants.NGHTTP2_CANCEL);\n      });\n      this.sessions.clear();\n      (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      this.shutdown = true;\n    }\n    register(name, handler, serialize, deserialize, type) {\n      if (this.handlers.has(name)) {\n        return false;\n      }\n      this.handlers.set(name, {\n        func: handler,\n        serialize,\n        deserialize,\n        type,\n        path: name\n      });\n      return true;\n    }\n    unregister(name) {\n      return this.handlers.delete(name);\n    }\n    /**\n     * @deprecated No longer needed as of version 1.10.x\n     */\n    start() {\n      if (this.http2Servers.size === 0 || [...this.http2Servers.keys()].every(server => !server.listening)) {\n        throw new Error('server must be bound in order to start');\n      }\n      if (this.started === true) {\n        throw new Error('server is already started');\n      }\n      this.started = true;\n    }\n    tryShutdown(callback) {\n      var _b;\n      const wrappedCallback = error => {\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        callback(error);\n      };\n      let pendingChecks = 0;\n      function maybeCallback() {\n        pendingChecks--;\n        if (pendingChecks === 0) {\n          wrappedCallback();\n        }\n      }\n      this.shutdown = true;\n      for (const [serverKey, server] of this.http2Servers.entries()) {\n        pendingChecks++;\n        const serverString = server.channelzRef.name;\n        this.trace('Waiting for server ' + serverString + ' to close');\n        this.closeServer(serverKey, () => {\n          this.trace('Server ' + serverString + ' finished closing');\n          maybeCallback();\n        });\n        for (const session of server.sessions.keys()) {\n          pendingChecks++;\n          const sessionString = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress;\n          this.trace('Waiting for session ' + sessionString + ' to close');\n          this.closeSession(session, () => {\n            this.trace('Session ' + sessionString + ' finished closing');\n            maybeCallback();\n          });\n        }\n      }\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n    addHttp2Port() {\n      throw new Error('Not yet implemented');\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */\n    getChannelzRef() {\n      return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n      const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n      if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n        stream.respond({\n          [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n        }, {\n          endStream: true\n        });\n        return false;\n      }\n      return true;\n    }\n    _retrieveHandler(path) {\n      this.trace('Received call to method ' + path + ' at address ' + this.serverAddressString);\n      const handler = this.handlers.get(path);\n      if (handler === undefined) {\n        this.trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n        return null;\n      }\n      return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n      var _b, _c;\n      const trailersToSend = Object.assign({\n        'grpc-status': (_b = err.code) !== null && _b !== void 0 ? _b : constants_1.Status.INTERNAL,\n        'grpc-message': err.details,\n        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n        [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n      }, (_c = err.metadata) === null || _c === void 0 ? void 0 : _c.toHttp2Headers());\n      stream.respond(trailersToSend, {\n        endStream: true\n      });\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n    }\n    _channelzHandler(extraInterceptors, stream, headers) {\n      // for handling idle timeout\n      this.onStreamOpened(stream);\n      const channelzSessionInfo = this.sessions.get(stream.session);\n      this.callTracker.addCallStarted();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n      if (!this._verifyContentType(stream, headers)) {\n        this.callTracker.addCallFailed();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        return;\n      }\n      const path = headers[HTTP2_HEADER_PATH];\n      const handler = this._retrieveHandler(path);\n      if (!handler) {\n        this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n        return;\n      }\n      const callEventTracker = {\n        addMessageSent: () => {\n          if (channelzSessionInfo) {\n            channelzSessionInfo.messagesSent += 1;\n            channelzSessionInfo.lastMessageSentTimestamp = new Date();\n          }\n        },\n        addMessageReceived: () => {\n          if (channelzSessionInfo) {\n            channelzSessionInfo.messagesReceived += 1;\n            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n          }\n        },\n        onCallEnd: status => {\n          if (status.code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        },\n        onStreamEnd: success => {\n          if (channelzSessionInfo) {\n            if (success) {\n              channelzSessionInfo.streamTracker.addCallSucceeded();\n            } else {\n              channelzSessionInfo.streamTracker.addCallFailed();\n            }\n          }\n        }\n      };\n      const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);\n      if (!this._runHandlerForCall(call, handler)) {\n        this.callTracker.addCallFailed();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        call.sendStatus({\n          code: constants_1.Status.INTERNAL,\n          details: `Unknown handler type: ${handler.type}`\n        });\n      }\n    }\n    _streamHandler(extraInterceptors, stream, headers) {\n      // for handling idle timeout\n      this.onStreamOpened(stream);\n      if (this._verifyContentType(stream, headers) !== true) {\n        return;\n      }\n      const path = headers[HTTP2_HEADER_PATH];\n      const handler = this._retrieveHandler(path);\n      if (!handler) {\n        this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n        return;\n      }\n      const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);\n      if (!this._runHandlerForCall(call, handler)) {\n        call.sendStatus({\n          code: constants_1.Status.INTERNAL,\n          details: `Unknown handler type: ${handler.type}`\n        });\n      }\n    }\n    _runHandlerForCall(call, handler) {\n      const {\n        type\n      } = handler;\n      if (type === 'unary') {\n        handleUnary(call, handler);\n      } else if (type === 'clientStream') {\n        handleClientStreaming(call, handler);\n      } else if (type === 'serverStream') {\n        handleServerStreaming(call, handler);\n      } else if (type === 'bidi') {\n        handleBidiStreaming(call, handler);\n      } else {\n        return false;\n      }\n      return true;\n    }\n    _setupHandlers(http2Server, extraInterceptors) {\n      if (http2Server === null) {\n        return;\n      }\n      const serverAddress = http2Server.address();\n      let serverAddressString = 'null';\n      if (serverAddress) {\n        if (typeof serverAddress === 'string') {\n          serverAddressString = serverAddress;\n        } else {\n          serverAddressString = serverAddress.address + ':' + serverAddress.port;\n        }\n      }\n      this.serverAddressString = serverAddressString;\n      const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n      const sessionHandler = this.channelzEnabled ? this._channelzSessionHandler(http2Server) : this._sessionHandler(http2Server);\n      http2Server.on('stream', handler.bind(this, extraInterceptors));\n      http2Server.on('session', sessionHandler);\n    }\n    _sessionHandler(http2Server) {\n      return session => {\n        var _b, _c;\n        (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.add(session);\n        let connectionAgeTimer = null;\n        let connectionAgeGraceTimer = null;\n        let keepaliveTimer = null;\n        let sessionClosedByServer = false;\n        const idleTimeoutObj = this.enableIdleTimeout(session);\n        if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n          // Apply a random jitter within a +/-10% range\n          const jitterMagnitude = this.maxConnectionAgeMs / 10;\n          const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n          connectionAgeTimer = setTimeout(() => {\n            var _b, _c;\n            sessionClosedByServer = true;\n            this.trace('Connection dropped by max connection age: ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\n            try {\n              session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\n            } catch (e) {\n              // The goaway can't be sent because the session is already closed\n              session.destroy();\n              return;\n            }\n            session.close();\n            /* Allow a grace period after sending the GOAWAY before forcibly\n             * closing the connection. */\n            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n              connectionAgeGraceTimer = setTimeout(() => {\n                session.destroy();\n              }, this.maxConnectionAgeGraceMs);\n              (_c = connectionAgeGraceTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeGraceTimer);\n            }\n          }, this.maxConnectionAgeMs + jitter);\n          (_c = connectionAgeTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeTimer);\n        }\n        const clearKeepaliveTimeout = () => {\n          if (keepaliveTimer) {\n            clearTimeout(keepaliveTimer);\n            keepaliveTimer = null;\n          }\n        };\n        const canSendPing = () => {\n          return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;\n        };\n        /* eslint-disable-next-line prefer-const */\n        let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\n        const maybeStartKeepalivePingTimer = () => {\n          var _b;\n          if (!canSendPing()) {\n            return;\n          }\n          this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n          keepaliveTimer = setTimeout(() => {\n            clearKeepaliveTimeout();\n            sendPing();\n          }, this.keepaliveTimeMs);\n          (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\n        };\n        sendPing = () => {\n          var _b;\n          if (!canSendPing()) {\n            return;\n          }\n          this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n          let pingSendError = '';\n          try {\n            const pingSentSuccessfully = session.ping((err, duration, payload) => {\n              clearKeepaliveTimeout();\n              if (err) {\n                this.keepaliveTrace('Ping failed with error: ' + err.message);\n                sessionClosedByServer = true;\n                session.close();\n              } else {\n                this.keepaliveTrace('Received ping response');\n                maybeStartKeepalivePingTimer();\n              }\n            });\n            if (!pingSentSuccessfully) {\n              pingSendError = 'Ping returned false';\n            }\n          } catch (e) {\n            // grpc/grpc-node#2139\n            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n          }\n          if (pingSendError) {\n            this.keepaliveTrace('Ping send failed: ' + pingSendError);\n            this.trace('Connection dropped due to ping send error: ' + pingSendError);\n            sessionClosedByServer = true;\n            session.close();\n            return;\n          }\n          keepaliveTimer = setTimeout(() => {\n            clearKeepaliveTimeout();\n            this.keepaliveTrace('Ping timeout passed without response');\n            this.trace('Connection dropped by keepalive timeout');\n            sessionClosedByServer = true;\n            session.close();\n          }, this.keepaliveTimeoutMs);\n          (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\n        };\n        maybeStartKeepalivePingTimer();\n        session.on('close', () => {\n          var _b, _c;\n          if (!sessionClosedByServer) {\n            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress}`);\n          }\n          if (connectionAgeTimer) {\n            clearTimeout(connectionAgeTimer);\n          }\n          if (connectionAgeGraceTimer) {\n            clearTimeout(connectionAgeGraceTimer);\n          }\n          clearKeepaliveTimeout();\n          if (idleTimeoutObj !== null) {\n            clearTimeout(idleTimeoutObj.timeout);\n            this.sessionIdleTimeouts.delete(session);\n          }\n          (_c = this.http2Servers.get(http2Server)) === null || _c === void 0 ? void 0 : _c.sessions.delete(session);\n        });\n      };\n    }\n    _channelzSessionHandler(http2Server) {\n      return session => {\n        var _b, _c, _d, _e;\n        const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) !== null && _c !== void 0 ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);\n        const channelzSessionInfo = {\n          ref: channelzRef,\n          streamTracker: new channelz_1.ChannelzCallTracker(),\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null\n        };\n        (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);\n        this.sessions.set(session, channelzSessionInfo);\n        const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;\n        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n        this.trace('Connection established by client ' + clientAddress);\n        this.sessionChildrenTracker.refChild(channelzRef);\n        let connectionAgeTimer = null;\n        let connectionAgeGraceTimer = null;\n        let keepaliveTimeout = null;\n        let sessionClosedByServer = false;\n        const idleTimeoutObj = this.enableIdleTimeout(session);\n        if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n          // Apply a random jitter within a +/-10% range\n          const jitterMagnitude = this.maxConnectionAgeMs / 10;\n          const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n          connectionAgeTimer = setTimeout(() => {\n            var _b;\n            sessionClosedByServer = true;\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\n            try {\n              session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\n            } catch (e) {\n              // The goaway can't be sent because the session is already closed\n              session.destroy();\n              return;\n            }\n            session.close();\n            /* Allow a grace period after sending the GOAWAY before forcibly\n             * closing the connection. */\n            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n              connectionAgeGraceTimer = setTimeout(() => {\n                session.destroy();\n              }, this.maxConnectionAgeGraceMs);\n              (_b = connectionAgeGraceTimer.unref) === null || _b === void 0 ? void 0 : _b.call(connectionAgeGraceTimer);\n            }\n          }, this.maxConnectionAgeMs + jitter);\n          (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);\n        }\n        const clearKeepaliveTimeout = () => {\n          if (keepaliveTimeout) {\n            clearTimeout(keepaliveTimeout);\n            keepaliveTimeout = null;\n          }\n        };\n        const canSendPing = () => {\n          return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;\n        };\n        /* eslint-disable-next-line prefer-const */\n        let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\n        const maybeStartKeepalivePingTimer = () => {\n          var _b;\n          if (!canSendPing()) {\n            return;\n          }\n          this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n          keepaliveTimeout = setTimeout(() => {\n            clearKeepaliveTimeout();\n            sendPing();\n          }, this.keepaliveTimeMs);\n          (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\n        };\n        sendPing = () => {\n          var _b;\n          if (!canSendPing()) {\n            return;\n          }\n          this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n          let pingSendError = '';\n          try {\n            const pingSentSuccessfully = session.ping((err, duration, payload) => {\n              clearKeepaliveTimeout();\n              if (err) {\n                this.keepaliveTrace('Ping failed with error: ' + err.message);\n                this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' + err.message + ' return in ' + duration);\n                sessionClosedByServer = true;\n                session.close();\n              } else {\n                this.keepaliveTrace('Received ping response');\n                maybeStartKeepalivePingTimer();\n              }\n            });\n            if (!pingSentSuccessfully) {\n              pingSendError = 'Ping returned false';\n            }\n          } catch (e) {\n            // grpc/grpc-node#2139\n            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n          }\n          if (pingSendError) {\n            this.keepaliveTrace('Ping send failed: ' + pingSendError);\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to ping send error: ' + pingSendError);\n            sessionClosedByServer = true;\n            session.close();\n            return;\n          }\n          channelzSessionInfo.keepAlivesSent += 1;\n          keepaliveTimeout = setTimeout(() => {\n            clearKeepaliveTimeout();\n            this.keepaliveTrace('Ping timeout passed without response');\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\n            sessionClosedByServer = true;\n            session.close();\n          }, this.keepaliveTimeoutMs);\n          (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\n        };\n        maybeStartKeepalivePingTimer();\n        session.on('close', () => {\n          var _b;\n          if (!sessionClosedByServer) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n          }\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          (0, channelz_1.unregisterChannelzRef)(channelzRef);\n          if (connectionAgeTimer) {\n            clearTimeout(connectionAgeTimer);\n          }\n          if (connectionAgeGraceTimer) {\n            clearTimeout(connectionAgeGraceTimer);\n          }\n          clearKeepaliveTimeout();\n          if (idleTimeoutObj !== null) {\n            clearTimeout(idleTimeoutObj.timeout);\n            this.sessionIdleTimeouts.delete(session);\n          }\n          (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.delete(session);\n          this.sessions.delete(session);\n        });\n      };\n    }\n    enableIdleTimeout(session) {\n      var _b, _c;\n      if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {\n        return null;\n      }\n      const idleTimeoutObj = {\n        activeStreams: 0,\n        lastIdle: Date.now(),\n        onClose: this.onStreamClose.bind(this, session),\n        timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session)\n      };\n      (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n      this.sessionIdleTimeouts.set(session, idleTimeoutObj);\n      const {\n        socket\n      } = session;\n      this.trace('Enable idle timeout for ' + socket.remoteAddress + ':' + socket.remotePort);\n      return idleTimeoutObj;\n    }\n    onIdleTimeout(ctx, session) {\n      const {\n        socket\n      } = session;\n      const sessionInfo = ctx.sessionIdleTimeouts.get(session);\n      // if it is called while we have activeStreams - timer will not be rescheduled\n      // until last active stream is closed, then it will call .refresh() on the timer\n      // important part is to not clearTimeout(timer) or it becomes unusable\n      // for future refreshes\n      if (sessionInfo !== undefined && sessionInfo.activeStreams === 0) {\n        if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {\n          ctx.trace('Session idle timeout triggered for ' + (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) + ':' + (socket === null || socket === void 0 ? void 0 : socket.remotePort) + ' last idle at ' + sessionInfo.lastIdle);\n          ctx.closeSession(session);\n        } else {\n          sessionInfo.timeout.refresh();\n        }\n      }\n    }\n    onStreamOpened(stream) {\n      const session = stream.session;\n      const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n      if (idleTimeoutObj) {\n        idleTimeoutObj.activeStreams += 1;\n        stream.once('close', idleTimeoutObj.onClose);\n      }\n    }\n    onStreamClose(session) {\n      var _b, _c;\n      const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n      if (idleTimeoutObj) {\n        idleTimeoutObj.activeStreams -= 1;\n        if (idleTimeoutObj.activeStreams === 0) {\n          idleTimeoutObj.lastIdle = Date.now();\n          idleTimeoutObj.timeout.refresh();\n          this.trace('Session onStreamClose' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) + ':' + ((_c = session.socket) === null || _c === void 0 ? void 0 : _c.remotePort) + ' at ' + idleTimeoutObj.lastIdle);\n        }\n      }\n    }\n  }, (() => {\n    const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n    _start_decorators = [deprecate('Calling start() is no longer necessary. It can be safely omitted.')];\n    __esDecorate(_a, null, _start_decorators, {\n      kind: \"method\",\n      name: \"start\",\n      static: false,\n      private: false,\n      access: {\n        has: obj => \"start\" in obj,\n        get: obj => obj.start\n      },\n      metadata: _metadata\n    }, null, _instanceExtraInitializers);\n    if (_metadata) Object.defineProperty(_a, Symbol.metadata, {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _metadata\n    });\n  })(), _a;\n})();\nexports.Server = Server;\nasync function handleUnary(call, handler) {\n  let stream;\n  function respond(err, value, trailer, flags) {\n    if (err) {\n      call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\n      return;\n    }\n    call.sendMessage(value, () => {\n      call.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata: trailer !== null && trailer !== void 0 ? trailer : null\n      });\n    });\n  }\n  let requestMetadata;\n  let requestMessage = null;\n  call.start({\n    onReceiveMetadata(metadata) {\n      requestMetadata = metadata;\n      call.startRead();\n    },\n    onReceiveMessage(message) {\n      if (requestMessage) {\n        call.sendStatus({\n          code: constants_1.Status.UNIMPLEMENTED,\n          details: `Received a second request message for server streaming method ${handler.path}`,\n          metadata: null\n        });\n        return;\n      }\n      requestMessage = message;\n      call.startRead();\n    },\n    onReceiveHalfClose() {\n      if (!requestMessage) {\n        call.sendStatus({\n          code: constants_1.Status.UNIMPLEMENTED,\n          details: `Received no request message for server streaming method ${handler.path}`,\n          metadata: null\n        });\n        return;\n      }\n      stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\n      try {\n        handler.func(stream, respond);\n      } catch (err) {\n        call.sendStatus({\n          code: constants_1.Status.UNKNOWN,\n          details: `Server method handler threw error ${err.message}`,\n          metadata: null\n        });\n      }\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n      }\n    }\n  });\n}\nfunction handleClientStreaming(call, handler) {\n  let stream;\n  function respond(err, value, trailer, flags) {\n    if (err) {\n      call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\n      return;\n    }\n    call.sendMessage(value, () => {\n      call.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata: trailer !== null && trailer !== void 0 ? trailer : null\n      });\n    });\n  }\n  call.start({\n    onReceiveMetadata(metadata) {\n      stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\n      try {\n        handler.func(stream, respond);\n      } catch (err) {\n        call.sendStatus({\n          code: constants_1.Status.UNKNOWN,\n          details: `Server method handler threw error ${err.message}`,\n          metadata: null\n        });\n      }\n    },\n    onReceiveMessage(message) {\n      stream.push(message);\n    },\n    onReceiveHalfClose() {\n      stream.push(null);\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    }\n  });\n}\nfunction handleServerStreaming(call, handler) {\n  let stream;\n  let requestMetadata;\n  let requestMessage = null;\n  call.start({\n    onReceiveMetadata(metadata) {\n      requestMetadata = metadata;\n      call.startRead();\n    },\n    onReceiveMessage(message) {\n      if (requestMessage) {\n        call.sendStatus({\n          code: constants_1.Status.UNIMPLEMENTED,\n          details: `Received a second request message for server streaming method ${handler.path}`,\n          metadata: null\n        });\n        return;\n      }\n      requestMessage = message;\n      call.startRead();\n    },\n    onReceiveHalfClose() {\n      if (!requestMessage) {\n        call.sendStatus({\n          code: constants_1.Status.UNIMPLEMENTED,\n          details: `Received no request message for server streaming method ${handler.path}`,\n          metadata: null\n        });\n        return;\n      }\n      stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\n      try {\n        handler.func(stream);\n      } catch (err) {\n        call.sendStatus({\n          code: constants_1.Status.UNKNOWN,\n          details: `Server method handler threw error ${err.message}`,\n          metadata: null\n        });\n      }\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    }\n  });\n}\nfunction handleBidiStreaming(call, handler) {\n  let stream;\n  call.start({\n    onReceiveMetadata(metadata) {\n      stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\n      try {\n        handler.func(stream);\n      } catch (err) {\n        call.sendStatus({\n          code: constants_1.Status.UNKNOWN,\n          details: `Server method handler threw error ${err.message}`,\n          metadata: null\n        });\n      }\n    },\n    onReceiveMessage(message) {\n      stream.push(message);\n    },\n    onReceiveHalfClose() {\n      stream.push(null);\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    }\n  });\n}","map":{"version":3,"names":["http2","require","util","constants_1","server_call_1","server_credentials_1","resolver_1","logging","subchannel_address_1","uri_parser_1","channelz_1","server_interceptors_1","UNLIMITED_CONNECTION_AGE_MS","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","MAX_CONNECTION_IDLE_MS","HTTP2_HEADER_PATH","constants","TRACER_NAME","kMaxAge","Buffer","from","noop","deprecate","message","target","context","getUnimplementedStatusResponse","methodName","code","Status","UNIMPLEMENTED","details","getDefaultHandler","handlerType","unimplementedStatusResponse","call","callback","emit","Error","Server","constructor","options","boundPorts","__runInitializers","_instanceExtraInitializers","Map","http2Servers","sessionIdleTimeouts","handlers","sessions","started","shutdown","serverAddressString","channelzEnabled","channelzTrace","ChannelzTraceStub","callTracker","ChannelzCallTrackerStub","listenerChildrenTracker","ChannelzChildrenTrackerStub","sessionChildrenTracker","ChannelzTrace","ChannelzCallTracker","ChannelzChildrenTracker","channelzRef","registerChannelzServer","getChannelzInfo","addTrace","maxConnectionAgeMs","_b","maxConnectionAgeGraceMs","_c","keepaliveTimeMs","_d","keepaliveTimeoutMs","_e","sessionIdleTimeout","_f","commonServerOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","settings","maxConcurrentStreams","interceptors","_g","trace","listenerChildren","getChildLists","sessionChildren","getChannelzSessionInfo","session","sessionInfo","get","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastRemoteStreamCreatedTimestamp","lastCallStartedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","state","localWindowSize","remoteFlowControlWindow","remoteWindowSize","text","LogVerbosity","DEBUG","id","keepaliveTrace","addProtoService","addService","service","implementation","serviceKeys","Object","keys","length","forEach","attrs","methodType","requestStream","responseStream","implFn","impl","undefined","originalName","bind","success","register","path","responseSerialize","requestDeserialize","removeService","unregister","port","creds","registerListenerToChannelz","boundAddress","registerChannelzSocket","subchannelAddressToString","createHttp2Server","credentials","http2Server","_isSecure","credentialsSettings","_getSettings","secureServerOptions","assign","enableTrace","areCredentialsValid","createSecureServer","on","destroy","e","credsWatcher","setSecureContext","_addWatcher","_removeWatcher","createServer","setTimeout","_setupHandlers","_getInterceptors","bindOneAddress","address","boundPortObject","Promise","resolve","reject","onError","err","error","once","listen","boundSubchannelAddress","host","refChild","set","Set","listeningServers","add","removeListener","bindManyPorts","addressList","count","errors","isTcpSubchannelAddress","firstAddressResult","restAddressResult","slice","restAddresses","map","all","allResults","filter","result","bindAddressList","bindResult","log","INFO","errorString","ERROR","join","resolvePort","resolverListener","onSuccessfulResolution","endpointList","serviceConfig","serviceConfigError","concat","endpoint","addresses","resolver","createResolver","updateResolution","bindPort","cancelled","completeUnbind","portNumber","normalizePort","initialPortUri","parseUri","portUri","mapUriDefaultScheme","bindAsync","TypeError","ServerCredentials","deferredCallback","process","nextTick","uriToString","_equals","completionPromise","then","portNum","mapKey","originalUri","splitPort","splitHostPort","finalUri","scheme","authority","combineHostPort","registerInjectorToChannelz","createConnectionInjector","server","sessionsSet","injectConnection","connection","drain","graceTimeMs","closeSession","NGHTTP2_CANCEL","unref","closeServer","JSON","stringify","serverInfo","close","unrefChild","unregisterChannelzRef","delete","closeCallback","ref","closed","queueMicrotask","unbind","allSessions","serverEntry","forceShutdown","values","clear","channelzInfo","handler","serialize","deserialize","type","has","func","start","size","every","listening","tryShutdown","wrappedCallback","pendingChecks","maybeCallback","serverKey","entries","serverString","sessionString","addHttp2Port","getChannelzRef","_verifyContentType","stream","headers","contentType","HTTP2_HEADER_CONTENT_TYPE","startsWith","respond","HTTP2_HEADER_STATUS","HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE","endStream","_retrieveHandler","_respondWithError","channelzSessionInfo","trailersToSend","INTERNAL","HTTP_STATUS_OK","metadata","toHttp2Headers","addCallFailed","_channelzHandler","extraInterceptors","onStreamOpened","addCallStarted","callEventTracker","addMessageSent","Date","addMessageReceived","onCallEnd","status","OK","addCallSucceeded","onStreamEnd","getServerInterceptingCall","_runHandlerForCall","sendStatus","_streamHandler","handleUnary","handleClientStreaming","handleServerStreaming","handleBidiStreaming","serverAddress","sessionHandler","_channelzSessionHandler","_sessionHandler","connectionAgeTimer","connectionAgeGraceTimer","keepaliveTimer","sessionClosedByServer","idleTimeoutObj","enableIdleTimeout","jitterMagnitude","jitter","Math","random","goaway","NGHTTP2_NO_ERROR","clearKeepaliveTimeout","clearTimeout","canSendPing","destroyed","sendPing","maybeStartKeepalivePingTimer","pingSendError","pingSentSuccessfully","ping","duration","payload","timeout","clientAddress","keepaliveTimeout","activeStreams","lastIdle","now","onClose","onStreamClose","onIdleTimeout","ctx","refresh","__esDecorate","_a","_start_decorators","kind","static","private","access","obj","_metadata","exports","value","trailer","flags","serverErrorToStatus","sendMessage","requestMetadata","requestMessage","onReceiveMetadata","startRead","onReceiveMessage","onReceiveHalfClose","ServerWritableStreamImpl","UNKNOWN","onCancel","ServerDuplexStreamImpl","push"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/server.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport * as util from 'util';\n\nimport { ServiceError } from './call';\nimport { Status, LogVerbosity } from './constants';\nimport { Deserialize, Serialize, ServiceDefinition } from './make-client';\nimport { Metadata } from './metadata';\nimport {\n  BidiStreamingHandler,\n  ClientStreamingHandler,\n  HandleCall,\n  Handler,\n  HandlerType,\n  sendUnaryData,\n  ServerDuplexStream,\n  ServerDuplexStreamImpl,\n  ServerReadableStream,\n  ServerStreamingHandler,\n  ServerUnaryCall,\n  ServerWritableStream,\n  ServerWritableStreamImpl,\n  UnaryHandler,\n  ServerErrorResponse,\n  ServerStatusResponse,\n  serverErrorToStatus,\n} from './server-call';\nimport { SecureContextWatcher, ServerCredentials } from './server-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  createResolver,\n  ResolverListener,\n  mapUriDefaultScheme,\n} from './resolver';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n  stringToSubchannelAddress,\n} from './subchannel-address';\nimport {\n  GrpcUri,\n  combineHostPort,\n  parseUri,\n  splitHostPort,\n  uriToString,\n} from './uri-parser';\nimport {\n  ChannelzCallTracker,\n  ChannelzCallTrackerStub,\n  ChannelzChildrenTracker,\n  ChannelzChildrenTrackerStub,\n  ChannelzTrace,\n  ChannelzTraceStub,\n  registerChannelzServer,\n  registerChannelzSocket,\n  ServerInfo,\n  ServerRef,\n  SocketInfo,\n  SocketRef,\n  TlsInfo,\n  unregisterChannelzRef,\n} from './channelz';\nimport { CipherNameAndProtocol, TLSSocket } from 'tls';\nimport {\n  ServerInterceptingCallInterface,\n  ServerInterceptor,\n  getServerInterceptingCall,\n} from './server-interceptors';\nimport { PartialStatusObject } from './call-interface';\nimport { CallEventTracker } from './transport';\nimport { Socket } from 'net';\nimport { Duplex } from 'stream';\n\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst MAX_CONNECTION_IDLE_MS = ~(1 << 31);\n\nconst { HTTP2_HEADER_PATH } = http2.constants;\n\nconst TRACER_NAME = 'server';\nconst kMaxAge = Buffer.from('max_age');\n\ntype AnyHttp2Server = http2.Http2Server | http2.Http2SecureServer;\n\ninterface BindResult {\n  port: number;\n  count: number;\n  errors: string[];\n}\n\ninterface SingleAddressBindResult {\n  port: number;\n  error?: string;\n}\n\nfunction noop(): void {}\n\n/**\n * Decorator to wrap a class method with util.deprecate\n * @param message The message to output if the deprecated method is called\n * @returns\n */\nfunction deprecate(message: string) {\n  return function <This, Args extends any[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext<\n      This,\n      (this: This, ...args: Args) => Return\n    >\n  ) {\n    return util.deprecate(target, message);\n  };\n}\n\nfunction getUnimplementedStatusResponse(\n  methodName: string\n): PartialStatusObject {\n  return {\n    code: Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedUnaryHandler = UnaryHandler<any, any>;\ntype UntypedClientStreamingHandler = ClientStreamingHandler<any, any>;\ntype UntypedServerStreamingHandler = ServerStreamingHandler<any, any>;\ntype UntypedBidiStreamingHandler = BidiStreamingHandler<any, any>;\nexport type UntypedHandleCall = HandleCall<any, any>;\ntype UntypedHandler = Handler<any, any>;\nexport interface UntypedServiceImplementation {\n  [name: string]: UntypedHandleCall;\n}\n\nfunction getDefaultHandler(handlerType: HandlerType, methodName: string) {\n  const unimplementedStatusResponse =\n    getUnimplementedStatusResponse(methodName);\n  switch (handlerType) {\n    case 'unary':\n      return (\n        call: ServerUnaryCall<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'clientStream':\n      return (\n        call: ServerReadableStream<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'serverStream':\n      return (call: ServerWritableStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return (call: ServerDuplexStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\n\ninterface ChannelzSessionInfo {\n  ref: SocketRef;\n  streamTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n  messagesSent: number;\n  messagesReceived: number;\n  keepAlivesSent: number;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n}\n\n/**\n * Information related to a single invocation of bindAsync. This should be\n * tracked in a map keyed by target string, normalized with a pass through\n * parseUri -> mapUriDefaultScheme -> uriToString. If the target has a port\n * number and the port number is 0, the target string is modified with the\n * concrete bound port.\n */\ninterface BoundPort {\n  /**\n   * The key used to refer to this object in the boundPorts map.\n   */\n  mapKey: string;\n  /**\n   * The target string, passed through parseUri -> mapUriDefaultScheme. Used\n   * to determine the final key when the port number is 0.\n   */\n  originalUri: GrpcUri;\n  /**\n   * If there is a pending bindAsync operation, this is a promise that resolves\n   * with the port number when that operation succeeds. If there is no such\n   * operation pending, this is null.\n   */\n  completionPromise: Promise<number> | null;\n  /**\n   * The port number that was actually bound. Populated only after\n   * completionPromise resolves.\n   */\n  portNumber: number;\n  /**\n   * Set by unbind if called while pending is true.\n   */\n  cancelled: boolean;\n  /**\n   * The credentials object passed to the original bindAsync call.\n   */\n  credentials: ServerCredentials;\n  /**\n   * The set of servers associated with this listening port. A target string\n   * that expands to multiple addresses will result in multiple listening\n   * servers.\n   */\n  listeningServers: Set<AnyHttp2Server>;\n}\n\n/**\n * Should be in a map keyed by AnyHttp2Server.\n */\ninterface Http2ServerInfo {\n  channelzRef: SocketRef;\n  sessions: Set<http2.ServerHttp2Session>;\n}\n\ninterface SessionIdleTimeoutTracker {\n  activeStreams: number;\n  lastIdle: number;\n  timeout: NodeJS.Timeout;\n  onClose: (session: http2.ServerHttp2Session) => void | null;\n}\n\nexport interface ServerOptions extends ChannelOptions {\n  interceptors?: ServerInterceptor[];\n}\n\nexport interface ConnectionInjector {\n  injectConnection(connection: Duplex): void;\n  drain(graceTimeMs: number): void;\n  destroy(): void;\n}\n\nexport class Server {\n  private boundPorts: Map<string, BoundPort> = new Map();\n  private http2Servers: Map<AnyHttp2Server, Http2ServerInfo> = new Map();\n  private sessionIdleTimeouts = new Map<\n    http2.ServerHttp2Session,\n    SessionIdleTimeoutTracker\n  >();\n\n  private handlers: Map<string, UntypedHandler> = new Map<\n    string,\n    UntypedHandler\n  >();\n  private sessions = new Map<http2.ServerHttp2Session, ChannelzSessionInfo>();\n  /**\n   * This field only exists to ensure that the start method throws an error if\n   * it is called twice, as it did previously.\n   */\n  private started = false;\n  private shutdown = false;\n  private options: ServerOptions;\n  private serverAddressString = 'null';\n\n  // Channelz Info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: ServerRef;\n  private channelzTrace: ChannelzTrace | ChannelzTraceStub;\n  private callTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n  private listenerChildrenTracker:\n    | ChannelzChildrenTracker\n    | ChannelzChildrenTrackerStub;\n  private sessionChildrenTracker:\n    | ChannelzChildrenTracker\n    | ChannelzChildrenTrackerStub;\n\n  private readonly maxConnectionAgeMs: number;\n  private readonly maxConnectionAgeGraceMs: number;\n\n  private readonly keepaliveTimeMs: number;\n  private readonly keepaliveTimeoutMs: number;\n\n  private readonly sessionIdleTimeout: number;\n\n  private readonly interceptors: ServerInterceptor[];\n\n  /**\n   * Options that will be used to construct all Http2Server instances for this\n   * Server.\n   */\n  private commonServerOptions: http2.ServerOptions;\n\n  constructor(options?: ServerOptions) {\n    this.options = options ?? {};\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.channelzTrace = new ChannelzTraceStub();\n      this.callTracker = new ChannelzCallTrackerStub();\n      this.listenerChildrenTracker = new ChannelzChildrenTrackerStub();\n      this.sessionChildrenTracker = new ChannelzChildrenTrackerStub();\n    } else {\n      this.channelzTrace = new ChannelzTrace();\n      this.callTracker = new ChannelzCallTracker();\n      this.listenerChildrenTracker = new ChannelzChildrenTracker();\n      this.sessionChildrenTracker = new ChannelzChildrenTracker();\n    }\n\n    this.channelzRef = registerChannelzServer(\n      'server',\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n\n    this.channelzTrace.addTrace('CT_INFO', 'Server created');\n    this.maxConnectionAgeMs =\n      this.options['grpc.max_connection_age_ms'] ?? UNLIMITED_CONNECTION_AGE_MS;\n    this.maxConnectionAgeGraceMs =\n      this.options['grpc.max_connection_age_grace_ms'] ??\n      UNLIMITED_CONNECTION_AGE_MS;\n    this.keepaliveTimeMs =\n      this.options['grpc.keepalive_time_ms'] ?? KEEPALIVE_MAX_TIME_MS;\n    this.keepaliveTimeoutMs =\n      this.options['grpc.keepalive_timeout_ms'] ?? KEEPALIVE_TIMEOUT_MS;\n    this.sessionIdleTimeout =\n      this.options['grpc.max_connection_idle_ms'] ?? MAX_CONNECTION_IDLE_MS;\n\n    this.commonServerOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\n    };\n    if ('grpc-node.max_session_memory' in this.options) {\n      this.commonServerOptions.maxSessionMemory =\n        this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    if ('grpc.max_concurrent_streams' in this.options) {\n      this.commonServerOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n      };\n    }\n    this.interceptors = this.options.interceptors ?? [];\n    this.trace('Server constructed');\n  }\n\n  private getChannelzInfo(): ServerInfo {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists(),\n    };\n  }\n\n  private getChannelzSessionInfo(\n    session: http2.ServerHttp2Session\n  ): SocketInfo {\n    const sessionInfo = this.sessions.get(session)!;\n    const sessionSocket = session.socket;\n    const remoteAddress = sessionSocket.remoteAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.remoteAddress,\n          sessionSocket.remotePort\n        )\n      : null;\n    const localAddress = sessionSocket.localAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.localAddress!,\n          sessionSocket.localPort\n        )\n      : null;\n    let tlsInfo: TlsInfo | null;\n    if (session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & { standardName?: string } =\n        tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate:\n          certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate:\n          peerCertificate && 'raw' in peerCertificate\n            ? peerCertificate.raw\n            : null,\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: null,\n      streamsStarted: sessionInfo.streamTracker.callsStarted,\n      streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n      streamsFailed: sessionInfo.streamTracker.callsFailed,\n      messagesSent: sessionInfo.messagesSent,\n      messagesReceived: sessionInfo.messagesReceived,\n      keepAlivesSent: sessionInfo.keepAlivesSent,\n      lastLocalStreamCreatedTimestamp: null,\n      lastRemoteStreamCreatedTimestamp:\n        sessionInfo.streamTracker.lastCallStartedTimestamp,\n      lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n      localFlowControlWindow: session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: session.state.remoteWindowSize ?? null,\n    };\n    return socketInfo;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' + this.channelzRef.id + ') ' + text\n    );\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'keepalive',\n      '(' + this.channelzRef.id + ') ' + text\n    );\n  }\n\n  addProtoService(): never {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(\n    service: ServiceDefinition,\n    implementation: UntypedServiceImplementation\n  ): void {\n    if (\n      service === null ||\n      typeof service !== 'object' ||\n      implementation === null ||\n      typeof implementation !== 'object'\n    ) {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType: HandlerType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(\n        attrs.path,\n        impl as UntypedHandleCall,\n        attrs.responseSerialize,\n        attrs.requestDeserialize,\n        methodType\n      );\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  removeService(service: ServiceDefinition): void {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n\n  bind(port: string, creds: ServerCredentials): never {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  private registerListenerToChannelz(boundAddress: SubchannelAddress) {\n    return registerChannelzSocket(\n      subchannelAddressToString(boundAddress),\n      () => {\n        return {\n          localAddress: boundAddress,\n          remoteAddress: null,\n          security: null,\n          remoteName: null,\n          streamsStarted: 0,\n          streamsSucceeded: 0,\n          streamsFailed: 0,\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastLocalStreamCreatedTimestamp: null,\n          lastRemoteStreamCreatedTimestamp: null,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null,\n          localFlowControlWindow: null,\n          remoteFlowControlWindow: null,\n        };\n      },\n      this.channelzEnabled\n    );\n  }\n\n  private createHttp2Server(credentials: ServerCredentials) {\n    let http2Server: http2.Http2Server | http2.Http2SecureServer;\n    if (credentials._isSecure()) {\n      const credentialsSettings = credentials._getSettings();\n      const secureServerOptions: http2.SecureServerOptions = {\n        ...this.commonServerOptions,\n        ...credentialsSettings,\n        enableTrace: this.options['grpc-node.tls_enable_trace'] === 1\n      };\n      let areCredentialsValid = credentialsSettings !== null;\n      http2Server = http2.createSecureServer(secureServerOptions);\n      http2Server.on('connection', (socket: Socket) => {\n        if (!areCredentialsValid) {\n          socket.destroy();\n        }\n      });\n      http2Server.on('secureConnection', (socket: TLSSocket) => {\n        /* These errors need to be handled by the user of Http2SecureServer,\n         * according to https://github.com/nodejs/node/issues/35824 */\n        socket.on('error', (e: Error) => {\n          this.trace(\n            'An incoming TLS connection closed with error: ' + e.message\n          );\n        });\n      });\n      const credsWatcher: SecureContextWatcher = options => {\n        if (options) {\n          (http2Server as http2.Http2SecureServer).setSecureContext(options);\n        }\n        areCredentialsValid = options !== null;\n      }\n      credentials._addWatcher(credsWatcher);\n      http2Server.on('close', () => {\n        credentials._removeWatcher(credsWatcher);\n      });\n    } else {\n      http2Server = http2.createServer(this.commonServerOptions);\n    }\n\n    http2Server.setTimeout(0, noop);\n    this._setupHandlers(http2Server, credentials._getInterceptors());\n    return http2Server;\n  }\n\n  private bindOneAddress(\n    address: SubchannelAddress,\n    boundPortObject: BoundPort\n  ): Promise<SingleAddressBindResult> {\n    this.trace('Attempting to bind ' + subchannelAddressToString(address));\n    const http2Server = this.createHttp2Server(boundPortObject.credentials);\n    return new Promise<SingleAddressBindResult>((resolve, reject) => {\n      const onError = (err: Error) => {\n        this.trace(\n          'Failed to bind ' +\n            subchannelAddressToString(address) +\n            ' with error ' +\n            err.message\n        );\n        resolve({\n          port: 'port' in address ? address.port : 1,\n          error: err.message,\n        });\n      };\n\n      http2Server.once('error', onError);\n\n      http2Server.listen(address, () => {\n        const boundAddress = http2Server.address()!;\n        let boundSubchannelAddress: SubchannelAddress;\n        if (typeof boundAddress === 'string') {\n          boundSubchannelAddress = {\n            path: boundAddress,\n          };\n        } else {\n          boundSubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port,\n          };\n        }\n\n        const channelzRef = this.registerListenerToChannelz(\n          boundSubchannelAddress\n        );\n        this.listenerChildrenTracker.refChild(channelzRef);\n\n        this.http2Servers.set(http2Server, {\n          channelzRef: channelzRef,\n          sessions: new Set(),\n        });\n        boundPortObject.listeningServers.add(http2Server);\n        this.trace(\n          'Successfully bound ' +\n            subchannelAddressToString(boundSubchannelAddress)\n        );\n        resolve({\n          port:\n            'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,\n        });\n        http2Server.removeListener('error', onError);\n      });\n    });\n  }\n\n  private async bindManyPorts(\n    addressList: SubchannelAddress[],\n    boundPortObject: BoundPort\n  ): Promise<BindResult> {\n    if (addressList.length === 0) {\n      return {\n        count: 0,\n        port: 0,\n        errors: [],\n      };\n    }\n    if (isTcpSubchannelAddress(addressList[0]) && addressList[0].port === 0) {\n      /* If binding to port 0, first try to bind the first address, then bind\n       * the rest of the address list to the specific port that it binds. */\n      const firstAddressResult = await this.bindOneAddress(\n        addressList[0],\n        boundPortObject\n      );\n      if (firstAddressResult.error) {\n        /* If the first address fails to bind, try the same operation starting\n         * from the second item in the list. */\n        const restAddressResult = await this.bindManyPorts(\n          addressList.slice(1),\n          boundPortObject\n        );\n        return {\n          ...restAddressResult,\n          errors: [firstAddressResult.error, ...restAddressResult.errors],\n        };\n      } else {\n        const restAddresses = addressList\n          .slice(1)\n          .map(address =>\n            isTcpSubchannelAddress(address)\n              ? { host: address.host, port: firstAddressResult.port }\n              : address\n          );\n        const restAddressResult = await Promise.all(\n          restAddresses.map(address =>\n            this.bindOneAddress(address, boundPortObject)\n          )\n        );\n        const allResults = [firstAddressResult, ...restAddressResult];\n        return {\n          count: allResults.filter(result => result.error === undefined).length,\n          port: firstAddressResult.port,\n          errors: allResults\n            .filter(result => result.error)\n            .map(result => result.error!),\n        };\n      }\n    } else {\n      const allResults = await Promise.all(\n        addressList.map(address =>\n          this.bindOneAddress(address, boundPortObject)\n        )\n      );\n      return {\n        count: allResults.filter(result => result.error === undefined).length,\n        port: allResults[0].port,\n        errors: allResults\n          .filter(result => result.error)\n          .map(result => result.error!),\n      };\n    }\n  }\n\n  private async bindAddressList(\n    addressList: SubchannelAddress[],\n    boundPortObject: BoundPort\n  ): Promise<number> {\n    const bindResult = await this.bindManyPorts(addressList, boundPortObject);\n    if (bindResult.count > 0) {\n      if (bindResult.count < addressList.length) {\n        logging.log(\n          LogVerbosity.INFO,\n          `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`\n        );\n      }\n      return bindResult.port;\n    } else {\n      const errorString = `No address added out of total ${addressList.length} resolved`;\n      logging.log(LogVerbosity.ERROR, errorString);\n      throw new Error(\n        `${errorString} errors: [${bindResult.errors.join(',')}]`\n      );\n    }\n  }\n\n  private resolvePort(port: GrpcUri): Promise<SubchannelAddress[]> {\n    return new Promise<SubchannelAddress[]>((resolve, reject) => {\n      const resolverListener: ResolverListener = {\n        onSuccessfulResolution: (\n          endpointList,\n          serviceConfig,\n          serviceConfigError\n        ) => {\n          // We only want one resolution result. Discard all future results\n          resolverListener.onSuccessfulResolution = () => {};\n          const addressList = ([] as SubchannelAddress[]).concat(\n            ...endpointList.map(endpoint => endpoint.addresses)\n          );\n          if (addressList.length === 0) {\n            reject(new Error(`No addresses resolved for port ${port}`));\n            return;\n          }\n          resolve(addressList);\n        },\n        onError: error => {\n          reject(new Error(error.details));\n        },\n      };\n      const resolver = createResolver(port, resolverListener, this.options);\n      resolver.updateResolution();\n    });\n  }\n\n  private async bindPort(\n    port: GrpcUri,\n    boundPortObject: BoundPort\n  ): Promise<number> {\n    const addressList = await this.resolvePort(port);\n    if (boundPortObject.cancelled) {\n      this.completeUnbind(boundPortObject);\n      throw new Error('bindAsync operation cancelled by unbind call');\n    }\n    const portNumber = await this.bindAddressList(addressList, boundPortObject);\n    if (boundPortObject.cancelled) {\n      this.completeUnbind(boundPortObject);\n      throw new Error('bindAsync operation cancelled by unbind call');\n    }\n    return portNumber;\n  }\n\n  private normalizePort(port: string): GrpcUri {\n    const initialPortUri = parseUri(port);\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n    const portUri = mapUriDefaultScheme(initialPortUri);\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n    return portUri;\n  }\n\n  bindAsync(\n    port: string,\n    creds: ServerCredentials,\n    callback: (error: Error | null, port: number) => void\n  ): void {\n    if (this.shutdown) {\n      throw new Error('bindAsync called after shutdown');\n    }\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || !(creds instanceof ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    this.trace('bindAsync port=' + port);\n\n    const portUri = this.normalizePort(port);\n\n    const deferredCallback = (error: Error | null, port: number) => {\n      process.nextTick(() => callback(error, port));\n    };\n\n    /* First, if this port is already bound or that bind operation is in\n     * progress, use that result. */\n    let boundPortObject = this.boundPorts.get(uriToString(portUri));\n    if (boundPortObject) {\n      if (!creds._equals(boundPortObject.credentials)) {\n        deferredCallback(\n          new Error(`${port} already bound with incompatible credentials`),\n          0\n        );\n        return;\n      }\n      /* If that operation has previously been cancelled by an unbind call,\n       * uncancel it. */\n      boundPortObject.cancelled = false;\n      if (boundPortObject.completionPromise) {\n        boundPortObject.completionPromise.then(\n          portNum => callback(null, portNum),\n          error => callback(error as Error, 0)\n        );\n      } else {\n        deferredCallback(null, boundPortObject.portNumber);\n      }\n      return;\n    }\n    boundPortObject = {\n      mapKey: uriToString(portUri),\n      originalUri: portUri,\n      completionPromise: null,\n      cancelled: false,\n      portNumber: 0,\n      credentials: creds,\n      listeningServers: new Set(),\n    };\n    const splitPort = splitHostPort(portUri.path);\n    const completionPromise = this.bindPort(portUri, boundPortObject);\n    boundPortObject.completionPromise = completionPromise;\n    /* If the port number is 0, defer populating the map entry until after the\n     * bind operation completes and we have a specific port number. Otherwise,\n     * populate it immediately. */\n    if (splitPort?.port === 0) {\n      completionPromise.then(\n        portNum => {\n          const finalUri: GrpcUri = {\n            scheme: portUri.scheme,\n            authority: portUri.authority,\n            path: combineHostPort({ host: splitPort.host, port: portNum }),\n          };\n          boundPortObject!.mapKey = uriToString(finalUri);\n          boundPortObject!.completionPromise = null;\n          boundPortObject!.portNumber = portNum;\n          this.boundPorts.set(boundPortObject!.mapKey, boundPortObject!);\n          callback(null, portNum);\n        },\n        error => {\n          callback(error, 0);\n        }\n      );\n    } else {\n      this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n      completionPromise.then(\n        portNum => {\n          boundPortObject!.completionPromise = null;\n          boundPortObject!.portNumber = portNum;\n          callback(null, portNum);\n        },\n        error => {\n          callback(error, 0);\n        }\n      );\n    }\n  }\n\n  private registerInjectorToChannelz() {\n    return registerChannelzSocket(\n      'injector',\n      () => {\n        return {\n          localAddress: null,\n          remoteAddress: null,\n          security: null,\n          remoteName: null,\n          streamsStarted: 0,\n          streamsSucceeded: 0,\n          streamsFailed: 0,\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastLocalStreamCreatedTimestamp: null,\n          lastRemoteStreamCreatedTimestamp: null,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null,\n          localFlowControlWindow: null,\n          remoteFlowControlWindow: null,\n        };\n      },\n      this.channelzEnabled\n    );\n  }\n\n  createConnectionInjector(credentials: ServerCredentials): ConnectionInjector {\n    if (credentials === null || !(credentials instanceof ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n    const server = this.createHttp2Server(credentials);\n    const channelzRef = this.registerInjectorToChannelz();\n    if (this.channelzEnabled) {\n      this.listenerChildrenTracker.refChild(channelzRef);\n    }\n    const sessionsSet: Set<http2.ServerHttp2Session> = new Set();\n    this.http2Servers.set(server, {\n      channelzRef: channelzRef,\n      sessions: sessionsSet\n    });\n    return {\n      injectConnection: (connection: Duplex) => {\n        server.emit('connection', connection);\n      },\n      drain: (graceTimeMs: number) => {\n        for (const session of sessionsSet) {\n          this.closeSession(session);\n        }\n        setTimeout(() => {\n          for (const session of sessionsSet) {\n            session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n          }\n        }, graceTimeMs).unref?.();\n      },\n      destroy: () => {\n        this.closeServer(server)\n        for (const session of sessionsSet) {\n          this.closeSession(session);\n        }\n      }\n    };\n  }\n\n  private closeServer(server: AnyHttp2Server, callback?: () => void) {\n    this.trace(\n      'Closing server with address ' + JSON.stringify(server.address())\n    );\n    const serverInfo = this.http2Servers.get(server);\n    server.close(() => {\n      if (serverInfo) {\n        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);\n        unregisterChannelzRef(serverInfo.channelzRef);\n      }\n      this.http2Servers.delete(server);\n      callback?.();\n    });\n  }\n\n  private closeSession(\n    session: http2.ServerHttp2Session,\n    callback?: () => void\n  ) {\n    this.trace('Closing session initiated by ' + session.socket?.remoteAddress);\n    const sessionInfo = this.sessions.get(session);\n    const closeCallback = () => {\n      if (sessionInfo) {\n        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);\n        unregisterChannelzRef(sessionInfo.ref);\n      }\n      callback?.();\n    };\n    if (session.closed) {\n      queueMicrotask(closeCallback);\n    } else {\n      session.close(closeCallback);\n    }\n  }\n\n  private completeUnbind(boundPortObject: BoundPort) {\n    for (const server of boundPortObject.listeningServers) {\n      const serverInfo = this.http2Servers.get(server);\n      this.closeServer(server, () => {\n        boundPortObject.listeningServers.delete(server);\n      });\n      if (serverInfo) {\n        for (const session of serverInfo.sessions) {\n          this.closeSession(session);\n        }\n      }\n    }\n    this.boundPorts.delete(boundPortObject.mapKey);\n  }\n\n  /**\n   * Unbind a previously bound port, or cancel an in-progress bindAsync\n   * operation. If port 0 was bound, only the actual bound port can be\n   * unbound. For example, if bindAsync was called with \"localhost:0\" and the\n   * bound port result was 54321, it can be unbound as \"localhost:54321\".\n   * @param port\n   */\n  unbind(port: string): void {\n    this.trace('unbind port=' + port);\n    const portUri = this.normalizePort(port);\n    const splitPort = splitHostPort(portUri.path);\n    if (splitPort?.port === 0) {\n      throw new Error('Cannot unbind port 0');\n    }\n    const boundPortObject = this.boundPorts.get(uriToString(portUri));\n    if (boundPortObject) {\n      this.trace(\n        'unbinding ' +\n          boundPortObject.mapKey +\n          ' originally bound as ' +\n          uriToString(boundPortObject.originalUri)\n      );\n      /* If the bind operation is pending, the cancelled flag will trigger\n       * the unbind operation later. */\n      if (boundPortObject.completionPromise) {\n        boundPortObject.cancelled = true;\n      } else {\n        this.completeUnbind(boundPortObject);\n      }\n    }\n  }\n\n  /**\n   * Gracefully close all connections associated with a previously bound port.\n   * After the grace time, forcefully close all remaining open connections.\n   *\n   * If port 0 was bound, only the actual bound port can be\n   * drained. For example, if bindAsync was called with \"localhost:0\" and the\n   * bound port result was 54321, it can be drained as \"localhost:54321\".\n   * @param port\n   * @param graceTimeMs\n   * @returns\n   */\n  drain(port: string, graceTimeMs: number): void {\n    this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);\n    const portUri = this.normalizePort(port);\n    const splitPort = splitHostPort(portUri.path);\n    if (splitPort?.port === 0) {\n      throw new Error('Cannot drain port 0');\n    }\n    const boundPortObject = this.boundPorts.get(uriToString(portUri));\n    if (!boundPortObject) {\n      return;\n    }\n    const allSessions: Set<http2.Http2Session> = new Set();\n    for (const http2Server of boundPortObject.listeningServers) {\n      const serverEntry = this.http2Servers.get(http2Server);\n      if (serverEntry) {\n        for (const session of serverEntry.sessions) {\n          allSessions.add(session);\n          this.closeSession(session, () => {\n            allSessions.delete(session);\n          });\n        }\n      }\n    }\n    /* After the grace time ends, send another goaway to all remaining sessions\n     * with the CANCEL code. */\n    setTimeout(() => {\n      for (const session of allSessions) {\n        session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n      }\n    }, graceTimeMs).unref?.();\n  }\n\n  forceShutdown(): void {\n    for (const boundPortObject of this.boundPorts.values()) {\n      boundPortObject.cancelled = true;\n    }\n    this.boundPorts.clear();\n    // Close the server if it is still running.\n    for (const server of this.http2Servers.keys()) {\n      this.closeServer(server);\n    }\n\n    // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n    this.sessions.forEach((channelzInfo, session) => {\n      this.closeSession(session);\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n    });\n    this.sessions.clear();\n    unregisterChannelzRef(this.channelzRef);\n\n    this.shutdown = true;\n  }\n\n  register<RequestType, ResponseType>(\n    name: string,\n    handler: HandleCall<RequestType, ResponseType>,\n    serialize: Serialize<ResponseType>,\n    deserialize: Deserialize<RequestType>,\n    type: string\n  ): boolean {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name,\n    } as UntypedHandler);\n    return true;\n  }\n\n  unregister(name: string): boolean {\n    return this.handlers.delete(name);\n  }\n\n  /**\n   * @deprecated No longer needed as of version 1.10.x\n   */\n  @deprecate(\n    'Calling start() is no longer necessary. It can be safely omitted.'\n  )\n  start(): void {\n    if (\n      this.http2Servers.size === 0 ||\n      [...this.http2Servers.keys()].every(server => !server.listening)\n    ) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    this.started = true;\n  }\n\n  tryShutdown(callback: (error?: Error) => void): void {\n    const wrappedCallback = (error?: Error) => {\n      unregisterChannelzRef(this.channelzRef);\n      callback(error);\n    };\n    let pendingChecks = 0;\n\n    function maybeCallback(): void {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n    this.shutdown = true;\n\n    for (const [serverKey, server] of this.http2Servers.entries()) {\n      pendingChecks++;\n      const serverString = server.channelzRef.name;\n      this.trace('Waiting for server ' + serverString + ' to close');\n      this.closeServer(serverKey, () => {\n        this.trace('Server ' + serverString + ' finished closing');\n        maybeCallback();\n      });\n\n      for (const session of server.sessions.keys()) {\n        pendingChecks++;\n        const sessionString = session.socket?.remoteAddress;\n        this.trace('Waiting for session ' + sessionString + ' to close');\n        this.closeSession(session, () => {\n          this.trace('Session ' + sessionString + ' finished closing');\n          maybeCallback();\n        });\n      }\n    }\n\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n\n  addHttp2Port(): never {\n    throw new Error('Not yet implemented');\n  }\n\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  private _verifyContentType(\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ): boolean {\n    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n    if (\n      typeof contentType !== 'string' ||\n      !contentType.startsWith('application/grpc')\n    ) {\n      stream.respond(\n        {\n          [http2.constants.HTTP2_HEADER_STATUS]:\n            http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n        },\n        { endStream: true }\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  private _retrieveHandler(path: string): Handler<any, any> | null {\n    this.trace(\n      'Received call to method ' +\n        path +\n        ' at address ' +\n        this.serverAddressString\n    );\n\n    const handler = this.handlers.get(path);\n\n    if (handler === undefined) {\n      this.trace(\n        'No handler registered for method ' +\n          path +\n          '. Sending UNIMPLEMENTED status.'\n      );\n      return null;\n    }\n\n    return handler;\n  }\n\n  private _respondWithError(\n    err: PartialStatusObject,\n    stream: http2.ServerHttp2Stream,\n    channelzSessionInfo: ChannelzSessionInfo | null = null\n  ) {\n    const trailersToSend = {\n      'grpc-status': err.code ?? Status.INTERNAL,\n      'grpc-message': err.details,\n      [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n      [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n      ...err.metadata?.toHttp2Headers(),\n    };\n    stream.respond(trailersToSend, { endStream: true });\n\n    this.callTracker.addCallFailed();\n    channelzSessionInfo?.streamTracker.addCallFailed();\n  }\n\n  private _channelzHandler(\n    extraInterceptors: ServerInterceptor[],\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ) {\n    // for handling idle timeout\n    this.onStreamOpened(stream);\n\n    const channelzSessionInfo = this.sessions.get(\n      stream.session as http2.ServerHttp2Session\n    );\n\n    this.callTracker.addCallStarted();\n    channelzSessionInfo?.streamTracker.addCallStarted();\n\n    if (!this._verifyContentType(stream, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed();\n      return;\n    }\n\n    const path = headers[HTTP2_HEADER_PATH] as string;\n\n    const handler = this._retrieveHandler(path);\n    if (!handler) {\n      this._respondWithError(\n        getUnimplementedStatusResponse(path),\n        stream,\n        channelzSessionInfo\n      );\n      return;\n    }\n\n    const callEventTracker: CallEventTracker = {\n      addMessageSent: () => {\n        if (channelzSessionInfo) {\n          channelzSessionInfo.messagesSent += 1;\n          channelzSessionInfo.lastMessageSentTimestamp = new Date();\n        }\n      },\n      addMessageReceived: () => {\n        if (channelzSessionInfo) {\n          channelzSessionInfo.messagesReceived += 1;\n          channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n        }\n      },\n      onCallEnd: status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      },\n      onStreamEnd: success => {\n        if (channelzSessionInfo) {\n          if (success) {\n            channelzSessionInfo.streamTracker.addCallSucceeded();\n          } else {\n            channelzSessionInfo.streamTracker.addCallFailed();\n          }\n        }\n      },\n    };\n\n    const call = getServerInterceptingCall(\n      [...extraInterceptors, ...this.interceptors],\n      stream,\n      headers,\n      callEventTracker,\n      handler,\n      this.options\n    );\n\n    if (!this._runHandlerForCall(call, handler)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed();\n\n      call.sendStatus({\n        code: Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`,\n      });\n    }\n  }\n\n  private _streamHandler(\n    extraInterceptors: ServerInterceptor[],\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ) {\n    // for handling idle timeout\n    this.onStreamOpened(stream);\n\n    if (this._verifyContentType(stream, headers) !== true) {\n      return;\n    }\n\n    const path = headers[HTTP2_HEADER_PATH] as string;\n\n    const handler = this._retrieveHandler(path);\n    if (!handler) {\n      this._respondWithError(\n        getUnimplementedStatusResponse(path),\n        stream,\n        null\n      );\n      return;\n    }\n\n    const call = getServerInterceptingCall(\n      [...extraInterceptors, ...this.interceptors],\n      stream,\n      headers,\n      null,\n      handler,\n      this.options\n    );\n\n    if (!this._runHandlerForCall(call, handler)) {\n      call.sendStatus({\n        code: Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`,\n      });\n    }\n  }\n\n  private _runHandlerForCall(\n    call: ServerInterceptingCallInterface,\n    handler:\n      | UntypedUnaryHandler\n      | UntypedClientStreamingHandler\n      | UntypedServerStreamingHandler\n      | UntypedBidiStreamingHandler\n  ): boolean {\n    const { type } = handler;\n    if (type === 'unary') {\n      handleUnary(call, handler);\n    } else if (type === 'clientStream') {\n      handleClientStreaming(call, handler);\n    } else if (type === 'serverStream') {\n      handleServerStreaming(call, handler);\n    } else if (type === 'bidi') {\n      handleBidiStreaming(call, handler);\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _setupHandlers(\n    http2Server: http2.Http2Server | http2.Http2SecureServer,\n    extraInterceptors: ServerInterceptor[]\n  ): void {\n    if (http2Server === null) {\n      return;\n    }\n\n    const serverAddress = http2Server.address();\n    let serverAddressString = 'null';\n    if (serverAddress) {\n      if (typeof serverAddress === 'string') {\n        serverAddressString = serverAddress;\n      } else {\n        serverAddressString = serverAddress.address + ':' + serverAddress.port;\n      }\n    }\n    this.serverAddressString = serverAddressString;\n\n    const handler = this.channelzEnabled\n      ? this._channelzHandler\n      : this._streamHandler;\n\n    const sessionHandler = this.channelzEnabled\n      ? this._channelzSessionHandler(http2Server)\n      : this._sessionHandler(http2Server);\n\n    http2Server.on('stream', handler.bind(this, extraInterceptors));\n    http2Server.on('session', sessionHandler);\n  }\n\n  private _sessionHandler(\n    http2Server: http2.Http2Server | http2.Http2SecureServer\n  ) {\n    return (session: http2.ServerHttp2Session) => {\n      this.http2Servers.get(http2Server)?.sessions.add(session);\n\n      let connectionAgeTimer: NodeJS.Timeout | null = null;\n      let connectionAgeGraceTimer: NodeJS.Timeout | null = null;\n      let keepaliveTimer: NodeJS.Timeout | null = null;\n      let sessionClosedByServer = false;\n\n      const idleTimeoutObj = this.enableIdleTimeout(session);\n\n      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n        // Apply a random jitter within a +/-10% range\n        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n\n        connectionAgeTimer = setTimeout(() => {\n          sessionClosedByServer = true;\n\n          this.trace(\n            'Connection dropped by max connection age: ' +\n              session.socket?.remoteAddress\n          );\n\n          try {\n            session.goaway(\n              http2.constants.NGHTTP2_NO_ERROR,\n              ~(1 << 31),\n              kMaxAge\n            );\n          } catch (e) {\n            // The goaway can't be sent because the session is already closed\n            session.destroy();\n            return;\n          }\n          session.close();\n\n          /* Allow a grace period after sending the GOAWAY before forcibly\n           * closing the connection. */\n          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n            connectionAgeGraceTimer = setTimeout(() => {\n              session.destroy();\n            }, this.maxConnectionAgeGraceMs);\n            connectionAgeGraceTimer.unref?.();\n          }\n        }, this.maxConnectionAgeMs + jitter);\n        connectionAgeTimer.unref?.();\n      }\n\n      const clearKeepaliveTimeout = () => {\n        if (keepaliveTimer) {\n          clearTimeout(keepaliveTimer);\n          keepaliveTimer = null;\n        }\n      };\n\n      const canSendPing = () => {\n        return (\n          !session.destroyed &&\n          this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&\n          this.keepaliveTimeMs > 0\n        );\n      };\n\n      /* eslint-disable-next-line prefer-const */\n      let sendPing: () => void; // hoisted for use in maybeStartKeepalivePingTimer\n\n      const maybeStartKeepalivePingTimer = () => {\n        if (!canSendPing()) {\n          return;\n        }\n        this.keepaliveTrace(\n          'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'\n        );\n        keepaliveTimer = setTimeout(() => {\n          clearKeepaliveTimeout();\n          sendPing();\n        }, this.keepaliveTimeMs);\n        keepaliveTimer.unref?.();\n      };\n\n      sendPing = () => {\n        if (!canSendPing()) {\n          return;\n        }\n        this.keepaliveTrace(\n          'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'\n        );\n        let pingSendError = '';\n        try {\n          const pingSentSuccessfully = session.ping(\n            (err: Error | null, duration: number, payload: Buffer) => {\n              clearKeepaliveTimeout();\n              if (err) {\n                this.keepaliveTrace('Ping failed with error: ' + err.message);\n                sessionClosedByServer = true;\n                session.close();\n              } else {\n                this.keepaliveTrace('Received ping response');\n                maybeStartKeepalivePingTimer();\n              }\n            }\n          );\n          if (!pingSentSuccessfully) {\n            pingSendError = 'Ping returned false';\n          }\n        } catch (e) {\n          // grpc/grpc-node#2139\n          pingSendError =\n            (e instanceof Error ? e.message : '') || 'Unknown error';\n        }\n\n        if (pingSendError) {\n          this.keepaliveTrace('Ping send failed: ' + pingSendError);\n          this.trace(\n            'Connection dropped due to ping send error: ' + pingSendError\n          );\n          sessionClosedByServer = true;\n          session.close();\n          return;\n        }\n\n        keepaliveTimer = setTimeout(() => {\n          clearKeepaliveTimeout();\n          this.keepaliveTrace('Ping timeout passed without response');\n          this.trace('Connection dropped by keepalive timeout');\n          sessionClosedByServer = true;\n          session.close();\n        }, this.keepaliveTimeoutMs);\n        keepaliveTimer.unref?.();\n      };\n\n      maybeStartKeepalivePingTimer();\n\n      session.on('close', () => {\n        if (!sessionClosedByServer) {\n          this.trace(\n            `Connection dropped by client ${session.socket?.remoteAddress}`\n          );\n        }\n\n        if (connectionAgeTimer) {\n          clearTimeout(connectionAgeTimer);\n        }\n\n        if (connectionAgeGraceTimer) {\n          clearTimeout(connectionAgeGraceTimer);\n        }\n\n        clearKeepaliveTimeout();\n\n        if (idleTimeoutObj !== null) {\n          clearTimeout(idleTimeoutObj.timeout);\n          this.sessionIdleTimeouts.delete(session);\n        }\n\n        this.http2Servers.get(http2Server)?.sessions.delete(session);\n      });\n    };\n  }\n\n  private _channelzSessionHandler(\n    http2Server: http2.Http2Server | http2.Http2SecureServer\n  ) {\n    return (session: http2.ServerHttp2Session) => {\n      const channelzRef = registerChannelzSocket(\n        session.socket?.remoteAddress ?? 'unknown',\n        this.getChannelzSessionInfo.bind(this, session),\n        this.channelzEnabled\n      );\n\n      const channelzSessionInfo: ChannelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        keepAlivesSent: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null,\n      };\n\n      this.http2Servers.get(http2Server)?.sessions.add(session);\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;\n\n      this.channelzTrace.addTrace(\n        'CT_INFO',\n        'Connection established by client ' + clientAddress\n      );\n      this.trace('Connection established by client ' + clientAddress);\n      this.sessionChildrenTracker.refChild(channelzRef);\n\n      let connectionAgeTimer: NodeJS.Timeout | null = null;\n      let connectionAgeGraceTimer: NodeJS.Timeout | null = null;\n      let keepaliveTimeout: NodeJS.Timeout | null = null;\n      let sessionClosedByServer = false;\n\n      const idleTimeoutObj = this.enableIdleTimeout(session);\n\n      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n        // Apply a random jitter within a +/-10% range\n        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n\n        connectionAgeTimer = setTimeout(() => {\n          sessionClosedByServer = true;\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Connection dropped by max connection age from ' + clientAddress\n          );\n\n          try {\n            session.goaway(\n              http2.constants.NGHTTP2_NO_ERROR,\n              ~(1 << 31),\n              kMaxAge\n            );\n          } catch (e) {\n            // The goaway can't be sent because the session is already closed\n            session.destroy();\n            return;\n          }\n          session.close();\n\n          /* Allow a grace period after sending the GOAWAY before forcibly\n           * closing the connection. */\n          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n            connectionAgeGraceTimer = setTimeout(() => {\n              session.destroy();\n            }, this.maxConnectionAgeGraceMs);\n            connectionAgeGraceTimer.unref?.();\n          }\n        }, this.maxConnectionAgeMs + jitter);\n        connectionAgeTimer.unref?.();\n      }\n\n      const clearKeepaliveTimeout = () => {\n        if (keepaliveTimeout) {\n          clearTimeout(keepaliveTimeout);\n          keepaliveTimeout = null;\n        }\n      };\n\n      const canSendPing = () => {\n        return (\n          !session.destroyed &&\n          this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&\n          this.keepaliveTimeMs > 0\n        );\n      };\n\n      /* eslint-disable-next-line prefer-const */\n      let sendPing: () => void; // hoisted for use in maybeStartKeepalivePingTimer\n\n      const maybeStartKeepalivePingTimer = () => {\n        if (!canSendPing()) {\n          return;\n        }\n        this.keepaliveTrace(\n          'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'\n        );\n        keepaliveTimeout = setTimeout(() => {\n          clearKeepaliveTimeout();\n          sendPing();\n        }, this.keepaliveTimeMs);\n        keepaliveTimeout.unref?.();\n      };\n\n      sendPing = () => {\n        if (!canSendPing()) {\n          return;\n        }\n        this.keepaliveTrace(\n          'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'\n        );\n        let pingSendError = '';\n        try {\n          const pingSentSuccessfully = session.ping(\n            (err: Error | null, duration: number, payload: Buffer) => {\n              clearKeepaliveTimeout();\n              if (err) {\n                this.keepaliveTrace('Ping failed with error: ' + err.message);\n                this.channelzTrace.addTrace(\n                  'CT_INFO',\n                  'Connection dropped due to error of a ping frame ' +\n                    err.message +\n                    ' return in ' +\n                    duration\n                );\n                sessionClosedByServer = true;\n                session.close();\n              } else {\n                this.keepaliveTrace('Received ping response');\n                maybeStartKeepalivePingTimer();\n              }\n            }\n          );\n          if (!pingSentSuccessfully) {\n            pingSendError = 'Ping returned false';\n          }\n        } catch (e) {\n          // grpc/grpc-node#2139\n          pingSendError =\n            (e instanceof Error ? e.message : '') || 'Unknown error';\n        }\n\n        if (pingSendError) {\n          this.keepaliveTrace('Ping send failed: ' + pingSendError);\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Connection dropped due to ping send error: ' + pingSendError\n          );\n          sessionClosedByServer = true;\n          session.close();\n          return;\n        }\n\n        channelzSessionInfo.keepAlivesSent += 1;\n\n        keepaliveTimeout = setTimeout(() => {\n          clearKeepaliveTimeout();\n          this.keepaliveTrace('Ping timeout passed without response');\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Connection dropped by keepalive timeout from ' + clientAddress\n          );\n          sessionClosedByServer = true;\n          session.close();\n        }, this.keepaliveTimeoutMs);\n        keepaliveTimeout.unref?.();\n      };\n\n      maybeStartKeepalivePingTimer();\n\n      session.on('close', () => {\n        if (!sessionClosedByServer) {\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Connection dropped by client ' + clientAddress\n          );\n        }\n\n        this.sessionChildrenTracker.unrefChild(channelzRef);\n        unregisterChannelzRef(channelzRef);\n\n        if (connectionAgeTimer) {\n          clearTimeout(connectionAgeTimer);\n        }\n\n        if (connectionAgeGraceTimer) {\n          clearTimeout(connectionAgeGraceTimer);\n        }\n\n        clearKeepaliveTimeout();\n\n        if (idleTimeoutObj !== null) {\n          clearTimeout(idleTimeoutObj.timeout);\n          this.sessionIdleTimeouts.delete(session);\n        }\n\n        this.http2Servers.get(http2Server)?.sessions.delete(session);\n        this.sessions.delete(session);\n      });\n    };\n  }\n\n  private enableIdleTimeout(\n    session: http2.ServerHttp2Session\n  ): SessionIdleTimeoutTracker | null {\n    if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {\n      return null;\n    }\n\n    const idleTimeoutObj: SessionIdleTimeoutTracker = {\n      activeStreams: 0,\n      lastIdle: Date.now(),\n      onClose: this.onStreamClose.bind(this, session),\n      timeout: setTimeout(\n        this.onIdleTimeout,\n        this.sessionIdleTimeout,\n        this,\n        session\n      ),\n    };\n    idleTimeoutObj.timeout.unref?.();\n    this.sessionIdleTimeouts.set(session, idleTimeoutObj);\n\n    const { socket } = session;\n    this.trace(\n      'Enable idle timeout for ' +\n        socket.remoteAddress +\n        ':' +\n        socket.remotePort\n    );\n\n    return idleTimeoutObj;\n  }\n\n  private onIdleTimeout(\n    this: undefined,\n    ctx: Server,\n    session: http2.ServerHttp2Session\n  ) {\n    const { socket } = session;\n    const sessionInfo = ctx.sessionIdleTimeouts.get(session);\n\n    // if it is called while we have activeStreams - timer will not be rescheduled\n    // until last active stream is closed, then it will call .refresh() on the timer\n    // important part is to not clearTimeout(timer) or it becomes unusable\n    // for future refreshes\n    if (\n      sessionInfo !== undefined &&\n      sessionInfo.activeStreams === 0\n    ) {\n      if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {\n        ctx.trace(\n          'Session idle timeout triggered for ' +\n            socket?.remoteAddress +\n            ':' +\n            socket?.remotePort +\n            ' last idle at ' +\n            sessionInfo.lastIdle\n        );\n\n        ctx.closeSession(session);\n      } else {\n        sessionInfo.timeout.refresh();\n      }\n    }\n  }\n\n  private onStreamOpened(stream: http2.ServerHttp2Stream) {\n    const session = stream.session as http2.ServerHttp2Session;\n\n    const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n    if (idleTimeoutObj) {\n      idleTimeoutObj.activeStreams += 1;\n      stream.once('close', idleTimeoutObj.onClose);\n    }\n  }\n\n  private onStreamClose(session: http2.ServerHttp2Session) {\n    const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n\n    if (idleTimeoutObj) {\n      idleTimeoutObj.activeStreams -= 1;\n      if (idleTimeoutObj.activeStreams === 0) {\n        idleTimeoutObj.lastIdle = Date.now();\n        idleTimeoutObj.timeout.refresh();\n\n        this.trace(\n          'Session onStreamClose' +\n            session.socket?.remoteAddress +\n            ':' +\n            session.socket?.remotePort +\n            ' at ' +\n            idleTimeoutObj.lastIdle\n        );\n      }\n    }\n  }\n}\n\nasync function handleUnary<RequestType, ResponseType>(\n  call: ServerInterceptingCallInterface,\n  handler: UnaryHandler<RequestType, ResponseType>\n): Promise<void> {\n  let stream: ServerUnaryCall<RequestType, ResponseType>;\n\n  function respond(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    trailer?: Metadata,\n    flags?: number\n  ) {\n    if (err) {\n      call.sendStatus(serverErrorToStatus(err, trailer));\n      return;\n    }\n    call.sendMessage(value, () => {\n      call.sendStatus({\n        code: Status.OK,\n        details: 'OK',\n        metadata: trailer ?? null,\n      });\n    });\n  }\n\n  let requestMetadata: Metadata;\n  let requestMessage: RequestType | null = null;\n  call.start({\n    onReceiveMetadata(metadata) {\n      requestMetadata = metadata;\n      call.startRead();\n    },\n    onReceiveMessage(message) {\n      if (requestMessage) {\n        call.sendStatus({\n          code: Status.UNIMPLEMENTED,\n          details: `Received a second request message for server streaming method ${handler.path}`,\n          metadata: null,\n        });\n        return;\n      }\n      requestMessage = message;\n      call.startRead();\n    },\n    onReceiveHalfClose() {\n      if (!requestMessage) {\n        call.sendStatus({\n          code: Status.UNIMPLEMENTED,\n          details: `Received no request message for server streaming method ${handler.path}`,\n          metadata: null,\n        });\n        return;\n      }\n      stream = new ServerWritableStreamImpl(\n        handler.path,\n        call,\n        requestMetadata,\n        requestMessage\n      );\n      try {\n        handler.func(stream, respond);\n      } catch (err) {\n        call.sendStatus({\n          code: Status.UNKNOWN,\n          details: `Server method handler threw error ${\n            (err as Error).message\n          }`,\n          metadata: null,\n        });\n      }\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n      }\n    },\n  });\n}\n\nfunction handleClientStreaming<RequestType, ResponseType>(\n  call: ServerInterceptingCallInterface,\n  handler: ClientStreamingHandler<RequestType, ResponseType>\n): void {\n  let stream: ServerReadableStream<RequestType, ResponseType>;\n\n  function respond(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    trailer?: Metadata,\n    flags?: number\n  ) {\n    if (err) {\n      call.sendStatus(serverErrorToStatus(err, trailer));\n      return;\n    }\n    call.sendMessage(value, () => {\n      call.sendStatus({\n        code: Status.OK,\n        details: 'OK',\n        metadata: trailer ?? null,\n      });\n    });\n  }\n\n  call.start({\n    onReceiveMetadata(metadata) {\n      stream = new ServerDuplexStreamImpl(handler.path, call, metadata);\n      try {\n        handler.func(stream, respond);\n      } catch (err) {\n        call.sendStatus({\n          code: Status.UNKNOWN,\n          details: `Server method handler threw error ${\n            (err as Error).message\n          }`,\n          metadata: null,\n        });\n      }\n    },\n    onReceiveMessage(message) {\n      stream.push(message);\n    },\n    onReceiveHalfClose() {\n      stream.push(null);\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    },\n  });\n}\n\nfunction handleServerStreaming<RequestType, ResponseType>(\n  call: ServerInterceptingCallInterface,\n  handler: ServerStreamingHandler<RequestType, ResponseType>\n): void {\n  let stream: ServerWritableStream<RequestType, ResponseType>;\n\n  let requestMetadata: Metadata;\n  let requestMessage: RequestType | null = null;\n  call.start({\n    onReceiveMetadata(metadata) {\n      requestMetadata = metadata;\n      call.startRead();\n    },\n    onReceiveMessage(message) {\n      if (requestMessage) {\n        call.sendStatus({\n          code: Status.UNIMPLEMENTED,\n          details: `Received a second request message for server streaming method ${handler.path}`,\n          metadata: null,\n        });\n        return;\n      }\n      requestMessage = message;\n      call.startRead();\n    },\n    onReceiveHalfClose() {\n      if (!requestMessage) {\n        call.sendStatus({\n          code: Status.UNIMPLEMENTED,\n          details: `Received no request message for server streaming method ${handler.path}`,\n          metadata: null,\n        });\n        return;\n      }\n      stream = new ServerWritableStreamImpl(\n        handler.path,\n        call,\n        requestMetadata,\n        requestMessage\n      );\n      try {\n        handler.func(stream);\n      } catch (err) {\n        call.sendStatus({\n          code: Status.UNKNOWN,\n          details: `Server method handler threw error ${\n            (err as Error).message\n          }`,\n          metadata: null,\n        });\n      }\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    },\n  });\n}\n\nfunction handleBidiStreaming<RequestType, ResponseType>(\n  call: ServerInterceptingCallInterface,\n  handler: BidiStreamingHandler<RequestType, ResponseType>\n): void {\n  let stream: ServerDuplexStream<RequestType, ResponseType>;\n\n  call.start({\n    onReceiveMetadata(metadata) {\n      stream = new ServerDuplexStreamImpl(handler.path, call, metadata);\n      try {\n        handler.func(stream);\n      } catch (err) {\n        call.sendStatus({\n          code: Status.UNKNOWN,\n          details: `Server method handler threw error ${\n            (err as Error).message\n          }`,\n          metadata: null,\n        });\n      }\n    },\n    onReceiveMessage(message) {\n      stream.push(message);\n    },\n    onReceiveHalfClose() {\n      stream.push(null);\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    },\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}