{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst load_balancer_pick_first_1 = require(\"./load-balancer-pick-first\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  constructor() {}\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {}\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n}\nclass RoundRobinPicker {\n  constructor(children, nextIndex = 0) {\n    this.children = children;\n    this.nextIndex = nextIndex;\n  }\n  pick(pickArgs) {\n    const childPicker = this.children[this.nextIndex].picker;\n    this.nextIndex = (this.nextIndex + 1) % this.children.length;\n    return childPicker.pick(pickArgs);\n  }\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n  peekNextEndpoint() {\n    return this.children[this.nextIndex].endpoint;\n  }\n}\nclass RoundRobinLoadBalancer {\n  constructor(channelControlHelper, options) {\n    this.channelControlHelper = channelControlHelper;\n    this.options = options;\n    this.children = [];\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentReadyPicker = null;\n    this.updatesPaused = false;\n    this.lastError = null;\n    this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\n      updateState: (connectivityState, picker) => {\n        /* Ensure that name resolution is requested again after active\n         * connections are dropped. This is more aggressive than necessary to\n         * accomplish that, so we are counting on resolvers to have\n         * reasonable rate limits. */\n        if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {\n          this.channelControlHelper.requestReresolution();\n        }\n        this.calculateAndUpdateState();\n      }\n    });\n  }\n  countChildrenWithState(state) {\n    return this.children.filter(child => child.getConnectivityState() === state).length;\n  }\n  calculateAndUpdateState() {\n    if (this.updatesPaused) {\n      return;\n    }\n    if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\n      const readyChildren = this.children.filter(child => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n      let index = 0;\n      if (this.currentReadyPicker !== null) {\n        const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();\n        index = readyChildren.findIndex(child => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));\n        if (index < 0) {\n          index = 0;\n        }\n      }\n      this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map(child => ({\n        endpoint: child.getEndpoint(),\n        picker: child.getPicker()\n      })), index));\n    } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n        details: `No connection established. Last error: ${this.lastError}`\n      }));\n    } else {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    }\n    /* round_robin should keep all children connected, this is how we do that.\n     * We can't do this more efficiently in the individual child's updateState\n     * callback because that doesn't have a reference to which child the state\n     * change is associated with. */\n    for (const child of this.children) {\n      if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n        child.exitIdle();\n      }\n    }\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (newState === connectivity_state_1.ConnectivityState.READY) {\n      this.currentReadyPicker = picker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList() {\n    for (const child of this.children) {\n      child.destroy();\n    }\n  }\n  updateAddressList(endpointList, lbConfig) {\n    this.resetSubchannelList();\n    trace('Connect to endpoint list ' + endpointList.map(subchannel_address_1.endpointToString));\n    this.updatesPaused = true;\n    this.children = endpointList.map(endpoint => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, this.options));\n    for (const child of this.children) {\n      child.startConnecting();\n    }\n    this.updatesPaused = false;\n    this.calculateAndUpdateState();\n  }\n  exitIdle() {\n    /* The round_robin LB policy is only in the IDLE state if it has no\n     * addresses to try to connect to and it has no picked subchannel.\n     * In that case, there is no meaningful action that can be taken here. */\n  }\n  resetBackoff() {\n    // This LB policy has no backoff to reset\n  }\n  destroy() {\n    this.resetSubchannelList();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n  (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup;","map":{"version":3,"names":["load_balancer_1","require","connectivity_state_1","picker_1","logging","constants_1","subchannel_address_1","load_balancer_pick_first_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","RoundRobinLoadBalancingConfig","getLoadBalancerName","constructor","toJsonObject","createFromJson","obj","RoundRobinPicker","children","nextIndex","pick","pickArgs","childPicker","picker","length","peekNextEndpoint","endpoint","RoundRobinLoadBalancer","channelControlHelper","options","currentState","ConnectivityState","IDLE","currentReadyPicker","updatesPaused","lastError","childChannelControlHelper","createChildChannelControlHelper","updateState","connectivityState","READY","requestReresolution","calculateAndUpdateState","countChildrenWithState","state","filter","child","getConnectivityState","readyChildren","index","nextPickedEndpoint","findIndex","endpointEqual","getEndpoint","map","getPicker","CONNECTING","QueuePicker","TRANSIENT_FAILURE","UnavailablePicker","details","exitIdle","newState","resetSubchannelList","destroy","updateAddressList","endpointList","lbConfig","endpointToString","LeafLoadBalancer","startConnecting","resetBackoff","getTypeName","exports","setup","registerLoadBalancerType"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/load-balancer-round-robin.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  TypedLoadBalancingConfig,\n  registerLoadBalancerType,\n  createChildChannelControlHelper,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  UnavailablePicker,\n  PickResult,\n} from './picker';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport {\n  Endpoint,\n  endpointEqual,\n  endpointToString,\n} from './subchannel-address';\nimport { LeafLoadBalancer } from './load-balancer-pick-first';\nimport { ChannelOptions } from './channel-options';\n\nconst TRACER_NAME = 'round_robin';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'round_robin';\n\nclass RoundRobinLoadBalancingConfig implements TypedLoadBalancingConfig {\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  constructor() {}\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {},\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n}\n\nclass RoundRobinPicker implements Picker {\n  constructor(\n    private readonly children: { endpoint: Endpoint; picker: Picker }[],\n    private nextIndex = 0\n  ) {}\n\n  pick(pickArgs: PickArgs): PickResult {\n    const childPicker = this.children[this.nextIndex].picker;\n    this.nextIndex = (this.nextIndex + 1) % this.children.length;\n    return childPicker.pick(pickArgs);\n  }\n\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n  peekNextEndpoint(): Endpoint {\n    return this.children[this.nextIndex].endpoint;\n  }\n}\n\nexport class RoundRobinLoadBalancer implements LoadBalancer {\n  private children: LeafLoadBalancer[] = [];\n\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n\n  private currentReadyPicker: RoundRobinPicker | null = null;\n\n  private updatesPaused = false;\n\n  private childChannelControlHelper: ChannelControlHelper;\n\n  private lastError: string | null = null;\n\n  constructor(\n    private readonly channelControlHelper: ChannelControlHelper,\n    private readonly options: ChannelOptions\n  ) {\n    this.childChannelControlHelper = createChildChannelControlHelper(\n      channelControlHelper,\n      {\n        updateState: (connectivityState, picker) => {\n          /* Ensure that name resolution is requested again after active\n           * connections are dropped. This is more aggressive than necessary to\n           * accomplish that, so we are counting on resolvers to have\n           * reasonable rate limits. */\n          if (this.currentState === ConnectivityState.READY && connectivityState !== ConnectivityState.READY) {\n            this.channelControlHelper.requestReresolution();\n          }\n          this.calculateAndUpdateState();\n        },\n      }\n    );\n  }\n\n  private countChildrenWithState(state: ConnectivityState) {\n    return this.children.filter(child => child.getConnectivityState() === state)\n      .length;\n  }\n\n  private calculateAndUpdateState() {\n    if (this.updatesPaused) {\n      return;\n    }\n    if (this.countChildrenWithState(ConnectivityState.READY) > 0) {\n      const readyChildren = this.children.filter(\n        child => child.getConnectivityState() === ConnectivityState.READY\n      );\n      let index = 0;\n      if (this.currentReadyPicker !== null) {\n        const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();\n        index = readyChildren.findIndex(child =>\n          endpointEqual(child.getEndpoint(), nextPickedEndpoint)\n        );\n        if (index < 0) {\n          index = 0;\n        }\n      }\n      this.updateState(\n        ConnectivityState.READY,\n        new RoundRobinPicker(\n          readyChildren.map(child => ({\n            endpoint: child.getEndpoint(),\n            picker: child.getPicker(),\n          })),\n          index\n        )\n      );\n    } else if (this.countChildrenWithState(ConnectivityState.CONNECTING) > 0) {\n      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n    } else if (\n      this.countChildrenWithState(ConnectivityState.TRANSIENT_FAILURE) > 0\n    ) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker({\n          details: `No connection established. Last error: ${this.lastError}`,\n        })\n      );\n    } else {\n      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    }\n    /* round_robin should keep all children connected, this is how we do that.\n     * We can't do this more efficiently in the individual child's updateState\n     * callback because that doesn't have a reference to which child the state\n     * change is associated with. */\n    for (const child of this.children) {\n      if (child.getConnectivityState() === ConnectivityState.IDLE) {\n        child.exitIdle();\n      }\n    }\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (newState === ConnectivityState.READY) {\n      this.currentReadyPicker = picker as RoundRobinPicker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList() {\n    for (const child of this.children) {\n      child.destroy();\n    }\n  }\n\n  updateAddressList(\n    endpointList: Endpoint[],\n    lbConfig: TypedLoadBalancingConfig\n  ): void {\n    this.resetSubchannelList();\n    trace('Connect to endpoint list ' + endpointList.map(endpointToString));\n    this.updatesPaused = true;\n    this.children = endpointList.map(\n      endpoint =>\n        new LeafLoadBalancer(\n          endpoint,\n          this.childChannelControlHelper,\n          this.options\n        )\n    );\n    for (const child of this.children) {\n      child.startConnecting();\n    }\n    this.updatesPaused = false;\n    this.calculateAndUpdateState();\n  }\n\n  exitIdle(): void {\n    /* The round_robin LB policy is only in the IDLE state if it has no\n     * addresses to try to connect to and it has no picked subchannel.\n     * In that case, there is no meaningful action that can be taken here. */\n  }\n  resetBackoff(): void {\n    // This LB policy has no backoff to reset\n  }\n  destroy(): void {\n    this.resetSubchannelList();\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup() {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    RoundRobinLoadBalancer,\n    RoundRobinLoadBalancingConfig\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}