{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelCall = void 0;\nconst http2 = require(\"http2\");\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'subchannel_call';\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\nfunction mapHttpStatusCode(code) {\n  const details = `Received HTTP status code ${code}`;\n  let mappedStatusCode;\n  switch (code) {\n    // TODO(murgatroid99): handle 100 and 101\n    case 400:\n      mappedStatusCode = constants_1.Status.INTERNAL;\n      break;\n    case 401:\n      mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n      break;\n    case 403:\n      mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n      break;\n    case 404:\n      mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n      break;\n    case 429:\n    case 502:\n    case 503:\n    case 504:\n      mappedStatusCode = constants_1.Status.UNAVAILABLE;\n      break;\n    default:\n      mappedStatusCode = constants_1.Status.UNKNOWN;\n  }\n  return {\n    code: mappedStatusCode,\n    details: details,\n    metadata: new metadata_1.Metadata()\n  };\n}\nclass Http2SubchannelCall {\n  constructor(http2Stream, callEventTracker, listener, transport, callId) {\n    var _a;\n    this.http2Stream = http2Stream;\n    this.callEventTracker = callEventTracker;\n    this.listener = listener;\n    this.transport = transport;\n    this.callId = callId;\n    this.isReadFilterPending = false;\n    this.isPushPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    // This is populated (non-null) if and only if the call has ended\n    this.finalStatus = null;\n    this.internalError = null;\n    this.serverEndedCall = false;\n    const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      this.httpStatusCode = headers[':status'];\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata;\n        try {\n          metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNKNOWN,\n            details: error.message,\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', headers => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', data => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      let messages;\n      try {\n        messages = this.decoder.write(data);\n      } catch (e) {\n        this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);\n        return;\n      }\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callEventTracker.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      this.serverEndedCall = true;\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        var _a;\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n          return;\n        }\n        let code;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            if (this.httpStatusCode && this.httpStatusCode !== 200) {\n              const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\n              code = mappedStatus.code;\n              details = mappedStatus.details;\n            } else {\n              code = constants_1.Status.INTERNAL;\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;\n            }\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = constants_1.Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = constants_1.Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = constants_1.Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = constants_1.Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = constants_1.Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                code = constants_1.Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = constants_1.Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({\n          code,\n          details,\n          metadata: new metadata_1.Metadata(),\n          rstCode: http2Stream.rstCode\n        });\n      });\n    });\n    http2Stream.on('error', err => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n        this.internalError = err;\n      }\n      this.callEventTracker.onStreamEnd(false);\n    });\n  }\n  getDeadlineInfo() {\n    return [`remote_addr=${this.getPeer()}`];\n  }\n  onDisconnect() {\n    this.endCall({\n      code: constants_1.Status.UNAVAILABLE,\n      details: 'Connection dropped',\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace('ended with status: code=' + this.finalStatus.code + ' details=\"' + this.finalStatus.details + '\"');\n      this.callEventTracker.onCallEnd(this.finalStatus);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n    }\n  }\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  endCall(status) {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n  maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {\n        this.outputStatus();\n      }\n    }\n  }\n  push(message) {\n    this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n    this.canPush = false;\n    this.isPushPending = true;\n    process.nextTick(() => {\n      this.isPushPending = false;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n  tryPush(messageBytes) {\n    if (this.canPush) {\n      this.http2Stream.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n  handleTrailers(headers) {\n    this.serverEndedCall = true;\n    this.callEventTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata;\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let status;\n    if (typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      this.trace('received status code ' + receivedStatus + ' from server');\n      metadata.remove('grpc-status');\n      let details = '';\n      if (typeof metadataMap['grpc-message'] === 'string') {\n        try {\n          details = decodeURI(metadataMap['grpc-message']);\n        } catch (e) {\n          details = metadataMap['grpc-message'];\n        }\n        metadata.remove('grpc-message');\n        this.trace('received status details string \"' + details + '\" from server');\n      }\n      status = {\n        code: receivedStatus,\n        details: details,\n        metadata: metadata\n      };\n    } else if (this.httpStatusCode) {\n      status = mapHttpStatusCode(this.httpStatusCode);\n      status.metadata = metadata;\n    } else {\n      status = {\n        code: constants_1.Status.UNKNOWN,\n        details: 'No status information received',\n        metadata: metadata\n      };\n    }\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n  destroyHttp2Stream() {\n    var _a;\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (this.http2Stream.destroyed) {\n      return;\n    }\n    /* If the server ended the call, sending an RST_STREAM is redundant, so we\n     * just half close on the client side instead to finish closing the stream.\n     */\n    if (this.serverEndedCall) {\n      this.http2Stream.end();\n    } else {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code;\n      if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.endCall({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  getStatus() {\n    return this.finalStatus;\n  }\n  getPeer() {\n    return this.transport.getPeerName();\n  }\n  getCallNumber() {\n    return this.callId;\n  }\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage = this.unpushedReadMessages.shift();\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n     * messages to emit */\n    this.http2Stream.resume();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb = error => {\n      /* nextTick here ensures that no stream action can be taken in the call\n       * stack of the write callback, in order to hopefully work around\n       * https://github.com/nodejs/node/issues/49147 */\n      process.nextTick(() => {\n        var _a;\n        let code = constants_1.Status.UNAVAILABLE;\n        if ((error === null || error === void 0 ? void 0 : error.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n          code = constants_1.Status.INTERNAL;\n        }\n        if (error) {\n          this.cancelWithStatus(code, `Write error: ${error.message}`);\n        }\n        (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n      });\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callEventTracker.addMessageSent();\n    try {\n      this.http2Stream.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: `Write failed with error ${error.message}`,\n        metadata: new metadata_1.Metadata()\n      });\n    }\n  }\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall;","map":{"version":3,"names":["http2","require","os","constants_1","metadata_1","stream_decoder_1","logging","constants_2","TRACER_NAME","getSystemErrorName","errno","name","num","Object","entries","constants","mapHttpStatusCode","code","details","mappedStatusCode","Status","INTERNAL","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","UNAVAILABLE","UNKNOWN","metadata","Metadata","Http2SubchannelCall","constructor","http2Stream","callEventTracker","listener","transport","callId","isReadFilterPending","isPushPending","canPush","readsClosed","statusOutput","unpushedReadMessages","finalStatus","internalError","serverEndedCall","maxReceiveMessageLength","_a","getOptions","DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH","decoder","StreamDecoder","on","headers","flags","headersString","header","keys","trace","httpStatusCode","NGHTTP2_FLAG_END_STREAM","handleTrailers","fromHttp2Headers","error","endCall","message","onReceiveMetadata","data","length","messages","write","e","cancelWithStatus","RESOURCE_EXHAUSTED","addMessageReceived","tryPush","maybeOutputStatus","process","nextTick","rstCode","OK","NGHTTP2_NO_ERROR","mappedStatus","NGHTTP2_REFUSED_STREAM","NGHTTP2_CANCEL","CANCELLED","NGHTTP2_ENHANCE_YOUR_CALM","NGHTTP2_INADEQUATE_SECURITY","NGHTTP2_INTERNAL_ERROR","err","syscall","onStreamEnd","getDeadlineInfo","getPeer","onDisconnect","outputStatus","onCallEnd","onReceiveStatus","resume","text","LogVerbosity","DEBUG","status","destroyHttp2Stream","push","Buffer","onReceiveMessage","messageBytes","pause","metadataMap","getMap","receivedStatus","Number","remove","decodeURI","destroyed","end","close","getStatus","getPeerName","getCallNumber","startRead","nextMessage","shift","sendMessageWithContext","context","cb","callback","call","addMessageSent","halfClose","exports"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/subchannel-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport * as os from 'os';\n\nimport { DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH, Status } from './constants';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport {\n  InterceptingListener,\n  MessageContext,\n  StatusObject,\n  WriteCallback,\n} from './call-interface';\nimport { CallEventTracker, Transport } from './transport';\n\nconst TRACER_NAME = 'subchannel_call';\n\n/**\n * https://nodejs.org/api/errors.html#errors_class_systemerror\n */\ninterface SystemError extends Error {\n  address?: string;\n  code: string;\n  dest?: string;\n  errno: number;\n  info?: object;\n  message: string;\n  path?: string;\n  port?: number;\n  syscall: string;\n}\n\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno: number): string {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\n\nexport interface SubchannelCall {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  sendMessageWithContext(context: MessageContext, message: Buffer): void;\n  startRead(): void;\n  halfClose(): void;\n  getCallNumber(): number;\n  getDeadlineInfo(): string[];\n}\n\nexport interface StatusObjectWithRstCode extends StatusObject {\n  rstCode?: number;\n}\n\nexport interface SubchannelCallInterceptingListener\n  extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithRstCode): void;\n}\n\nfunction mapHttpStatusCode(code: number): StatusObject {\n  const details = `Received HTTP status code ${code}`;\n  let mappedStatusCode: number;\n  switch (code) {\n    // TODO(murgatroid99): handle 100 and 101\n    case 400:\n      mappedStatusCode = Status.INTERNAL;\n      break;\n    case 401:\n      mappedStatusCode = Status.UNAUTHENTICATED;\n      break;\n    case 403:\n      mappedStatusCode = Status.PERMISSION_DENIED;\n      break;\n    case 404:\n      mappedStatusCode = Status.UNIMPLEMENTED;\n      break;\n    case 429:\n    case 502:\n    case 503:\n    case 504:\n      mappedStatusCode = Status.UNAVAILABLE;\n      break;\n    default:\n      mappedStatusCode = Status.UNKNOWN;\n  }\n  return {\n    code: mappedStatusCode,\n    details: details,\n    metadata: new Metadata()\n  };\n}\n\nexport class Http2SubchannelCall implements SubchannelCall {\n  private decoder: StreamDecoder;\n\n  private isReadFilterPending = false;\n  private isPushPending = false;\n  private canPush = false;\n  /**\n   * Indicates that an 'end' event has come from the http2 stream, so there\n   * will be no more data events.\n   */\n  private readsClosed = false;\n\n  private statusOutput = false;\n\n  private unpushedReadMessages: Buffer[] = [];\n\n  private httpStatusCode: number | undefined;\n\n  // This is populated (non-null) if and only if the call has ended\n  private finalStatus: StatusObject | null = null;\n\n  private internalError: SystemError | null = null;\n\n  private serverEndedCall = false;\n\n  constructor(\n    private readonly http2Stream: http2.ClientHttp2Stream,\n    private readonly callEventTracker: CallEventTracker,\n    private readonly listener: SubchannelCallInterceptingListener,\n    private readonly transport: Transport,\n    private readonly callId: number\n  ) {\n    const maxReceiveMessageLength = transport.getOptions()['grpc.max_receive_message_length'] ?? DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.decoder = new StreamDecoder(maxReceiveMessageLength);\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      this.httpStatusCode = headers[':status'];\n\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata: Metadata;\n        try {\n          metadata = Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: Status.UNKNOWN,\n            details: (error as Error).message,\n            metadata: new Metadata(),\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', (headers: http2.IncomingHttpHeaders) => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', (data: Buffer) => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      let messages: Buffer[];\n      try {\n        messages = this.decoder.write(data);\n      } catch (e) {\n        this.cancelWithStatus(Status.RESOURCE_EXHAUSTED, (e as Error).message);\n        return;\n      }\n\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callEventTracker!.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      this.serverEndedCall = true;\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (this.finalStatus?.code === Status.OK) {\n          return;\n        }\n        let code: Status;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            if (this.httpStatusCode && this.httpStatusCode !== 200) {\n              const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\n              code = mappedStatus.code;\n              details = mappedStatus.details;\n            } else {\n              code = Status.INTERNAL;\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;\n            }\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (\n                this.internalError.code === 'ECONNRESET' ||\n                this.internalError.code === 'ETIMEDOUT'\n              ) {\n                code = Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({\n          code,\n          details,\n          metadata: new Metadata(),\n          rstCode: http2Stream.rstCode,\n        });\n      });\n    });\n    http2Stream.on('error', (err: SystemError) => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace(\n          'Node error event: message=' +\n            err.message +\n            ' code=' +\n            err.code +\n            ' errno=' +\n            getSystemErrorName(err.errno) +\n            ' syscall=' +\n            err.syscall\n        );\n        this.internalError = err;\n      }\n      this.callEventTracker.onStreamEnd(false);\n    });\n  }\n  getDeadlineInfo(): string[] {\n    return [`remote_addr=${this.getPeer()}`];\n  }\n\n  public onDisconnect() {\n    this.endCall({\n      code: Status.UNAVAILABLE,\n      details: 'Connection dropped',\n      metadata: new Metadata(),\n    });\n  }\n\n  private outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace(\n        'ended with status: code=' +\n          this.finalStatus!.code +\n          ' details=\"' +\n          this.finalStatus!.details +\n          '\"'\n      );\n      this.callEventTracker.onCallEnd(this.finalStatus!);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus!);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n    }\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callId + '] ' + text\n    );\n  }\n\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  private endCall(status: StatusObjectWithRstCode): void {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n\n  private maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (\n        this.finalStatus.code !== Status.OK ||\n        (this.readsClosed &&\n          this.unpushedReadMessages.length === 0 &&\n          !this.isReadFilterPending &&\n          !this.isPushPending)\n      ) {\n        this.outputStatus();\n      }\n    }\n  }\n\n  private push(message: Buffer): void {\n    this.trace(\n      'pushing to reader message of length ' +\n        (message instanceof Buffer ? message.length : null)\n    );\n    this.canPush = false;\n    this.isPushPending = true;\n    process.nextTick(() => {\n      this.isPushPending = false;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n\n  private tryPush(messageBytes: Buffer): void {\n    if (this.canPush) {\n      this.http2Stream!.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace(\n        'unpushedReadMessages.push message of length ' + messageBytes.length\n      );\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n\n  private handleTrailers(headers: http2.IncomingHttpHeaders) {\n    this.serverEndedCall = true;\n    this.callEventTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata: Metadata;\n    try {\n      metadata = Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let status: StatusObject;\n    if (typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus: Status = Number(metadataMap['grpc-status']);\n      this.trace('received status code ' + receivedStatus + ' from server');\n      metadata.remove('grpc-status');\n      let details = '';\n      if (typeof metadataMap['grpc-message'] === 'string') {\n        try {\n          details = decodeURI(metadataMap['grpc-message']);\n        } catch (e) {\n          details = metadataMap['grpc-message'];\n        }\n        metadata.remove('grpc-message');\n        this.trace(\n          'received status details string \"' + details + '\" from server'\n        );\n      }\n      status = {\n        code: receivedStatus,\n        details: details,\n        metadata: metadata\n      };\n    } else if (this.httpStatusCode) {\n      status = mapHttpStatusCode(this.httpStatusCode);\n      status.metadata = metadata;\n    } else {\n      status = {\n        code: Status.UNKNOWN,\n        details: 'No status information received',\n        metadata: metadata\n      };\n    }\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n\n  private destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (this.http2Stream.destroyed) {\n      return;\n    }\n    /* If the server ended the call, sending an RST_STREAM is redundant, so we\n     * just half close on the client side instead to finish closing the stream.\n     */\n    if (this.serverEndedCall) {\n      this.http2Stream.end();\n    } else {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code: number;\n      if (this.finalStatus?.code === Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.endCall({ code: status, details, metadata: new Metadata() });\n  }\n\n  getStatus(): StatusObject | null {\n    return this.finalStatus;\n  }\n\n  getPeer(): string {\n    return this.transport.getPeerName();\n  }\n\n  getCallNumber(): number {\n    return this.callId;\n  }\n\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage: Buffer = this.unpushedReadMessages.shift()!;\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n     * messages to emit */\n    this.http2Stream.resume();\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb: WriteCallback = (error?: Error | null) => {\n      /* nextTick here ensures that no stream action can be taken in the call\n       * stack of the write callback, in order to hopefully work around\n       * https://github.com/nodejs/node/issues/49147 */\n      process.nextTick(() => {\n        let code: Status = Status.UNAVAILABLE;\n        if (\n          (error as NodeJS.ErrnoException)?.code ===\n          'ERR_STREAM_WRITE_AFTER_END'\n        ) {\n          code = Status.INTERNAL;\n        }\n        if (error) {\n          this.cancelWithStatus(code, `Write error: ${error.message}`);\n        }\n        context.callback?.();\n      });\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callEventTracker.addMessageSent();\n    try {\n      this.http2Stream!.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: Status.UNAVAILABLE,\n        details: `Write failed with error ${(error as Error).message}`,\n        metadata: new Metadata(),\n      });\n    }\n  }\n\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}