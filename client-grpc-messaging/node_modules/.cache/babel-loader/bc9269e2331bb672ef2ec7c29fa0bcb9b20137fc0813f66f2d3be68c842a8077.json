{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTrackerStub = exports.ChannelzCallTracker = exports.ChannelzChildrenTrackerStub = exports.ChannelzChildrenTracker = exports.ChannelzTrace = exports.ChannelzTraceStub = void 0;\nconst net_1 = require(\"net\");\nconst ordered_map_1 = require(\"@js-sdsl/ordered-map\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst admin_1 = require(\"./admin\");\nconst make_client_1 = require(\"./make-client\");\nfunction channelRefToMessage(ref) {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\nfunction subchannelRefToMessage(ref) {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  };\n}\nfunction serverRefToMessage(ref) {\n  return {\n    server_id: ref.id\n  };\n}\nfunction socketRefToMessage(ref) {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\n/**\n * Default number of sockets/servers/channels/subchannels to return\n */\nconst DEFAULT_MAX_RESULTS = 100;\nclass ChannelzTraceStub {\n  constructor() {\n    this.events = [];\n    this.creationTimestamp = new Date();\n    this.eventsLogged = 0;\n  }\n  addTrace() {}\n  getTraceMessage() {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: []\n    };\n  }\n}\nexports.ChannelzTraceStub = ChannelzTraceStub;\nclass ChannelzTrace {\n  constructor() {\n    this.events = [];\n    this.eventsLogged = 0;\n    this.creationTimestamp = new Date();\n  }\n  addTrace(severity, description, child) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n      childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n  getTraceMessage() {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        };\n      })\n    };\n  }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n  constructor() {\n    this.channelChildren = new ordered_map_1.OrderedMap();\n    this.subchannelChildren = new ordered_map_1.OrderedMap();\n    this.socketChildren = new ordered_map_1.OrderedMap();\n    this.trackerMap = {\n      [\"channel\" /* EntityTypes.channel */]: this.channelChildren,\n      [\"subchannel\" /* EntityTypes.subchannel */]: this.subchannelChildren,\n      [\"socket\" /* EntityTypes.socket */]: this.socketChildren\n    };\n  }\n  refChild(child) {\n    const tracker = this.trackerMap[child.kind];\n    const trackedChild = tracker.find(child.id);\n    if (trackedChild.equals(tracker.end())) {\n      tracker.setElement(child.id, {\n        ref: child,\n        count: 1\n      }, trackedChild);\n    } else {\n      trackedChild.pointer[1].count += 1;\n    }\n  }\n  unrefChild(child) {\n    const tracker = this.trackerMap[child.kind];\n    const trackedChild = tracker.getElementByKey(child.id);\n    if (trackedChild !== undefined) {\n      trackedChild.count -= 1;\n      if (trackedChild.count === 0) {\n        tracker.eraseElementByKey(child.id);\n      }\n    }\n  }\n  getChildLists() {\n    return {\n      channels: this.channelChildren,\n      subchannels: this.subchannelChildren,\n      sockets: this.socketChildren\n    };\n  }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {\n  refChild() {}\n  unrefChild() {}\n}\nexports.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;\nclass ChannelzCallTracker {\n  constructor() {\n    this.callsStarted = 0;\n    this.callsSucceeded = 0;\n    this.callsFailed = 0;\n    this.lastCallStartedTimestamp = null;\n  }\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nclass ChannelzCallTrackerStub extends ChannelzCallTracker {\n  addCallStarted() {}\n  addCallSucceeded() {}\n  addCallFailed() {}\n}\nexports.ChannelzCallTrackerStub = ChannelzCallTrackerStub;\nconst entityMaps = {\n  [\"channel\" /* EntityTypes.channel */]: new ordered_map_1.OrderedMap(),\n  [\"subchannel\" /* EntityTypes.subchannel */]: new ordered_map_1.OrderedMap(),\n  [\"server\" /* EntityTypes.server */]: new ordered_map_1.OrderedMap(),\n  [\"socket\" /* EntityTypes.socket */]: new ordered_map_1.OrderedMap()\n};\nconst generateRegisterFn = kind => {\n  let nextId = 1;\n  function getNextId() {\n    return nextId++;\n  }\n  const entityMap = entityMaps[kind];\n  return (name, getInfo, channelzEnabled) => {\n    const id = getNextId();\n    const ref = {\n      id,\n      name,\n      kind\n    };\n    if (channelzEnabled) {\n      entityMap.setElement(id, {\n        ref,\n        getInfo\n      });\n    }\n    return ref;\n  };\n};\nexports.registerChannelzChannel = generateRegisterFn(\"channel\" /* EntityTypes.channel */);\nexports.registerChannelzSubchannel = generateRegisterFn(\"subchannel\" /* EntityTypes.subchannel */);\nexports.registerChannelzServer = generateRegisterFn(\"server\" /* EntityTypes.server */);\nexports.registerChannelzSocket = generateRegisterFn(\"socket\" /* EntityTypes.socket */);\nfunction unregisterChannelzRef(ref) {\n  entityMaps[ref.kind].eraseElementByKey(ref.id);\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result = [];\n  return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n  if ((0, net_1.isIPv4)(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if ((0, net_1.isIPv6)(ipAddress)) {\n    let leftSection;\n    let rightSection;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\nfunction connectivityStateToMessage(state) {\n  switch (state) {\n    case connectivity_state_1.ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n    case connectivity_state_1.ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n    case connectivity_state_1.ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n    case connectivity_state_1.ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n    case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\nfunction dateToProtoTimestamp(date) {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: millisSinceEpoch / 1000 | 0,\n    nanos: millisSinceEpoch % 1000 * 1000000\n  };\n}\nfunction getChannelMessage(channelEntry) {\n  const resolvedInfo = channelEntry.getInfo();\n  const channelRef = [];\n  const subchannelRef = [];\n  resolvedInfo.children.channels.forEach(el => {\n    channelRef.push(channelRefToMessage(el[1].ref));\n  });\n  resolvedInfo.children.subchannels.forEach(el => {\n    subchannelRef.push(subchannelRefToMessage(el[1].ref));\n  });\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: channelRef,\n    subchannel_ref: subchannelRef\n  };\n}\nfunction GetChannel(call, callback) {\n  const channelId = parseInt(call.request.channel_id, 10);\n  const channelEntry = entityMaps[\"channel\" /* EntityTypes.channel */].getElementByKey(channelId);\n  if (channelEntry === undefined) {\n    callback({\n      code: constants_1.Status.NOT_FOUND,\n      details: 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n  callback(null, {\n    channel: getChannelMessage(channelEntry)\n  });\n}\nfunction GetTopChannels(call, callback) {\n  const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n  const resultList = [];\n  const startId = parseInt(call.request.start_channel_id, 10);\n  const channelEntries = entityMaps[\"channel\" /* EntityTypes.channel */];\n  let i;\n  for (i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {\n    resultList.push(getChannelMessage(i.pointer[1]));\n  }\n  callback(null, {\n    channel: resultList,\n    end: i.equals(channelEntries.end())\n  });\n}\nfunction getServerMessage(serverEntry) {\n  const resolvedInfo = serverEntry.getInfo();\n  const listenSocket = [];\n  resolvedInfo.listenerChildren.sockets.forEach(el => {\n    listenSocket.push(socketRefToMessage(el[1].ref));\n  });\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: listenSocket\n  };\n}\nfunction GetServer(call, callback) {\n  const serverId = parseInt(call.request.server_id, 10);\n  const serverEntries = entityMaps[\"server\" /* EntityTypes.server */];\n  const serverEntry = serverEntries.getElementByKey(serverId);\n  if (serverEntry === undefined) {\n    callback({\n      code: constants_1.Status.NOT_FOUND,\n      details: 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  callback(null, {\n    server: getServerMessage(serverEntry)\n  });\n}\nfunction GetServers(call, callback) {\n  const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n  const startId = parseInt(call.request.start_server_id, 10);\n  const serverEntries = entityMaps[\"server\" /* EntityTypes.server */];\n  const resultList = [];\n  let i;\n  for (i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {\n    resultList.push(getServerMessage(i.pointer[1]));\n  }\n  callback(null, {\n    server: resultList,\n    end: i.equals(serverEntries.end())\n  });\n}\nfunction GetSubchannel(call, callback) {\n  const subchannelId = parseInt(call.request.subchannel_id, 10);\n  const subchannelEntry = entityMaps[\"subchannel\" /* EntityTypes.subchannel */].getElementByKey(subchannelId);\n  if (subchannelEntry === undefined) {\n    callback({\n      code: constants_1.Status.NOT_FOUND,\n      details: 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const listenSocket = [];\n  resolvedInfo.children.sockets.forEach(el => {\n    listenSocket.push(socketRefToMessage(el[1].ref));\n  });\n  const subchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: listenSocket\n  };\n  callback(null, {\n    subchannel: subchannelMessage\n  });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n  var _a;\n  if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\nfunction GetSocket(call, callback) {\n  var _a, _b, _c, _d, _e;\n  const socketId = parseInt(call.request.socket_id, 10);\n  const socketEntry = entityMaps[\"socket\" /* EntityTypes.socket */].getElementByKey(socketId);\n  if (socketEntry === undefined) {\n    callback({\n      code: constants_1.Status.NOT_FOUND,\n      details: 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n      other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n      local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n      remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n    }\n  } : null;\n  const socketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n        value: resolvedInfo.localFlowControlWindow\n      } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n        value: resolvedInfo.remoteFlowControlWindow\n      } : null\n    }\n  };\n  callback(null, {\n    socket: socketMessage\n  });\n}\nfunction GetServerSockets(call, callback) {\n  const serverId = parseInt(call.request.server_id, 10);\n  const serverEntry = entityMaps[\"server\" /* EntityTypes.server */].getElementByKey(serverId);\n  if (serverEntry === undefined) {\n    callback({\n      code: constants_1.Status.NOT_FOUND,\n      details: 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  const startId = parseInt(call.request.start_socket_id, 10);\n  const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets;\n  const resultList = [];\n  let i;\n  for (i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {\n    resultList.push(socketRefToMessage(i.pointer[1].ref));\n  }\n  callback(null, {\n    socket_ref: resultList,\n    end: i.equals(allSockets.end())\n  });\n}\nfunction getChannelzHandlers() {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [`${__dirname}/../../proto`]\n  });\n  const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n  (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup;","map":{"version":3,"names":["net_1","require","ordered_map_1","connectivity_state_1","constants_1","subchannel_address_1","admin_1","make_client_1","channelRefToMessage","ref","channel_id","id","name","subchannelRefToMessage","subchannel_id","serverRefToMessage","server_id","socketRefToMessage","socket_id","TARGET_RETAINED_TRACES","DEFAULT_MAX_RESULTS","ChannelzTraceStub","constructor","events","creationTimestamp","Date","eventsLogged","addTrace","getTraceMessage","creation_timestamp","dateToProtoTimestamp","num_events_logged","exports","ChannelzTrace","severity","description","child","timestamp","push","childChannel","kind","undefined","childSubchannel","length","slice","map","event","channel_ref","subchannel_ref","ChannelzChildrenTracker","channelChildren","OrderedMap","subchannelChildren","socketChildren","trackerMap","refChild","tracker","trackedChild","find","equals","end","setElement","count","pointer","unrefChild","getElementByKey","eraseElementByKey","getChildLists","channels","subchannels","sockets","ChannelzChildrenTrackerStub","ChannelzCallTracker","callsStarted","callsSucceeded","callsFailed","lastCallStartedTimestamp","addCallStarted","addCallSucceeded","addCallFailed","ChannelzCallTrackerStub","entityMaps","generateRegisterFn","nextId","getNextId","entityMap","getInfo","channelzEnabled","registerChannelzChannel","registerChannelzSubchannel","registerChannelzServer","registerChannelzSocket","unregisterChannelzRef","parseIPv6Section","addressSection","numberValue","Number","parseInt","parseIPv6Chunk","addressChunk","bytePairs","split","section","result","concat","ipAddressStringToBuffer","ipAddress","isIPv4","Buffer","from","Uint8Array","segment","isIPv6","leftSection","rightSection","doubleColonIndex","indexOf","substring","leftBuffer","rightBuffer","middleBuffer","alloc","connectivityStateToMessage","state","ConnectivityState","CONNECTING","IDLE","READY","SHUTDOWN","TRANSIENT_FAILURE","date","millisSinceEpoch","getTime","seconds","nanos","getChannelMessage","channelEntry","resolvedInfo","channelRef","subchannelRef","children","forEach","el","data","target","calls_started","callTracker","calls_succeeded","calls_failed","last_call_started_timestamp","trace","GetChannel","call","callback","channelId","request","code","Status","NOT_FOUND","details","channel","GetTopChannels","maxResults","max_results","resultList","startId","start_channel_id","channelEntries","i","lowerBound","next","getServerMessage","serverEntry","listenSocket","listenerChildren","listen_socket","GetServer","serverId","serverEntries","server","GetServers","start_server_id","GetSubchannel","subchannelId","subchannelEntry","subchannelMessage","socket_ref","subchannel","subchannelAddressToAddressMessage","subchannelAddress","isTcpSubchannelAddress","address","tcpip_address","ip_address","_a","host","port","uds_address","filename","path","GetSocket","socketId","socketEntry","securityMessage","security","model","tls","cipher_suite","cipherSuiteStandardName","standard_name","other_name","_b","cipherSuiteOtherName","local_certificate","_c","localCertificate","remote_certificate","_d","remoteCertificate","socketMessage","local","localAddress","remote","remoteAddress","remote_name","_e","remoteName","keep_alives_sent","keepAlivesSent","streams_started","streamsStarted","streams_succeeded","streamsSucceeded","streams_failed","streamsFailed","last_local_stream_created_timestamp","lastLocalStreamCreatedTimestamp","last_remote_stream_created_timestamp","lastRemoteStreamCreatedTimestamp","messages_received","messagesReceived","messages_sent","messagesSent","last_message_received_timestamp","lastMessageReceivedTimestamp","last_message_sent_timestamp","lastMessageSentTimestamp","local_flow_control_window","localFlowControlWindow","value","remote_flow_control_window","remoteFlowControlWindow","socket","GetServerSockets","start_socket_id","allSockets","sessionChildren","getChannelzHandlers","loadedChannelzDefinition","getChannelzServiceDefinition","loaderLoadSync","loadSync","loadedProto","keepCase","longs","String","enums","defaults","oneofs","includeDirs","__dirname","channelzGrpcObject","loadPackageDefinition","grpc","channelz","v1","Channelz","service","setup","registerAdminService"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/channelz.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isIPv4, isIPv6 } from 'net';\nimport { OrderedMap, type OrderedMapIterator } from '@js-sdsl/ordered-map';\nimport { ConnectivityState } from './connectivity-state';\nimport { Status } from './constants';\nimport { Timestamp } from './generated/google/protobuf/Timestamp';\nimport { Channel as ChannelMessage } from './generated/grpc/channelz/v1/Channel';\nimport { ChannelConnectivityState__Output } from './generated/grpc/channelz/v1/ChannelConnectivityState';\nimport { ChannelRef as ChannelRefMessage } from './generated/grpc/channelz/v1/ChannelRef';\nimport { ChannelTrace } from './generated/grpc/channelz/v1/ChannelTrace';\nimport { GetChannelRequest__Output } from './generated/grpc/channelz/v1/GetChannelRequest';\nimport { GetChannelResponse } from './generated/grpc/channelz/v1/GetChannelResponse';\nimport { sendUnaryData, ServerUnaryCall } from './server-call';\nimport { ServerRef as ServerRefMessage } from './generated/grpc/channelz/v1/ServerRef';\nimport { SocketRef as SocketRefMessage } from './generated/grpc/channelz/v1/SocketRef';\nimport {\n  isTcpSubchannelAddress,\n  SubchannelAddress,\n} from './subchannel-address';\nimport { SubchannelRef as SubchannelRefMessage } from './generated/grpc/channelz/v1/SubchannelRef';\nimport { GetServerRequest__Output } from './generated/grpc/channelz/v1/GetServerRequest';\nimport { GetServerResponse } from './generated/grpc/channelz/v1/GetServerResponse';\nimport { Server as ServerMessage } from './generated/grpc/channelz/v1/Server';\nimport { GetServersRequest__Output } from './generated/grpc/channelz/v1/GetServersRequest';\nimport { GetServersResponse } from './generated/grpc/channelz/v1/GetServersResponse';\nimport { GetTopChannelsRequest__Output } from './generated/grpc/channelz/v1/GetTopChannelsRequest';\nimport { GetTopChannelsResponse } from './generated/grpc/channelz/v1/GetTopChannelsResponse';\nimport { GetSubchannelRequest__Output } from './generated/grpc/channelz/v1/GetSubchannelRequest';\nimport { GetSubchannelResponse } from './generated/grpc/channelz/v1/GetSubchannelResponse';\nimport { Subchannel as SubchannelMessage } from './generated/grpc/channelz/v1/Subchannel';\nimport { GetSocketRequest__Output } from './generated/grpc/channelz/v1/GetSocketRequest';\nimport { GetSocketResponse } from './generated/grpc/channelz/v1/GetSocketResponse';\nimport { Socket as SocketMessage } from './generated/grpc/channelz/v1/Socket';\nimport { Address } from './generated/grpc/channelz/v1/Address';\nimport { Security } from './generated/grpc/channelz/v1/Security';\nimport { GetServerSocketsRequest__Output } from './generated/grpc/channelz/v1/GetServerSocketsRequest';\nimport { GetServerSocketsResponse } from './generated/grpc/channelz/v1/GetServerSocketsResponse';\nimport {\n  ChannelzDefinition,\n  ChannelzHandlers,\n} from './generated/grpc/channelz/v1/Channelz';\nimport { ProtoGrpcType as ChannelzProtoGrpcType } from './generated/channelz';\nimport type { loadSync } from '@grpc/proto-loader';\nimport { registerAdminService } from './admin';\nimport { loadPackageDefinition } from './make-client';\n\nexport type TraceSeverity =\n  | 'CT_UNKNOWN'\n  | 'CT_INFO'\n  | 'CT_WARNING'\n  | 'CT_ERROR';\n\ninterface Ref {\n  kind: EntityTypes;\n  id: number;\n  name: string;\n}\n\nexport interface ChannelRef extends Ref {\n  kind: EntityTypes.channel;\n}\n\nexport interface SubchannelRef extends Ref {\n  kind: EntityTypes.subchannel;\n}\n\nexport interface ServerRef extends Ref {\n  kind: EntityTypes.server;\n}\n\nexport interface SocketRef extends Ref {\n  kind: EntityTypes.socket;\n}\n\nfunction channelRefToMessage(ref: ChannelRef): ChannelRefMessage {\n  return {\n    channel_id: ref.id,\n    name: ref.name,\n  };\n}\n\nfunction subchannelRefToMessage(ref: SubchannelRef): SubchannelRefMessage {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name,\n  };\n}\n\nfunction serverRefToMessage(ref: ServerRef): ServerRefMessage {\n  return {\n    server_id: ref.id,\n  };\n}\n\nfunction socketRefToMessage(ref: SocketRef): SocketRefMessage {\n  return {\n    socket_id: ref.id,\n    name: ref.name,\n  };\n}\n\ninterface TraceEvent {\n  description: string;\n  severity: TraceSeverity;\n  timestamp: Date;\n  childChannel?: ChannelRef;\n  childSubchannel?: SubchannelRef;\n}\n\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\n\n/**\n * Default number of sockets/servers/channels/subchannels to return\n */\nconst DEFAULT_MAX_RESULTS = 100;\n\nexport class ChannelzTraceStub {\n  readonly events: TraceEvent[] = [];\n  readonly creationTimestamp: Date = new Date();\n  readonly eventsLogged = 0;\n\n  addTrace(): void {}\n  getTraceMessage(): ChannelTrace {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: [],\n    };\n  }\n}\n\nexport class ChannelzTrace {\n  events: TraceEvent[] = [];\n  creationTimestamp: Date;\n  eventsLogged = 0;\n\n  constructor() {\n    this.creationTimestamp = new Date();\n  }\n\n  addTrace(\n    severity: TraceSeverity,\n    description: string,\n    child?: ChannelRef | SubchannelRef\n  ) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: child?.kind === 'channel' ? child : undefined,\n      childSubchannel: child?.kind === 'subchannel' ? child : undefined,\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n\n  getTraceMessage(): ChannelTrace {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel\n            ? channelRefToMessage(event.childChannel)\n            : null,\n          subchannel_ref: event.childSubchannel\n            ? subchannelRefToMessage(event.childSubchannel)\n            : null,\n        };\n      }),\n    };\n  }\n}\n\ntype RefOrderedMap = OrderedMap<\n  number,\n  { ref: { id: number; kind: EntityTypes; name: string }; count: number }\n>;\n\nexport class ChannelzChildrenTracker {\n  private channelChildren: RefOrderedMap = new OrderedMap();\n  private subchannelChildren: RefOrderedMap = new OrderedMap();\n  private socketChildren: RefOrderedMap = new OrderedMap();\n  private trackerMap = {\n    [EntityTypes.channel]: this.channelChildren,\n    [EntityTypes.subchannel]: this.subchannelChildren,\n    [EntityTypes.socket]: this.socketChildren,\n  } as const;\n\n  refChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    const tracker = this.trackerMap[child.kind];\n    const trackedChild = tracker.find(child.id);\n\n    if (trackedChild.equals(tracker.end())) {\n      tracker.setElement(\n        child.id,\n        {\n          ref: child,\n          count: 1,\n        },\n        trackedChild\n      );\n    } else {\n      trackedChild.pointer[1].count += 1;\n    }\n  }\n\n  unrefChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    const tracker = this.trackerMap[child.kind];\n    const trackedChild = tracker.getElementByKey(child.id);\n    if (trackedChild !== undefined) {\n      trackedChild.count -= 1;\n      if (trackedChild.count === 0) {\n        tracker.eraseElementByKey(child.id);\n      }\n    }\n  }\n\n  getChildLists(): ChannelzChildren {\n    return {\n      channels: this.channelChildren as ChannelzChildren['channels'],\n      subchannels: this.subchannelChildren as ChannelzChildren['subchannels'],\n      sockets: this.socketChildren as ChannelzChildren['sockets'],\n    };\n  }\n}\n\nexport class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {\n  override refChild(): void {}\n  override unrefChild(): void {}\n}\n\nexport class ChannelzCallTracker {\n  callsStarted = 0;\n  callsSucceeded = 0;\n  callsFailed = 0;\n  lastCallStartedTimestamp: Date | null = null;\n\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\n\nexport class ChannelzCallTrackerStub extends ChannelzCallTracker {\n  override addCallStarted() {}\n  override addCallSucceeded() {}\n  override addCallFailed() {}\n}\n\nexport interface ChannelzChildren {\n  channels: OrderedMap<number, { ref: ChannelRef; count: number }>;\n  subchannels: OrderedMap<number, { ref: SubchannelRef; count: number }>;\n  sockets: OrderedMap<number, { ref: SocketRef; count: number }>;\n}\n\nexport interface ChannelInfo {\n  target: string;\n  state: ConnectivityState;\n  trace: ChannelzTrace | ChannelzTraceStub;\n  callTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n  children: ChannelzChildren;\n}\n\nexport type SubchannelInfo = ChannelInfo;\n\nexport interface ServerInfo {\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  listenerChildren: ChannelzChildren;\n  sessionChildren: ChannelzChildren;\n}\n\nexport interface TlsInfo {\n  cipherSuiteStandardName: string | null;\n  cipherSuiteOtherName: string | null;\n  localCertificate: Buffer | null;\n  remoteCertificate: Buffer | null;\n}\n\nexport interface SocketInfo {\n  localAddress: SubchannelAddress | null;\n  remoteAddress: SubchannelAddress | null;\n  security: TlsInfo | null;\n  remoteName: string | null;\n  streamsStarted: number;\n  streamsSucceeded: number;\n  streamsFailed: number;\n  messagesSent: number;\n  messagesReceived: number;\n  keepAlivesSent: number;\n  lastLocalStreamCreatedTimestamp: Date | null;\n  lastRemoteStreamCreatedTimestamp: Date | null;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n  localFlowControlWindow: number | null;\n  remoteFlowControlWindow: number | null;\n}\n\ninterface ChannelEntry {\n  ref: ChannelRef;\n  getInfo(): ChannelInfo;\n}\n\ninterface SubchannelEntry {\n  ref: SubchannelRef;\n  getInfo(): SubchannelInfo;\n}\n\ninterface ServerEntry {\n  ref: ServerRef;\n  getInfo(): ServerInfo;\n}\n\ninterface SocketEntry {\n  ref: SocketRef;\n  getInfo(): SocketInfo;\n}\n\nexport const enum EntityTypes {\n  channel = 'channel',\n  subchannel = 'subchannel',\n  server = 'server',\n  socket = 'socket',\n}\n\ntype EntryOrderedMap = OrderedMap<number, { ref: Ref; getInfo: () => any }>;\n\nconst entityMaps = {\n  [EntityTypes.channel]: new OrderedMap<number, ChannelEntry>(),\n  [EntityTypes.subchannel]: new OrderedMap<number, SubchannelEntry>(),\n  [EntityTypes.server]: new OrderedMap<number, ServerEntry>(),\n  [EntityTypes.socket]: new OrderedMap<number, SocketEntry>(),\n} as const;\n\nexport type RefByType<T extends EntityTypes> = T extends EntityTypes.channel\n  ? ChannelRef\n  : T extends EntityTypes.server\n  ? ServerRef\n  : T extends EntityTypes.socket\n  ? SocketRef\n  : T extends EntityTypes.subchannel\n  ? SubchannelRef\n  : never;\n\nexport type EntryByType<T extends EntityTypes> = T extends EntityTypes.channel\n  ? ChannelEntry\n  : T extends EntityTypes.server\n  ? ServerEntry\n  : T extends EntityTypes.socket\n  ? SocketEntry\n  : T extends EntityTypes.subchannel\n  ? SubchannelEntry\n  : never;\n\nexport type InfoByType<T extends EntityTypes> = T extends EntityTypes.channel\n  ? ChannelInfo\n  : T extends EntityTypes.subchannel\n  ? SubchannelInfo\n  : T extends EntityTypes.server\n  ? ServerInfo\n  : T extends EntityTypes.socket\n  ? SocketInfo\n  : never;\n\nconst generateRegisterFn = <R extends EntityTypes>(kind: R) => {\n  let nextId = 1;\n  function getNextId(): number {\n    return nextId++;\n  }\n\n  const entityMap: EntryOrderedMap = entityMaps[kind];\n\n  return (\n    name: string,\n    getInfo: () => InfoByType<R>,\n    channelzEnabled: boolean\n  ): RefByType<R> => {\n    const id = getNextId();\n    const ref = { id, name, kind } as RefByType<R>;\n    if (channelzEnabled) {\n      entityMap.setElement(id, { ref, getInfo });\n    }\n    return ref;\n  };\n};\n\nexport const registerChannelzChannel = generateRegisterFn(EntityTypes.channel);\nexport const registerChannelzSubchannel = generateRegisterFn(\n  EntityTypes.subchannel\n);\nexport const registerChannelzServer = generateRegisterFn(EntityTypes.server);\nexport const registerChannelzSocket = generateRegisterFn(EntityTypes.socket);\n\nexport function unregisterChannelzRef(\n  ref: ChannelRef | SubchannelRef | ServerRef | SocketRef\n) {\n  entityMaps[ref.kind].eraseElementByKey(ref.id);\n}\n\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection: string): [number, number] {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [(numberValue / 256) | 0, numberValue % 256];\n}\n\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk: string): number[] {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk\n    .split(':')\n    .map(section => parseIPv6Section(section));\n  const result: number[] = [];\n  return result.concat(...bytePairs);\n}\n\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress: string): Buffer | null {\n  if (isIPv4(ipAddress)) {\n    return Buffer.from(\n      Uint8Array.from(\n        ipAddress.split('.').map(segment => Number.parseInt(segment))\n      )\n    );\n  } else if (isIPv6(ipAddress)) {\n    let leftSection: string;\n    let rightSection: string;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(\n      16 - leftBuffer.length - rightBuffer.length,\n      0\n    );\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\n\nfunction connectivityStateToMessage(\n  state: ConnectivityState\n): ChannelConnectivityState__Output {\n  switch (state) {\n    case ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING',\n      };\n    case ConnectivityState.IDLE:\n      return {\n        state: 'IDLE',\n      };\n    case ConnectivityState.READY:\n      return {\n        state: 'READY',\n      };\n    case ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN',\n      };\n    case ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE',\n      };\n    default:\n      return {\n        state: 'UNKNOWN',\n      };\n  }\n}\n\nfunction dateToProtoTimestamp(date?: Date | null): Timestamp | null {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: (millisSinceEpoch / 1000) | 0,\n    nanos: (millisSinceEpoch % 1000) * 1_000_000,\n  };\n}\n\nfunction getChannelMessage(channelEntry: ChannelEntry): ChannelMessage {\n  const resolvedInfo = channelEntry.getInfo();\n  const channelRef: ChannelRefMessage[] = [];\n  const subchannelRef: SubchannelRefMessage[] = [];\n\n  resolvedInfo.children.channels.forEach(el => {\n    channelRef.push(channelRefToMessage(el[1].ref));\n  });\n\n  resolvedInfo.children.subchannels.forEach(el => {\n    subchannelRef.push(subchannelRefToMessage(el[1].ref));\n  });\n\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(\n        resolvedInfo.callTracker.lastCallStartedTimestamp\n      ),\n      trace: resolvedInfo.trace.getTraceMessage(),\n    },\n    channel_ref: channelRef,\n    subchannel_ref: subchannelRef,\n  };\n}\n\nfunction GetChannel(\n  call: ServerUnaryCall<GetChannelRequest__Output, GetChannelResponse>,\n  callback: sendUnaryData<GetChannelResponse>\n): void {\n  const channelId = parseInt(call.request.channel_id, 10);\n  const channelEntry =\n    entityMaps[EntityTypes.channel].getElementByKey(channelId);\n  if (channelEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No channel data found for id ' + channelId,\n    });\n    return;\n  }\n  callback(null, { channel: getChannelMessage(channelEntry) });\n}\n\nfunction GetTopChannels(\n  call: ServerUnaryCall<GetTopChannelsRequest__Output, GetTopChannelsResponse>,\n  callback: sendUnaryData<GetTopChannelsResponse>\n): void {\n  const maxResults =\n    parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n  const resultList: ChannelMessage[] = [];\n  const startId = parseInt(call.request.start_channel_id, 10);\n  const channelEntries = entityMaps[EntityTypes.channel];\n\n  let i: OrderedMapIterator<number, ChannelEntry>;\n  for (\n    i = channelEntries.lowerBound(startId);\n    !i.equals(channelEntries.end()) && resultList.length < maxResults;\n    i = i.next()\n  ) {\n    resultList.push(getChannelMessage(i.pointer[1]));\n  }\n\n  callback(null, {\n    channel: resultList,\n    end: i.equals(channelEntries.end()),\n  });\n}\n\nfunction getServerMessage(serverEntry: ServerEntry): ServerMessage {\n  const resolvedInfo = serverEntry.getInfo();\n  const listenSocket: SocketRefMessage[] = [];\n\n  resolvedInfo.listenerChildren.sockets.forEach(el => {\n    listenSocket.push(socketRefToMessage(el[1].ref));\n  });\n\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(\n        resolvedInfo.callTracker.lastCallStartedTimestamp\n      ),\n      trace: resolvedInfo.trace.getTraceMessage(),\n    },\n    listen_socket: listenSocket,\n  };\n}\n\nfunction GetServer(\n  call: ServerUnaryCall<GetServerRequest__Output, GetServerResponse>,\n  callback: sendUnaryData<GetServerResponse>\n): void {\n  const serverId = parseInt(call.request.server_id, 10);\n  const serverEntries = entityMaps[EntityTypes.server];\n  const serverEntry = serverEntries.getElementByKey(serverId);\n  if (serverEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No server data found for id ' + serverId,\n    });\n    return;\n  }\n  callback(null, { server: getServerMessage(serverEntry) });\n}\n\nfunction GetServers(\n  call: ServerUnaryCall<GetServersRequest__Output, GetServersResponse>,\n  callback: sendUnaryData<GetServersResponse>\n): void {\n  const maxResults =\n    parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n  const startId = parseInt(call.request.start_server_id, 10);\n  const serverEntries = entityMaps[EntityTypes.server];\n  const resultList: ServerMessage[] = [];\n\n  let i: OrderedMapIterator<number, ServerEntry>;\n  for (\n    i = serverEntries.lowerBound(startId);\n    !i.equals(serverEntries.end()) && resultList.length < maxResults;\n    i = i.next()\n  ) {\n    resultList.push(getServerMessage(i.pointer[1]));\n  }\n\n  callback(null, {\n    server: resultList,\n    end: i.equals(serverEntries.end()),\n  });\n}\n\nfunction GetSubchannel(\n  call: ServerUnaryCall<GetSubchannelRequest__Output, GetSubchannelResponse>,\n  callback: sendUnaryData<GetSubchannelResponse>\n): void {\n  const subchannelId = parseInt(call.request.subchannel_id, 10);\n  const subchannelEntry =\n    entityMaps[EntityTypes.subchannel].getElementByKey(subchannelId);\n  if (subchannelEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No subchannel data found for id ' + subchannelId,\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const listenSocket: SocketRefMessage[] = [];\n\n  resolvedInfo.children.sockets.forEach(el => {\n    listenSocket.push(socketRefToMessage(el[1].ref));\n  });\n\n  const subchannelMessage: SubchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(\n        resolvedInfo.callTracker.lastCallStartedTimestamp\n      ),\n      trace: resolvedInfo.trace.getTraceMessage(),\n    },\n    socket_ref: listenSocket,\n  };\n  callback(null, { subchannel: subchannelMessage });\n}\n\nfunction subchannelAddressToAddressMessage(\n  subchannelAddress: SubchannelAddress\n): Address {\n  if (isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address:\n          ipAddressStringToBuffer(subchannelAddress.host) ?? undefined,\n        port: subchannelAddress.port,\n      },\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path,\n      },\n    };\n  }\n}\n\nfunction GetSocket(\n  call: ServerUnaryCall<GetSocketRequest__Output, GetSocketResponse>,\n  callback: sendUnaryData<GetSocketResponse>\n): void {\n  const socketId = parseInt(call.request.socket_id, 10);\n  const socketEntry = entityMaps[EntityTypes.socket].getElementByKey(socketId);\n  if (socketEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No socket data found for id ' + socketId,\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage: Security | null = resolvedInfo.security\n    ? {\n        model: 'tls',\n        tls: {\n          cipher_suite: resolvedInfo.security.cipherSuiteStandardName\n            ? 'standard_name'\n            : 'other_name',\n          standard_name:\n            resolvedInfo.security.cipherSuiteStandardName ?? undefined,\n          other_name: resolvedInfo.security.cipherSuiteOtherName ?? undefined,\n          local_certificate:\n            resolvedInfo.security.localCertificate ?? undefined,\n          remote_certificate:\n            resolvedInfo.security.remoteCertificate ?? undefined,\n        },\n      }\n    : null;\n  const socketMessage: SocketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress\n      ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)\n      : null,\n    remote: resolvedInfo.remoteAddress\n      ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)\n      : null,\n    remote_name: resolvedInfo.remoteName ?? undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(\n        resolvedInfo.lastLocalStreamCreatedTimestamp\n      ),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(\n        resolvedInfo.lastRemoteStreamCreatedTimestamp\n      ),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(\n        resolvedInfo.lastMessageReceivedTimestamp\n      ),\n      last_message_sent_timestamp: dateToProtoTimestamp(\n        resolvedInfo.lastMessageSentTimestamp\n      ),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow\n        ? { value: resolvedInfo.localFlowControlWindow }\n        : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow\n        ? { value: resolvedInfo.remoteFlowControlWindow }\n        : null,\n    },\n  };\n  callback(null, { socket: socketMessage });\n}\n\nfunction GetServerSockets(\n  call: ServerUnaryCall<\n    GetServerSocketsRequest__Output,\n    GetServerSocketsResponse\n  >,\n  callback: sendUnaryData<GetServerSocketsResponse>\n): void {\n  const serverId = parseInt(call.request.server_id, 10);\n  const serverEntry = entityMaps[EntityTypes.server].getElementByKey(serverId);\n\n  if (serverEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No server data found for id ' + serverId,\n    });\n    return;\n  }\n\n  const startId = parseInt(call.request.start_socket_id, 10);\n  const maxResults =\n    parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets;\n  const resultList: SocketRefMessage[] = [];\n\n  let i: OrderedMapIterator<number, { ref: SocketRef }>;\n  for (\n    i = allSockets.lowerBound(startId);\n    !i.equals(allSockets.end()) && resultList.length < maxResults;\n    i = i.next()\n  ) {\n    resultList.push(socketRefToMessage(i.pointer[1].ref));\n  }\n\n  callback(null, {\n    socket_ref: resultList,\n    end: i.equals(allSockets.end()),\n  });\n}\n\nexport function getChannelzHandlers(): ChannelzHandlers {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets,\n  };\n}\n\nlet loadedChannelzDefinition: ChannelzDefinition | null = null;\n\nexport function getChannelzServiceDefinition(): ChannelzDefinition {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader')\n    .loadSync as typeof loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [`${__dirname}/../../proto`],\n  });\n  const channelzGrpcObject = loadPackageDefinition(\n    loadedProto\n  ) as unknown as ChannelzProtoGrpcType;\n  loadedChannelzDefinition =\n    channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\n\nexport function setup() {\n  registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}