{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = require(\"zlib\");\nconst compression_algorithms_1 = require(\"./compression-algorithms\");\nconst constants_1 = require(\"./constants\");\nconst filter_1 = require(\"./filter\");\nconst logging = require(\"./logging\");\nconst isCompressionAlgorithmKey = key => {\n  return typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string';\n};\nclass CompressionHandler {\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  async writeMessage(message, compress) {\n    let messageBuffer = message;\n    if (compress) {\n      messageBuffer = await this.compressMessage(messageBuffer);\n    }\n    const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n    output.writeUInt8(compress ? 1 : 0, 0);\n    output.writeUInt32BE(messageBuffer.length, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n  async readMessage(data) {\n    const compressed = data.readUInt8(0) === 1;\n    let messageBuffer = data.slice(5);\n    if (compressed) {\n      messageBuffer = await this.decompressMessage(messageBuffer);\n    }\n    return messageBuffer;\n  }\n}\nclass IdentityHandler extends CompressionHandler {\n  async compressMessage(message) {\n    return message;\n  }\n  async writeMessage(message, compress) {\n    const output = Buffer.allocUnsafe(message.length + 5);\n    /* With \"identity\" compression, messages should always be marked as\n     * uncompressed */\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(message.length, 1);\n    message.copy(output, 5);\n    return output;\n  }\n  decompressMessage(message) {\n    return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n  }\n}\nclass DeflateHandler extends CompressionHandler {\n  constructor(maxRecvMessageLength) {\n    super();\n    this.maxRecvMessageLength = maxRecvMessageLength;\n  }\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      let totalLength = 0;\n      const messageParts = [];\n      const decompresser = zlib.createInflate();\n      decompresser.on('data', chunk => {\n        messageParts.push(chunk);\n        totalLength += chunk.byteLength;\n        if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n          decompresser.destroy();\n          reject({\n            code: constants_1.Status.RESOURCE_EXHAUSTED,\n            details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n          });\n        }\n      });\n      decompresser.on('end', () => {\n        resolve(Buffer.concat(messageParts));\n      });\n      decompresser.write(message);\n      decompresser.end();\n    });\n  }\n}\nclass GzipHandler extends CompressionHandler {\n  constructor(maxRecvMessageLength) {\n    super();\n    this.maxRecvMessageLength = maxRecvMessageLength;\n  }\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      let totalLength = 0;\n      const messageParts = [];\n      const decompresser = zlib.createGunzip();\n      decompresser.on('data', chunk => {\n        messageParts.push(chunk);\n        totalLength += chunk.byteLength;\n        if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n          decompresser.destroy();\n          reject({\n            code: constants_1.Status.RESOURCE_EXHAUSTED,\n            details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n          });\n        }\n      });\n      decompresser.on('end', () => {\n        resolve(Buffer.concat(messageParts));\n      });\n      decompresser.write(message);\n      decompresser.end();\n    });\n  }\n}\nclass UnknownHandler extends CompressionHandler {\n  constructor(compressionName) {\n    super();\n    this.compressionName = compressionName;\n  }\n  compressMessage(message) {\n    return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n  }\n  decompressMessage(message) {\n    // This should be unreachable\n    return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n  }\n}\nfunction getCompressionHandler(compressionName, maxReceiveMessageSize) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n    case 'deflate':\n      return new DeflateHandler(maxReceiveMessageSize);\n    case 'gzip':\n      return new GzipHandler(maxReceiveMessageSize);\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n  constructor(channelOptions, sharedFilterConfig) {\n    var _a, _b, _c;\n    super();\n    this.sharedFilterConfig = sharedFilterConfig;\n    this.sendCompression = new IdentityHandler();\n    this.receiveCompression = new IdentityHandler();\n    this.currentCompressionAlgorithm = 'identity';\n    const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n    this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.maxSendMessageLength = (_b = channelOptions['grpc.max_send_message_length']) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    if (compressionAlgorithmKey !== undefined) {\n      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n        const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n        const serverSupportedEncodings = (_c = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c === void 0 ? void 0 : _c.split(',');\n        /**\n         * There are two possible situations here:\n         * 1) We don't have any info yet from the server about what compression it supports\n         *    In that case we should just use what the client tells us to use\n         * 2) We've previously received a response from the server including a grpc-accept-encoding header\n         *    In that case we only want to use the encoding chosen by the client if the server supports it\n         */\n        if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n          this.currentCompressionAlgorithm = clientSelectedEncoding;\n          this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);\n        }\n      } else {\n        logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n      }\n    }\n  }\n  async sendMetadata(metadata) {\n    const headers = await metadata;\n    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n    headers.set('accept-encoding', 'identity');\n    // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n    if (this.currentCompressionAlgorithm === 'identity') {\n      headers.remove('grpc-encoding');\n    } else {\n      headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n    }\n    return headers;\n  }\n  receiveMetadata(metadata) {\n    const receiveEncoding = metadata.get('grpc-encoding');\n    if (receiveEncoding.length > 0) {\n      const encoding = receiveEncoding[0];\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\n      }\n    }\n    metadata.remove('grpc-encoding');\n    /* Check to see if the compression we're using to send messages is supported by the server\n     * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n    const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n    if (serverSupportedEncodingsHeader) {\n      this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n      const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n      if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n        this.sendCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n      }\n    }\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n  async sendMessage(message) {\n    var _a;\n    /* This filter is special. The input message is the bare message bytes,\n     * and the output is a framed and possibly compressed message. For this\n     * reason, this filter should be at the bottom of the filter stack */\n    const resolvedMessage = await message;\n    if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {\n      throw {\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`\n      };\n    }\n    let compress;\n    if (this.sendCompression instanceof IdentityHandler) {\n      compress = false;\n    } else {\n      compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;\n    }\n    return {\n      message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n      flags: resolvedMessage.flags\n    };\n  }\n  async receiveMessage(message) {\n    /* This filter is also special. The input message is framed and possibly\n     * compressed, and the output message is deframed and uncompressed. So\n     * this is another reason that this filter should be at the bottom of the\n     * filter stack. */\n    return this.receiveCompression.readMessage(await message);\n  }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n  constructor(channel, options) {\n    this.options = options;\n    this.sharedFilterConfig = {};\n  }\n  createFilter() {\n    return new CompressionFilter(this.options, this.sharedFilterConfig);\n  }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;","map":{"version":3,"names":["zlib","require","compression_algorithms_1","constants_1","filter_1","logging","isCompressionAlgorithmKey","key","CompressionAlgorithms","CompressionHandler","writeMessage","message","compress","messageBuffer","compressMessage","output","Buffer","allocUnsafe","length","writeUInt8","writeUInt32BE","copy","readMessage","data","compressed","readUInt8","slice","decompressMessage","IdentityHandler","Promise","reject","Error","DeflateHandler","constructor","maxRecvMessageLength","resolve","deflate","err","totalLength","messageParts","decompresser","createInflate","on","chunk","push","byteLength","destroy","code","Status","RESOURCE_EXHAUSTED","details","concat","write","end","GzipHandler","gzip","createGunzip","UnknownHandler","compressionName","getCompressionHandler","maxReceiveMessageSize","CompressionFilter","BaseFilter","channelOptions","sharedFilterConfig","sendCompression","receiveCompression","currentCompressionAlgorithm","compressionAlgorithmKey","maxReceiveMessageLength","_a","DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH","maxSendMessageLength","_b","DEFAULT_MAX_SEND_MESSAGE_LENGTH","undefined","clientSelectedEncoding","serverSupportedEncodings","_c","serverSupportedEncodingHeader","split","includes","log","LogVerbosity","ERROR","sendMetadata","metadata","headers","set","remove","receiveMetadata","receiveEncoding","get","encoding","serverSupportedEncodingsHeader","sendMessage","resolvedMessage","flags","receiveMessage","exports","CompressionFilterFactory","channel","options","createFilter"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/compression-filter.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as zlib from 'zlib';\n\nimport { WriteObject, WriteFlags } from './call-interface';\nimport { Channel } from './channel';\nimport { ChannelOptions } from './channel-options';\nimport { CompressionAlgorithms } from './compression-algorithms';\nimport { DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH, DEFAULT_MAX_SEND_MESSAGE_LENGTH, LogVerbosity, Status } from './constants';\nimport { BaseFilter, Filter, FilterFactory } from './filter';\nimport * as logging from './logging';\nimport { Metadata, MetadataValue } from './metadata';\n\nconst isCompressionAlgorithmKey = (\n  key: number\n): key is CompressionAlgorithms => {\n  return (\n    typeof key === 'number' && typeof CompressionAlgorithms[key] === 'string'\n  );\n};\n\ntype CompressionAlgorithm = keyof typeof CompressionAlgorithms;\n\ntype SharedCompressionFilterConfig = {\n  serverSupportedEncodingHeader?: string;\n};\n\nabstract class CompressionHandler {\n  protected abstract compressMessage(message: Buffer): Promise<Buffer>;\n  protected abstract decompressMessage(data: Buffer): Promise<Buffer>;\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> {\n    let messageBuffer = message;\n    if (compress) {\n      messageBuffer = await this.compressMessage(messageBuffer);\n    }\n    const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n    output.writeUInt8(compress ? 1 : 0, 0);\n    output.writeUInt32BE(messageBuffer.length, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n  async readMessage(data: Buffer): Promise<Buffer> {\n    const compressed = data.readUInt8(0) === 1;\n    let messageBuffer = data.slice(5);\n    if (compressed) {\n      messageBuffer = await this.decompressMessage(messageBuffer);\n    }\n    return messageBuffer;\n  }\n}\n\nclass IdentityHandler extends CompressionHandler {\n  async compressMessage(message: Buffer) {\n    return message;\n  }\n\n  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> {\n    const output = Buffer.allocUnsafe(message.length + 5);\n    /* With \"identity\" compression, messages should always be marked as\n     * uncompressed */\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(message.length, 1);\n    message.copy(output, 5);\n    return output;\n  }\n\n  decompressMessage(message: Buffer): Promise<Buffer> {\n    return Promise.reject<Buffer>(\n      new Error(\n        'Received compressed message but \"grpc-encoding\" header was identity'\n      )\n    );\n  }\n}\n\nclass DeflateHandler extends CompressionHandler {\n  constructor(private maxRecvMessageLength: number) {\n    super();\n  }\n\n  compressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      let totalLength = 0;\n      const messageParts: Buffer[] = [];\n      const decompresser = zlib.createInflate();\n      decompresser.on('data', (chunk: Buffer) => {\n        messageParts.push(chunk);\n        totalLength += chunk.byteLength;\n        if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n          decompresser.destroy();\n          reject({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n          });\n        }\n      });\n      decompresser.on('end', () => {\n        resolve(Buffer.concat(messageParts));\n      });\n      decompresser.write(message);\n      decompresser.end();\n    });\n  }\n}\n\nclass GzipHandler extends CompressionHandler {\n  constructor(private maxRecvMessageLength: number) {\n    super();\n  }\n\n  compressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      let totalLength = 0;\n      const messageParts: Buffer[] = [];\n      const decompresser = zlib.createGunzip();\n      decompresser.on('data', (chunk: Buffer) => {\n        messageParts.push(chunk);\n        totalLength += chunk.byteLength;\n        if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n          decompresser.destroy();\n          reject({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n          });\n        }\n      });\n      decompresser.on('end', () => {\n        resolve(Buffer.concat(messageParts));\n      });\n      decompresser.write(message);\n      decompresser.end();\n    });\n  }\n}\n\nclass UnknownHandler extends CompressionHandler {\n  constructor(private readonly compressionName: string) {\n    super();\n  }\n  compressMessage(message: Buffer): Promise<Buffer> {\n    return Promise.reject<Buffer>(\n      new Error(\n        `Received message compressed with unsupported compression method ${this.compressionName}`\n      )\n    );\n  }\n\n  decompressMessage(message: Buffer): Promise<Buffer> {\n    // This should be unreachable\n    return Promise.reject<Buffer>(\n      new Error(`Compression method not supported: ${this.compressionName}`)\n    );\n  }\n}\n\nfunction getCompressionHandler(compressionName: string, maxReceiveMessageSize: number): CompressionHandler {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n    case 'deflate':\n      return new DeflateHandler(maxReceiveMessageSize);\n    case 'gzip':\n      return new GzipHandler(maxReceiveMessageSize);\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nexport class CompressionFilter extends BaseFilter implements Filter {\n  private sendCompression: CompressionHandler = new IdentityHandler();\n  private receiveCompression: CompressionHandler = new IdentityHandler();\n  private currentCompressionAlgorithm: CompressionAlgorithm = 'identity';\n  private maxReceiveMessageLength: number;\n  private maxSendMessageLength: number;\n\n  constructor(\n    channelOptions: ChannelOptions,\n    private sharedFilterConfig: SharedCompressionFilterConfig\n  ) {\n    super();\n\n    const compressionAlgorithmKey =\n      channelOptions['grpc.default_compression_algorithm'];\n    this.maxReceiveMessageLength = channelOptions['grpc.max_receive_message_length'] ?? DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.maxSendMessageLength = channelOptions['grpc.max_send_message_length'] ?? DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    if (compressionAlgorithmKey !== undefined) {\n      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n        const clientSelectedEncoding = CompressionAlgorithms[\n          compressionAlgorithmKey\n        ] as CompressionAlgorithm;\n        const serverSupportedEncodings =\n          sharedFilterConfig.serverSupportedEncodingHeader?.split(',');\n        /**\n         * There are two possible situations here:\n         * 1) We don't have any info yet from the server about what compression it supports\n         *    In that case we should just use what the client tells us to use\n         * 2) We've previously received a response from the server including a grpc-accept-encoding header\n         *    In that case we only want to use the encoding chosen by the client if the server supports it\n         */\n        if (\n          !serverSupportedEncodings ||\n          serverSupportedEncodings.includes(clientSelectedEncoding)\n        ) {\n          this.currentCompressionAlgorithm = clientSelectedEncoding;\n          this.sendCompression = getCompressionHandler(\n            this.currentCompressionAlgorithm,\n            -1\n          );\n        }\n      } else {\n        logging.log(\n          LogVerbosity.ERROR,\n          `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`\n        );\n      }\n    }\n  }\n\n  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {\n    const headers: Metadata = await metadata;\n    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n    headers.set('accept-encoding', 'identity');\n\n    // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n    if (this.currentCompressionAlgorithm === 'identity') {\n      headers.remove('grpc-encoding');\n    } else {\n      headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n    }\n\n    return headers;\n  }\n\n  receiveMetadata(metadata: Metadata): Metadata {\n    const receiveEncoding: MetadataValue[] = metadata.get('grpc-encoding');\n    if (receiveEncoding.length > 0) {\n      const encoding: MetadataValue = receiveEncoding[0];\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\n      }\n    }\n    metadata.remove('grpc-encoding');\n\n    /* Check to see if the compression we're using to send messages is supported by the server\n     * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n    const serverSupportedEncodingsHeader = metadata.get(\n      'grpc-accept-encoding'\n    )[0] as string | undefined;\n    if (serverSupportedEncodingsHeader) {\n      this.sharedFilterConfig.serverSupportedEncodingHeader =\n        serverSupportedEncodingsHeader;\n      const serverSupportedEncodings =\n        serverSupportedEncodingsHeader.split(',');\n\n      if (\n        !serverSupportedEncodings.includes(this.currentCompressionAlgorithm)\n      ) {\n        this.sendCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n      }\n    }\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {\n    /* This filter is special. The input message is the bare message bytes,\n     * and the output is a framed and possibly compressed message. For this\n     * reason, this filter should be at the bottom of the filter stack */\n    const resolvedMessage: WriteObject = await message;\n    if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {\n      throw {\n        code: Status.RESOURCE_EXHAUSTED,\n        details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`\n      };\n    }\n    let compress: boolean;\n    if (this.sendCompression instanceof IdentityHandler) {\n      compress = false;\n    } else {\n      compress = ((resolvedMessage.flags ?? 0) & WriteFlags.NoCompress) === 0;\n    }\n\n    return {\n      message: await this.sendCompression.writeMessage(\n        resolvedMessage.message,\n        compress\n      ),\n      flags: resolvedMessage.flags,\n    };\n  }\n\n  async receiveMessage(message: Promise<Buffer>) {\n    /* This filter is also special. The input message is framed and possibly\n     * compressed, and the output message is deframed and uncompressed. So\n     * this is another reason that this filter should be at the bottom of the\n     * filter stack. */\n    return this.receiveCompression.readMessage(await message);\n  }\n}\n\nexport class CompressionFilterFactory\n  implements FilterFactory<CompressionFilter>\n{\n  private sharedFilterConfig: SharedCompressionFilterConfig = {};\n  constructor(channel: Channel, private readonly options: ChannelOptions) {}\n  createFilter(): CompressionFilter {\n    return new CompressionFilter(this.options, this.sharedFilterConfig);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}