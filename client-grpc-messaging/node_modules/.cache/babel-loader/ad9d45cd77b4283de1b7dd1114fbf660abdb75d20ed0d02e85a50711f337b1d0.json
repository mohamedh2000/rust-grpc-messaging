{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.endpointEqual = exports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\nconst net_1 = require(\"net\");\nfunction isTcpSubchannelAddress(address) {\n  return 'port' in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n  if (!address1 && !address2) {\n    return true;\n  }\n  if (!address1 || !address2) {\n    return false;\n  }\n  if (isTcpSubchannelAddress(address1)) {\n    return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;\n  } else {\n    return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n  }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n  if (isTcpSubchannelAddress(address)) {\n    if ((0, net_1.isIPv6)(address.host)) {\n      return '[' + address.host + ']:' + address.port;\n    } else {\n      return address.host + ':' + address.port;\n    }\n  } else {\n    return address.path;\n  }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n  if ((0, net_1.isIP)(addressString)) {\n    return {\n      host: addressString,\n      port: port !== null && port !== void 0 ? port : DEFAULT_PORT\n    };\n  } else {\n    return {\n      path: addressString\n    };\n  }\n}\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\nfunction endpointEqual(endpoint1, endpoint2) {\n  if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n    return false;\n  }\n  for (let i = 0; i < endpoint1.addresses.length; i++) {\n    if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.endpointEqual = endpointEqual;\nfunction endpointToString(endpoint) {\n  return '[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']';\n}\nexports.endpointToString = endpointToString;\nfunction endpointHasAddress(endpoint, expectedAddress) {\n  for (const address of endpoint.addresses) {\n    if (subchannelAddressEqual(address, expectedAddress)) {\n      return true;\n    }\n  }\n  return false;\n}\nexports.endpointHasAddress = endpointHasAddress;\nfunction endpointEqualUnordered(endpoint1, endpoint2) {\n  if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n    return false;\n  }\n  for (const address1 of endpoint1.addresses) {\n    let matchFound = false;\n    for (const address2 of endpoint2.addresses) {\n      if (subchannelAddressEqual(address1, address2)) {\n        matchFound = true;\n        break;\n      }\n    }\n    if (!matchFound) {\n      return false;\n    }\n  }\n  return true;\n}\nclass EndpointMap {\n  constructor() {\n    this.map = new Set();\n  }\n  get size() {\n    return this.map.size;\n  }\n  getForSubchannelAddress(address) {\n    for (const entry of this.map) {\n      if (endpointHasAddress(entry.key, address)) {\n        return entry.value;\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Delete any entries in this map with keys that are not in endpoints\n   * @param endpoints\n   */\n  deleteMissing(endpoints) {\n    const removedValues = [];\n    for (const entry of this.map) {\n      let foundEntry = false;\n      for (const endpoint of endpoints) {\n        if (endpointEqualUnordered(endpoint, entry.key)) {\n          foundEntry = true;\n        }\n      }\n      if (!foundEntry) {\n        removedValues.push(entry.value);\n        this.map.delete(entry);\n      }\n    }\n    return removedValues;\n  }\n  get(endpoint) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        return entry.value;\n      }\n    }\n    return undefined;\n  }\n  set(endpoint, mapEntry) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        entry.value = mapEntry;\n        return;\n      }\n    }\n    this.map.add({\n      key: endpoint,\n      value: mapEntry\n    });\n  }\n  delete(endpoint) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        this.map.delete(entry);\n        return;\n      }\n    }\n  }\n  has(endpoint) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  clear() {\n    this.map.clear();\n  }\n  *keys() {\n    for (const entry of this.map) {\n      yield entry.key;\n    }\n  }\n  *values() {\n    for (const entry of this.map) {\n      yield entry.value;\n    }\n  }\n  *entries() {\n    for (const entry of this.map) {\n      yield [entry.key, entry.value];\n    }\n  }\n}\nexports.EndpointMap = EndpointMap;","map":{"version":3,"names":["net_1","require","isTcpSubchannelAddress","address","exports","subchannelAddressEqual","address1","address2","host","port","path","subchannelAddressToString","isIPv6","DEFAULT_PORT","stringToSubchannelAddress","addressString","isIP","endpointEqual","endpoint1","endpoint2","addresses","length","i","endpointToString","endpoint","map","join","endpointHasAddress","expectedAddress","endpointEqualUnordered","matchFound","EndpointMap","constructor","Set","size","getForSubchannelAddress","entry","key","value","undefined","deleteMissing","endpoints","removedValues","foundEntry","push","delete","get","set","mapEntry","add","has","clear","keys","values","entries"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/subchannel-address.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isIP, isIPv6 } from 'net';\n\nexport interface TcpSubchannelAddress {\n  port: number;\n  host: string;\n}\n\nexport interface IpcSubchannelAddress {\n  path: string;\n}\n/**\n * This represents a single backend address to connect to. This interface is a\n * subset of net.SocketConnectOpts, i.e. the options described at\n * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener.\n * Those are in turn a subset of the options that can be passed to http2.connect.\n */\n\nexport type SubchannelAddress = TcpSubchannelAddress | IpcSubchannelAddress;\n\nexport function isTcpSubchannelAddress(\n  address: SubchannelAddress\n): address is TcpSubchannelAddress {\n  return 'port' in address;\n}\n\nexport function subchannelAddressEqual(\n  address1?: SubchannelAddress,\n  address2?: SubchannelAddress\n): boolean {\n  if (!address1 && !address2) {\n    return true;\n  }\n  if (!address1 || !address2) {\n    return false;\n  }\n  if (isTcpSubchannelAddress(address1)) {\n    return (\n      isTcpSubchannelAddress(address2) &&\n      address1.host === address2.host &&\n      address1.port === address2.port\n    );\n  } else {\n    return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n  }\n}\n\nexport function subchannelAddressToString(address: SubchannelAddress): string {\n  if (isTcpSubchannelAddress(address)) {\n    if (isIPv6(address.host)) {\n      return '[' + address.host + ']:' + address.port;\n    } else {\n      return address.host + ':' + address.port;\n    }\n  } else {\n    return address.path;\n  }\n}\n\nconst DEFAULT_PORT = 443;\n\nexport function stringToSubchannelAddress(\n  addressString: string,\n  port?: number\n): SubchannelAddress {\n  if (isIP(addressString)) {\n    return {\n      host: addressString,\n      port: port ?? DEFAULT_PORT,\n    };\n  } else {\n    return {\n      path: addressString,\n    };\n  }\n}\n\nexport interface Endpoint {\n  addresses: SubchannelAddress[];\n}\n\nexport function endpointEqual(endpoint1: Endpoint, endpoint2: Endpoint) {\n  if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n    return false;\n  }\n  for (let i = 0; i < endpoint1.addresses.length; i++) {\n    if (\n      !subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function endpointToString(endpoint: Endpoint): string {\n  return (\n    '[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']'\n  );\n}\n\nexport function endpointHasAddress(\n  endpoint: Endpoint,\n  expectedAddress: SubchannelAddress\n): boolean {\n  for (const address of endpoint.addresses) {\n    if (subchannelAddressEqual(address, expectedAddress)) {\n      return true;\n    }\n  }\n  return false;\n}\n\ninterface EndpointMapEntry<ValueType> {\n  key: Endpoint;\n  value: ValueType;\n}\n\nfunction endpointEqualUnordered(\n  endpoint1: Endpoint,\n  endpoint2: Endpoint\n): boolean {\n  if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n    return false;\n  }\n  for (const address1 of endpoint1.addresses) {\n    let matchFound = false;\n    for (const address2 of endpoint2.addresses) {\n      if (subchannelAddressEqual(address1, address2)) {\n        matchFound = true;\n        break;\n      }\n    }\n    if (!matchFound) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport class EndpointMap<ValueType> {\n  private map: Set<EndpointMapEntry<ValueType>> = new Set();\n\n  get size() {\n    return this.map.size;\n  }\n\n  getForSubchannelAddress(address: SubchannelAddress): ValueType | undefined {\n    for (const entry of this.map) {\n      if (endpointHasAddress(entry.key, address)) {\n        return entry.value;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Delete any entries in this map with keys that are not in endpoints\n   * @param endpoints\n   */\n  deleteMissing(endpoints: Endpoint[]): ValueType[] {\n    const removedValues: ValueType[] = [];\n    for (const entry of this.map) {\n      let foundEntry = false;\n      for (const endpoint of endpoints) {\n        if (endpointEqualUnordered(endpoint, entry.key)) {\n          foundEntry = true;\n        }\n      }\n      if (!foundEntry) {\n        removedValues.push(entry.value);\n        this.map.delete(entry);\n      }\n    }\n    return removedValues;\n  }\n\n  get(endpoint: Endpoint): ValueType | undefined {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        return entry.value;\n      }\n    }\n    return undefined;\n  }\n\n  set(endpoint: Endpoint, mapEntry: ValueType) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        entry.value = mapEntry;\n        return;\n      }\n    }\n    this.map.add({ key: endpoint, value: mapEntry });\n  }\n\n  delete(endpoint: Endpoint) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        this.map.delete(entry);\n        return;\n      }\n    }\n  }\n\n  has(endpoint: Endpoint): boolean {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n  *keys(): IterableIterator<Endpoint> {\n    for (const entry of this.map) {\n      yield entry.key;\n    }\n  }\n\n  *values(): IterableIterator<ValueType> {\n    for (const entry of this.map) {\n      yield entry.value;\n    }\n  }\n\n  *entries(): IterableIterator<[Endpoint, ValueType]> {\n    for (const entry of this.map) {\n      yield [entry.key, entry.value];\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}