{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = require(\"./channel-options\");\nconst subchannel_1 = require(\"./subchannel\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst transport_1 = require(\"./transport\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   */\n  constructor() {\n    this.pool = Object.create(null);\n    /**\n     * A timer of a task performing a periodic subchannel cleanup.\n     */\n    this.cleanupTimer = null;\n  }\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n  unrefUnusedSubchannels() {\n    let allSubchannelsUnrefed = true;\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // eslint-disable-disable-next-line:forin\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n    // Cancel the cleanup task if all subchannels have been unrefed.\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n  ensureCleanupTask() {\n    var _a, _b;\n    if (this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL);\n      // Unref because this timer should not keep the event loop running.\n      // Call unref only if it exists to address electron/electron#21162\n      (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n  getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n    this.ensureCleanupTask();\n    const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      for (const subchannelObj of subchannelObjArray) {\n        if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n          return subchannelObj.subchannel;\n        }\n      }\n    }\n    // If we get here, no matching subchannel was found\n    const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel\n    });\n    subchannel.ref();\n    return subchannel;\n  }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool();\n  }\n}\nexports.getSubchannelPool = getSubchannelPool;","map":{"version":3,"names":["channel_options_1","require","subchannel_1","subchannel_address_1","uri_parser_1","transport_1","REF_CHECK_INTERVAL","SubchannelPool","constructor","pool","Object","create","cleanupTimer","unrefUnusedSubchannels","allSubchannelsUnrefed","channelTarget","subchannelObjArray","refedSubchannels","filter","value","subchannel","unrefIfOneRef","length","clearInterval","ensureCleanupTask","setInterval","_b","_a","unref","call","getOrCreateSubchannel","channelTargetUri","subchannelTarget","channelArguments","channelCredentials","uriToString","subchannelObj","subchannelAddressEqual","subchannelAddress","channelOptionsEqual","_equals","Subchannel","Http2SubchannelConnector","push","ref","exports","globalSubchannelPool","getSubchannelPool","global"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/subchannel-pool.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions, channelOptionsEqual } from './channel-options';\nimport { Subchannel } from './subchannel';\nimport {\n  SubchannelAddress,\n  subchannelAddressEqual,\n} from './subchannel-address';\nimport { ChannelCredentials } from './channel-credentials';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { Http2SubchannelConnector } from './transport';\n\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10_000;\n\nexport class SubchannelPool {\n  private pool: {\n    [channelTarget: string]: Array<{\n      subchannelAddress: SubchannelAddress;\n      channelArguments: ChannelOptions;\n      channelCredentials: ChannelCredentials;\n      subchannel: Subchannel;\n    }>;\n  } = Object.create(null);\n\n  /**\n   * A timer of a task performing a periodic subchannel cleanup.\n   */\n  private cleanupTimer: NodeJS.Timeout | null = null;\n\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   */\n  constructor() {}\n\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n  unrefUnusedSubchannels(): void {\n    let allSubchannelsUnrefed = true;\n\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // eslint-disable-disable-next-line:forin\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n\n      const refedSubchannels = subchannelObjArray.filter(\n        value => !value.subchannel.unrefIfOneRef()\n      );\n\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n\n    // Cancel the cleanup task if all subchannels have been unrefed.\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n  ensureCleanupTask(): void {\n    if (this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL);\n\n      // Unref because this timer should not keep the event loop running.\n      // Call unref only if it exists to address electron/electron#21162\n      this.cleanupTimer.unref?.();\n    }\n  }\n\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n  getOrCreateSubchannel(\n    channelTargetUri: GrpcUri,\n    subchannelTarget: SubchannelAddress,\n    channelArguments: ChannelOptions,\n    channelCredentials: ChannelCredentials\n  ): Subchannel {\n    this.ensureCleanupTask();\n    const channelTarget = uriToString(channelTargetUri);\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      for (const subchannelObj of subchannelObjArray) {\n        if (\n          subchannelAddressEqual(\n            subchannelTarget,\n            subchannelObj.subchannelAddress\n          ) &&\n          channelOptionsEqual(\n            channelArguments,\n            subchannelObj.channelArguments\n          ) &&\n          channelCredentials._equals(subchannelObj.channelCredentials)\n        ) {\n          return subchannelObj.subchannel;\n        }\n      }\n    }\n    // If we get here, no matching subchannel was found\n    const subchannel = new Subchannel(\n      channelTargetUri,\n      subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      new Http2SubchannelConnector(channelTargetUri)\n    );\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel,\n    });\n    subchannel.ref();\n    return subchannel;\n  }\n}\n\nconst globalSubchannelPool = new SubchannelPool();\n\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nexport function getSubchannelPool(global: boolean): SubchannelPool {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}