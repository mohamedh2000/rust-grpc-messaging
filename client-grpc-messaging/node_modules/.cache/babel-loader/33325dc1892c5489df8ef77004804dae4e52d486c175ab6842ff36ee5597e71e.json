{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = require(\"./constants\");\nconst deadline_1 = require(\"./deadline\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'retrying_call';\nclass RetryThrottler {\n  constructor(maxTokens, tokenRatio, previousRetryThrottler) {\n    this.maxTokens = maxTokens;\n    this.tokenRatio = tokenRatio;\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n  constructor(totalLimit, limitPerCall) {\n    this.totalLimit = totalLimit;\n    this.limitPerCall = limitPerCall;\n    this.totalAllocated = 0;\n    this.allocatedPerCall = new Map();\n  }\n  allocate(size, callId) {\n    var _a;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n  free(size, callId) {\n    var _a;\n    if (this.totalAllocated < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (currentPerCall < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n  freeAll(callId) {\n    var _a;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\nconst DEFAULT_MAX_ATTEMPTS_LIMIT = 5;\nclass RetryingCall {\n  constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\n    var _a;\n    this.channel = channel;\n    this.callConfig = callConfig;\n    this.methodName = methodName;\n    this.host = host;\n    this.credentials = credentials;\n    this.deadline = deadline;\n    this.callNumber = callNumber;\n    this.bufferTracker = bufferTracker;\n    this.retryThrottler = retryThrottler;\n    this.listener = null;\n    this.initialMetadata = null;\n    this.underlyingCalls = [];\n    this.writeBuffer = [];\n    /**\n     * The offset of message indices in the writeBuffer. For example, if\n     * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n     * is in writeBuffer[5].\n     */\n    this.writeBufferOffset = 0;\n    /**\n     * Tracks whether a read has been started, so that we know whether to start\n     * reads on new child calls. This only matters for the first read, because\n     * once a message comes in the child call becomes committed and there will\n     * be no new child calls.\n     */\n    this.readStarted = false;\n    this.transparentRetryUsed = false;\n    /**\n     * Number of attempts so far\n     */\n    this.attempts = 0;\n    this.hedgingTimer = null;\n    this.committedCallIndex = null;\n    this.initialRetryBackoffSec = 0;\n    this.nextRetryBackoffSec = 0;\n    const maxAttemptsLimit = (_a = channel.getOptions()['grpc-node.retry_max_attempts_limit']) !== null && _a !== void 0 ? _a : DEFAULT_MAX_ATTEMPTS_LIMIT;\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n      this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n      this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n      this.maxAttempts = 1;\n    }\n    this.startTime = new Date();\n  }\n  getDeadlineInfo() {\n    if (this.underlyingCalls.length === 0) {\n      return [];\n    }\n    const deadlineInfo = [];\n    const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];\n    if (this.underlyingCalls.length > 1) {\n      deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);\n    }\n    if (latestCall.startTime > this.startTime) {\n      deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);\n    }\n    deadlineInfo.push(...latestCall.call.getDeadlineInfo());\n    return deadlineInfo;\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  reportStatus(statusObject) {\n    this.trace('ended with status: code=' + statusObject.code + ' details=\"' + statusObject.details + '\" start time=' + this.startTime.toISOString());\n    this.bufferTracker.freeAll(this.callNumber);\n    this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n    this.writeBuffer = [];\n    process.nextTick(() => {\n      var _a;\n      // Explicitly construct status object to remove progress field\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n        code: statusObject.code,\n        details: statusObject.details,\n        metadata: statusObject.metadata\n      });\n    });\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.reportStatus({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n    for (const {\n      call\n    } of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer() {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n  getBufferEntry(messageIndex) {\n    var _a;\n    return (_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n      entryType: 'FREED',\n      allocated: false\n    };\n  }\n  getNextBufferIndex() {\n    return this.writeBufferOffset + this.writeBuffer.length;\n  }\n  clearSentMessages() {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n    for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\n      const bufferEntry = this.getBufferEntry(messageIndex);\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n      }\n    }\n    this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n    this.writeBufferOffset = earliestNeededMessageIndex;\n  }\n  commitCall(index) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('Committing call [' + this.underlyingCalls[index].call.getCallNumber() + '] at index ' + index);\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n    }\n    this.clearSentMessages();\n  }\n  commitCallWithMostMessages() {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (childCall.state === 'ACTIVE' && childCall.nextMessageToSend > mostMessages) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    if (callWithMostMessages === -1) {\n      /* There are no active calls, disable retries to force the next call that\n       * is started to be committed. */\n      this.state = 'TRANSPARENT_ONLY';\n    } else {\n      this.commitCall(callWithMostMessages);\n    }\n  }\n  isStatusCodeInList(list, code) {\n    return list.some(value => {\n      var _a;\n      return value === code || value.toString().toLowerCase() === ((_a = constants_1.Status[code]) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n    });\n  }\n  getNextRetryBackoffMs() {\n    var _a;\n    const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n    this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n    return nextBackoffMs;\n  }\n  maybeRetryCall(pushback, callback) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    if (this.attempts >= this.maxAttempts) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      var _a, _b;\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n  countActiveCalls() {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n  handleProcessedStatus(status, callIndex, pushback) {\n    var _a, _b, _c;\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n          (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n          let delayMs;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n          (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n          this.maybeRetryCall(pushback, retried => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n  getPushback(metadata) {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0]);\n    } catch (e) {\n      return -1;\n    }\n  }\n  handleChildStatus(status, callIndex) {\n    var _a;\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('state=' + this.state + ' handling status with progress ' + status.progress + ' from child [' + this.underlyingCalls[callIndex].call.getCallNumber() + '] in state ' + this.underlyingCalls[callIndex].state);\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === constants_1.Status.OK) {\n      (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        }\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n  maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    if (this.attempts >= this.maxAttempts) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n  maybeStartHedgingTimer() {\n    var _a, _b, _c;\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= this.maxAttempts) {\n      return;\n    }\n    const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\n    const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n  }\n  startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n    this.trace('Created child call [' + child.getCallNumber() + '] for attempt ' + this.attempts);\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({\n      state: 'ACTIVE',\n      call: child,\n      nextMessageToSend: 0,\n      startTime: new Date()\n    });\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace('Received message from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace('Received status from child [' + child.getCallNumber() + ']');\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        this.handleChildStatus(status, index);\n      }\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n  handleChildWriteCompleted(childIndex) {\n    var _a, _b;\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.clearSentMessages();\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n  sendNextChildMessage(childIndex) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.getBufferEntry(childCall.nextMessageToSend)) {\n      const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE':\n          childCall.call.sendMessageWithContext({\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(childIndex);\n            }\n          }, bufferEntry.message.message);\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n  sendMessageWithContext(context, message) {\n    var _a;\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj = {\n      message,\n      flags: context.flags\n    };\n    const messageIndex = this.getNextBufferIndex();\n    const bufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n    };\n    this.writeBuffer.push(bufferEntry);\n    if (bufferEntry.allocated) {\n      (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n          call.call.sendMessageWithContext({\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(callIndex);\n            }\n          }, message);\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      // commitCallWithMostMessages can fail if we are between ping attempts\n      if (this.committedCallIndex === null) {\n        return;\n      }\n      const call = this.underlyingCalls[this.committedCallIndex];\n      bufferEntry.callback = context.callback;\n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext({\n          callback: error => {\n            // Ignore error\n            this.handleChildWriteCompleted(this.committedCallIndex);\n          }\n        }, message);\n      }\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.getNextBufferIndex();\n    this.writeBuffer.push({\n      entryType: 'HALF_CLOSE',\n      allocated: false\n    });\n    for (const call of this.underlyingCalls) {\n      if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' && call.nextMessageToSend === halfCloseIndex) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials) {\n    throw new Error('Method not implemented.');\n  }\n  getMethod() {\n    return this.methodName;\n  }\n  getHost() {\n    return this.host;\n  }\n}\nexports.RetryingCall = RetryingCall;","map":{"version":3,"names":["constants_1","require","deadline_1","metadata_1","logging","TRACER_NAME","RetryThrottler","constructor","maxTokens","tokenRatio","previousRetryThrottler","tokens","addCallSucceeded","Math","max","addCallFailed","min","canRetryCall","exports","MessageBufferTracker","totalLimit","limitPerCall","totalAllocated","allocatedPerCall","Map","allocate","size","callId","currentPerCall","_a","get","set","free","Error","freeAll","delete","PREVIONS_RPC_ATTEMPTS_METADATA_KEY","DEFAULT_MAX_ATTEMPTS_LIMIT","RetryingCall","channel","callConfig","methodName","host","credentials","deadline","callNumber","bufferTracker","retryThrottler","listener","initialMetadata","underlyingCalls","writeBuffer","writeBufferOffset","readStarted","transparentRetryUsed","attempts","hedgingTimer","committedCallIndex","initialRetryBackoffSec","nextRetryBackoffSec","maxAttemptsLimit","getOptions","methodConfig","retryPolicy","state","Number","initialBackoff","substring","length","maxAttempts","hedgingPolicy","startTime","Date","getDeadlineInfo","deadlineInfo","latestCall","push","formatDateDifference","call","getCallNumber","trace","text","LogVerbosity","DEBUG","reportStatus","statusObject","code","details","toISOString","process","nextTick","onReceiveStatus","metadata","cancelWithStatus","status","Metadata","getPeer","getBufferEntry","messageIndex","entryType","allocated","getNextBufferIndex","clearSentMessages","earliestNeededMessageIndex","nextMessageToSend","bufferEntry","message","slice","commitCall","index","i","Status","CANCELLED","commitCallWithMostMessages","mostMessages","callWithMostMessages","childCall","entries","isStatusCodeInList","list","some","value","toString","toLowerCase","getNextRetryBackoffMs","nextBackoffMs","random","maxBackoffSec","maxBackoff","backoffMultiplier","maybeRetryCall","pushback","callback","retryDelayMs","setTimeout","_b","startNewAttempt","countActiveCalls","count","handleProcessedStatus","callIndex","nonFatalStatusCodes","delayMs","maybeStartHedgingAttempt","retryableStatusCodes","_c","retried","getPushback","mdValue","parseInt","e","handleChildStatus","progress","OK","maybeStartHedgingTimer","clearTimeout","hedgingDelayString","hedgingDelay","hedgingDelaySec","unref","child","createLoadBalancingCall","previousAttempts","clone","receivedMetadata","start","onReceiveMetadata","onReceiveMessage","sendNextChildMessage","startRead","handleChildWriteCompleted","childIndex","sendMessageWithContext","error","halfClose","context","writeObj","flags","underlyingCall","halfCloseIndex","setCredentials","newCredentials","getMethod","getHost"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/retrying-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from './call-credentials';\nimport { LogVerbosity, Status } from './constants';\nimport { Deadline, formatDateDifference } from './deadline';\nimport { Metadata } from './metadata';\nimport { CallConfig } from './resolver';\nimport * as logging from './logging';\nimport {\n  Call,\n  DeadlineInfoProvider,\n  InterceptingListener,\n  MessageContext,\n  StatusObject,\n  WriteCallback,\n  WriteObject,\n} from './call-interface';\nimport {\n  LoadBalancingCall,\n  StatusObjectWithProgress,\n} from './load-balancing-call';\nimport { InternalChannel } from './internal-channel';\n\nconst TRACER_NAME = 'retrying_call';\n\nexport class RetryThrottler {\n  private tokens: number;\n  constructor(\n    private readonly maxTokens: number,\n    private readonly tokenRatio: number,\n    previousRetryThrottler?: RetryThrottler\n  ) {\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens =\n        previousRetryThrottler.tokens *\n        (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\n\nexport class MessageBufferTracker {\n  private totalAllocated = 0;\n  private allocatedPerCall: Map<number, number> = new Map<number, number>();\n\n  constructor(private totalLimit: number, private limitPerCall: number) {}\n\n  allocate(size: number, callId: number): boolean {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (\n      this.limitPerCall - currentPerCall < size ||\n      this.totalLimit - this.totalAllocated < size\n    ) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n\n  free(size: number, callId: number) {\n    if (this.totalAllocated < size) {\n      throw new Error(\n        `Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`\n      );\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (currentPerCall < size) {\n      throw new Error(\n        `Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`\n      );\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n\n  freeAll(callId: number) {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(\n        `Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`\n      );\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\n\ntype UnderlyingCallState = 'ACTIVE' | 'COMPLETED';\n\ninterface UnderlyingCall {\n  state: UnderlyingCallState;\n  call: LoadBalancingCall;\n  nextMessageToSend: number;\n  startTime: Date;\n}\n\n/**\n * A retrying call can be in one of these states:\n * RETRY: Retries are configured and new attempts may be sent\n * HEDGING: Hedging is configured and new attempts may be sent\n * TRANSPARENT_ONLY: Neither retries nor hedging are configured, and\n * transparent retry attempts may still be sent\n * COMMITTED: One attempt is committed, and no new attempts will be\n * sent\n */\ntype RetryingCallState = 'RETRY' | 'HEDGING' | 'TRANSPARENT_ONLY' | 'COMMITTED';\n\n/**\n * The different types of objects that can be stored in the write buffer, with\n * the following meanings:\n * MESSAGE: This is a message to be sent.\n * HALF_CLOSE: When this entry is reached, the calls should send a half-close.\n * FREED: This slot previously contained a message that has been sent on all\n * child calls and is no longer needed.\n */\ntype WriteBufferEntryType = 'MESSAGE' | 'HALF_CLOSE' | 'FREED';\n\n/**\n * Entry in the buffer of messages to send to the remote end.\n */\ninterface WriteBufferEntry {\n  entryType: WriteBufferEntryType;\n  /**\n   * Message to send.\n   * Only populated if entryType is MESSAGE.\n   */\n  message?: WriteObject;\n  /**\n   * Callback to call after sending the message.\n   * Only populated if entryType is MESSAGE and the call is in the COMMITTED\n   * state.\n   */\n  callback?: WriteCallback;\n  /**\n   * Indicates whether the message is allocated in the buffer tracker. Ignored\n   * if entryType is not MESSAGE. Should be the return value of\n   * bufferTracker.allocate.\n   */\n  allocated: boolean;\n}\n\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\n\nconst DEFAULT_MAX_ATTEMPTS_LIMIT = 5;\n\nexport class RetryingCall implements Call, DeadlineInfoProvider {\n  private state: RetryingCallState;\n  private listener: InterceptingListener | null = null;\n  private initialMetadata: Metadata | null = null;\n  private underlyingCalls: UnderlyingCall[] = [];\n  private writeBuffer: WriteBufferEntry[] = [];\n  /**\n   * The offset of message indices in the writeBuffer. For example, if\n   * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n   * is in writeBuffer[5].\n   */\n  private writeBufferOffset = 0;\n  /**\n   * Tracks whether a read has been started, so that we know whether to start\n   * reads on new child calls. This only matters for the first read, because\n   * once a message comes in the child call becomes committed and there will\n   * be no new child calls.\n   */\n  private readStarted = false;\n  private transparentRetryUsed = false;\n  /**\n   * Number of attempts so far\n   */\n  private attempts = 0;\n  private hedgingTimer: NodeJS.Timeout | null = null;\n  private committedCallIndex: number | null = null;\n  private initialRetryBackoffSec = 0;\n  private nextRetryBackoffSec = 0;\n  private startTime: Date;\n  private maxAttempts: number;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host: string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number,\n    private readonly bufferTracker: MessageBufferTracker,\n    private readonly retryThrottler?: RetryThrottler\n  ) {\n    const maxAttemptsLimit = channel.getOptions()['grpc-node.retry_max_attempts_limit'] ?? DEFAULT_MAX_ATTEMPTS_LIMIT;\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(\n        retryPolicy.initialBackoff.substring(\n          0,\n          retryPolicy.initialBackoff.length - 1\n        )\n      );\n      this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n      this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n      this.maxAttempts = 1;\n    }\n    this.startTime = new Date();\n  }\n  getDeadlineInfo(): string[] {\n    if (this.underlyingCalls.length === 0) {\n      return [];\n    }\n    const deadlineInfo: string[] = [];\n    const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];\n    if (this.underlyingCalls.length > 1) {\n      deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);\n    }\n    if (latestCall.startTime > this.startTime) {\n      deadlineInfo.push(`time to current attempt start: ${formatDateDifference(this.startTime, latestCall.startTime)}`);\n    }\n    deadlineInfo.push(...latestCall.call.getDeadlineInfo());\n    return deadlineInfo;\n  }\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private reportStatus(statusObject: StatusObject) {\n    this.trace(\n      'ended with status: code=' +\n        statusObject.code +\n        ' details=\"' +\n        statusObject.details +\n        '\" start time=' +\n        this.startTime.toISOString()\n    );\n    this.bufferTracker.freeAll(this.callNumber);\n    this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n    this.writeBuffer = [];\n    process.nextTick(() => {\n      // Explicitly construct status object to remove progress field\n      this.listener?.onReceiveStatus({\n        code: statusObject.code,\n        details: statusObject.details,\n        metadata: statusObject.metadata,\n      });\n    });\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.reportStatus({ code: status, details, metadata: new Metadata() });\n    for (const { call } of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer(): string {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n\n  private getBufferEntry(messageIndex: number): WriteBufferEntry {\n    return (\n      this.writeBuffer[messageIndex - this.writeBufferOffset] ?? {\n        entryType: 'FREED',\n        allocated: false,\n      }\n    );\n  }\n\n  private getNextBufferIndex() {\n    return this.writeBufferOffset + this.writeBuffer.length;\n  }\n\n  private clearSentMessages() {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const earliestNeededMessageIndex =\n      this.underlyingCalls[this.committedCallIndex!].nextMessageToSend;\n    for (\n      let messageIndex = this.writeBufferOffset;\n      messageIndex < earliestNeededMessageIndex;\n      messageIndex++\n    ) {\n      const bufferEntry = this.getBufferEntry(messageIndex);\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(\n          bufferEntry.message!.message.length,\n          this.callNumber\n        );\n      }\n    }\n    this.writeBuffer = this.writeBuffer.slice(\n      earliestNeededMessageIndex - this.writeBufferOffset\n    );\n    this.writeBufferOffset = earliestNeededMessageIndex;\n  }\n\n  private commitCall(index: number) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace(\n      'Committing call [' +\n        this.underlyingCalls[index].call.getCallNumber() +\n        '] at index ' +\n        index\n    );\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(\n        Status.CANCELLED,\n        'Discarded in favor of other hedged attempt'\n      );\n    }\n    this.clearSentMessages();\n  }\n\n  private commitCallWithMostMessages() {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (\n        childCall.state === 'ACTIVE' &&\n        childCall.nextMessageToSend > mostMessages\n      ) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    if (callWithMostMessages === -1) {\n      /* There are no active calls, disable retries to force the next call that\n       * is started to be committed. */\n      this.state = 'TRANSPARENT_ONLY';\n    } else {\n      this.commitCall(callWithMostMessages);\n    }\n  }\n\n  private isStatusCodeInList(list: (Status | string)[], code: Status) {\n    return list.some(\n      value =>\n        value === code ||\n        value.toString().toLowerCase() === Status[code]?.toLowerCase()\n    );\n  }\n\n  private getNextRetryBackoffMs() {\n    const retryPolicy = this.callConfig?.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(\n      retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1)\n    );\n    this.nextRetryBackoffSec = Math.min(\n      this.nextRetryBackoffSec * retryPolicy.backoffMultiplier,\n      maxBackoffSec\n    );\n    return nextBackoffMs;\n  }\n\n  private maybeRetryCall(\n    pushback: number | null,\n    callback: (retried: boolean) => void\n  ) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    if (this.attempts >= this.maxAttempts) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs: number;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if (this.retryThrottler?.canRetryCall() ?? true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n\n  private countActiveCalls(): number {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if (call?.state === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  private handleProcessedStatus(\n    status: StatusObject,\n    callIndex: number,\n    pushback: number | null\n  ) {\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (\n          this.isStatusCodeInList(\n            this.callConfig!.methodConfig.hedgingPolicy!.nonFatalStatusCodes ??\n              [],\n            status.code\n          )\n        ) {\n          this.retryThrottler?.addCallFailed();\n          let delayMs: number;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (\n          this.isStatusCodeInList(\n            this.callConfig!.methodConfig.retryPolicy!.retryableStatusCodes,\n            status.code\n          )\n        ) {\n          this.retryThrottler?.addCallFailed();\n          this.maybeRetryCall(pushback, retried => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n\n  private getPushback(metadata: Metadata): number | null {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0] as string);\n    } catch (e) {\n      return -1;\n    }\n  }\n\n  private handleChildStatus(\n    status: StatusObjectWithProgress,\n    callIndex: number\n  ) {\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace(\n      'state=' +\n        this.state +\n        ' handling status with progress ' +\n        status.progress +\n        ' from child [' +\n        this.underlyingCalls[callIndex].call.getCallNumber() +\n        '] in state ' +\n        this.underlyingCalls[callIndex].state\n    );\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === Status.OK) {\n      this.retryThrottler?.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        }\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n\n  private maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    if (this.attempts >= this.maxAttempts) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private maybeStartHedgingTimer() {\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= this.maxAttempts) {\n      return;\n    }\n    const hedgingDelayString = hedgingPolicy.hedgingDelay ?? '0s';\n    const hedgingDelaySec = Number(\n      hedgingDelayString.substring(0, hedgingDelayString.length - 1)\n    );\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    this.hedgingTimer.unref?.();\n  }\n\n  private startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(\n      this.callConfig,\n      this.methodName,\n      this.host,\n      this.credentials,\n      this.deadline\n    );\n    this.trace(\n      'Created child call [' +\n        child.getCallNumber() +\n        '] for attempt ' +\n        this.attempts\n    );\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({\n      state: 'ACTIVE',\n      call: child,\n      nextMessageToSend: 0,\n      startTime: new Date()\n    });\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata!.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(\n        PREVIONS_RPC_ATTEMPTS_METADATA_KEY,\n        `${previousAttempts}`\n      );\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace(\n          'Received metadata from child [' + child.getCallNumber() + ']'\n        );\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(\n            PREVIONS_RPC_ATTEMPTS_METADATA_KEY,\n            `${previousAttempts}`\n          );\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace(\n          'Received message from child [' + child.getCallNumber() + ']'\n        );\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace(\n          'Received status from child [' + child.getCallNumber() + ']'\n        );\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(\n            PREVIONS_RPC_ATTEMPTS_METADATA_KEY,\n            `${previousAttempts}`\n          );\n        }\n        this.handleChildStatus(status, index);\n      },\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n\n  start(metadata: Metadata, listener: InterceptingListener): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private handleChildWriteCompleted(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    this.getBufferEntry(messageIndex).callback?.();\n    this.clearSentMessages();\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n\n  private sendNextChildMessage(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.getBufferEntry(childCall.nextMessageToSend)) {\n      const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE':\n          childCall.call.sendMessageWithContext(\n            {\n              callback: error => {\n                // Ignore error\n                this.handleChildWriteCompleted(childIndex);\n              },\n            },\n            bufferEntry.message!.message\n          );\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj: WriteObject = {\n      message,\n      flags: context.flags,\n    };\n    const messageIndex = this.getNextBufferIndex();\n    const bufferEntry: WriteBufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber),\n    };\n    this.writeBuffer.push(bufferEntry);\n    if (bufferEntry.allocated) {\n      context.callback?.();\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (\n          call.state === 'ACTIVE' &&\n          call.nextMessageToSend === messageIndex\n        ) {\n          call.call.sendMessageWithContext(\n            {\n              callback: error => {\n                // Ignore error\n                this.handleChildWriteCompleted(callIndex);\n              },\n            },\n            message\n          );\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      // commitCallWithMostMessages can fail if we are between ping attempts\n      if (this.committedCallIndex === null) {\n        return;\n      }\n      const call = this.underlyingCalls[this.committedCallIndex];\n      bufferEntry.callback = context.callback;\n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext(\n          {\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(this.committedCallIndex!);\n            },\n          },\n          message\n        );\n      }\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if (underlyingCall?.state === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.getNextBufferIndex();\n    this.writeBuffer.push({\n      entryType: 'HALF_CLOSE',\n      allocated: false,\n    });\n    for (const call of this.underlyingCalls) {\n      if (\n        call?.state === 'ACTIVE' &&\n        call.nextMessageToSend === halfCloseIndex\n      ) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials: CallCredentials): void {\n    throw new Error('Method not implemented.');\n  }\n  getMethod(): string {\n    return this.methodName;\n  }\n  getHost(): string {\n    return this.host;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}