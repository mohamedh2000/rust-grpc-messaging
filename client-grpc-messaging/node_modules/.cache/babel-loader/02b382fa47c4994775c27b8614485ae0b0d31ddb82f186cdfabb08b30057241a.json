{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = exports.validateRetryThrottling = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\nfunction validateName(obj) {\n  // In this context, and unset field and '' are considered the same\n  if ('service' in obj && obj.service !== '') {\n    if (typeof obj.service !== 'string') {\n      throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\n    }\n    if ('method' in obj && obj.method !== '') {\n      if (typeof obj.method !== 'string') {\n        throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\n      }\n      return {\n        service: obj.service,\n        method: obj.method\n      };\n    } else {\n      return {\n        service: obj.service\n      };\n    }\n  } else {\n    if ('method' in obj && obj.method !== undefined) {\n      throw new Error(`Invalid method config name: method set with empty or unset service`);\n    }\n    return {};\n  }\n}\nfunction validateRetryPolicy(obj) {\n  if (!('maxAttempts' in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n    throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');\n  }\n  if (!('initialBackoff' in obj) || typeof obj.initialBackoff !== 'string' || !DURATION_REGEX.test(obj.initialBackoff)) {\n    throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s');\n  }\n  if (!('maxBackoff' in obj) || typeof obj.maxBackoff !== 'string' || !DURATION_REGEX.test(obj.maxBackoff)) {\n    throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s');\n  }\n  if (!('backoffMultiplier' in obj) || typeof obj.backoffMultiplier !== 'number' || obj.backoffMultiplier <= 0) {\n    throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');\n  }\n  if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {\n    throw new Error('Invalid method config retry policy: retryableStatusCodes is required');\n  }\n  if (obj.retryableStatusCodes.length === 0) {\n    throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');\n  }\n  for (const value of obj.retryableStatusCodes) {\n    if (typeof value === 'number') {\n      if (!Object.values(constants_1.Status).includes(value)) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');\n      }\n    } else if (typeof value === 'string') {\n      if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');\n      }\n    } else {\n      throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');\n    }\n  }\n  return {\n    maxAttempts: obj.maxAttempts,\n    initialBackoff: obj.initialBackoff,\n    maxBackoff: obj.maxBackoff,\n    backoffMultiplier: obj.backoffMultiplier,\n    retryableStatusCodes: obj.retryableStatusCodes\n  };\n}\nfunction validateHedgingPolicy(obj) {\n  if (!('maxAttempts' in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n    throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');\n  }\n  if ('hedgingDelay' in obj && (typeof obj.hedgingDelay !== 'string' || !DURATION_REGEX.test(obj.hedgingDelay))) {\n    throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');\n  }\n  if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n    for (const value of obj.nonFatalStatusCodes) {\n      if (typeof value === 'number') {\n        if (!Object.values(constants_1.Status).includes(value)) {\n          throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not in status code range');\n        }\n      } else if (typeof value === 'string') {\n        if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n          throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not a status code name');\n        }\n      } else {\n        throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number');\n      }\n    }\n  }\n  const result = {\n    maxAttempts: obj.maxAttempts\n  };\n  if (obj.hedgingDelay) {\n    result.hedgingDelay = obj.hedgingDelay;\n  }\n  if (obj.nonFatalStatusCodes) {\n    result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n  }\n  return result;\n}\nfunction validateMethodConfig(obj) {\n  var _a;\n  const result = {\n    name: []\n  };\n  if (!('name' in obj) || !Array.isArray(obj.name)) {\n    throw new Error('Invalid method config: invalid name array');\n  }\n  for (const name of obj.name) {\n    result.name.push(validateName(name));\n  }\n  if ('waitForReady' in obj) {\n    if (typeof obj.waitForReady !== 'boolean') {\n      throw new Error('Invalid method config: invalid waitForReady');\n    }\n    result.waitForReady = obj.waitForReady;\n  }\n  if ('timeout' in obj) {\n    if (typeof obj.timeout === 'object') {\n      if (!('seconds' in obj.timeout) || !(typeof obj.timeout.seconds === 'number')) {\n        throw new Error('Invalid method config: invalid timeout.seconds');\n      }\n      if (!('nanos' in obj.timeout) || !(typeof obj.timeout.nanos === 'number')) {\n        throw new Error('Invalid method config: invalid timeout.nanos');\n      }\n      result.timeout = obj.timeout;\n    } else if (typeof obj.timeout === 'string' && DURATION_REGEX.test(obj.timeout)) {\n      const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split('.');\n      result.timeout = {\n        seconds: timeoutParts[0] | 0,\n        nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0\n      };\n    } else {\n      throw new Error('Invalid method config: invalid timeout');\n    }\n  }\n  if ('maxRequestBytes' in obj) {\n    if (typeof obj.maxRequestBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxRequestBytes = obj.maxRequestBytes;\n  }\n  if ('maxResponseBytes' in obj) {\n    if (typeof obj.maxResponseBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxResponseBytes = obj.maxResponseBytes;\n  }\n  if ('retryPolicy' in obj) {\n    if ('hedgingPolicy' in obj) {\n      throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');\n    } else {\n      result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n    }\n  } else if ('hedgingPolicy' in obj) {\n    result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n  }\n  return result;\n}\nfunction validateRetryThrottling(obj) {\n  if (!('maxTokens' in obj) || typeof obj.maxTokens !== 'number' || obj.maxTokens <= 0 || obj.maxTokens > 1000) {\n    throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');\n  }\n  if (!('tokenRatio' in obj) || typeof obj.tokenRatio !== 'number' || obj.tokenRatio <= 0) {\n    throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');\n  }\n  return {\n    maxTokens: +obj.maxTokens.toFixed(3),\n    tokenRatio: +obj.tokenRatio.toFixed(3)\n  };\n}\nexports.validateRetryThrottling = validateRetryThrottling;\nfunction validateLoadBalancingConfig(obj) {\n  if (!(typeof obj === 'object' && obj !== null)) {\n    throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);\n  }\n  const keys = Object.keys(obj);\n  if (keys.length > 1) {\n    throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);\n  }\n  if (keys.length === 0) {\n    throw new Error('Invalid loadBalancingConfig: load balancing policy name required');\n  }\n  return {\n    [keys[0]]: obj[keys[0]]\n  };\n}\nfunction validateServiceConfig(obj) {\n  const result = {\n    loadBalancingConfig: [],\n    methodConfig: []\n  };\n  if ('loadBalancingPolicy' in obj) {\n    if (typeof obj.loadBalancingPolicy === 'string') {\n      result.loadBalancingPolicy = obj.loadBalancingPolicy;\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingPolicy');\n    }\n  }\n  if ('loadBalancingConfig' in obj) {\n    if (Array.isArray(obj.loadBalancingConfig)) {\n      for (const config of obj.loadBalancingConfig) {\n        result.loadBalancingConfig.push(validateLoadBalancingConfig(config));\n      }\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingConfig');\n    }\n  }\n  if ('methodConfig' in obj) {\n    if (Array.isArray(obj.methodConfig)) {\n      for (const methodConfig of obj.methodConfig) {\n        result.methodConfig.push(validateMethodConfig(methodConfig));\n      }\n    }\n  }\n  if ('retryThrottling' in obj) {\n    result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n  }\n  // Validate method name uniqueness\n  const seenMethodNames = [];\n  for (const methodConfig of result.methodConfig) {\n    for (const name of methodConfig.name) {\n      for (const seenName of seenMethodNames) {\n        if (name.service === seenName.service && name.method === seenName.method) {\n          throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n        }\n      }\n      seenMethodNames.push(name);\n    }\n  }\n  return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n  if (!('serviceConfig' in obj)) {\n    throw new Error('Invalid service config choice: missing service config');\n  }\n  const result = {\n    serviceConfig: validateServiceConfig(obj.serviceConfig)\n  };\n  if ('clientLanguage' in obj) {\n    if (Array.isArray(obj.clientLanguage)) {\n      result.clientLanguage = [];\n      for (const lang of obj.clientLanguage) {\n        if (typeof lang === 'string') {\n          result.clientLanguage.push(lang);\n        } else {\n          throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientLanguage');\n    }\n  }\n  if ('clientHostname' in obj) {\n    if (Array.isArray(obj.clientHostname)) {\n      result.clientHostname = [];\n      for (const lang of obj.clientHostname) {\n        if (typeof lang === 'string') {\n          result.clientHostname.push(lang);\n        } else {\n          throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientHostname');\n    }\n  }\n  if ('percentage' in obj) {\n    if (typeof obj.percentage === 'number' && 0 <= obj.percentage && obj.percentage <= 100) {\n      result.percentage = obj.percentage;\n    } else {\n      throw new Error('Invalid service config choice: invalid percentage');\n    }\n  }\n  // Validate that no unexpected fields are present\n  const allowedFields = ['clientLanguage', 'percentage', 'clientHostname', 'serviceConfig'];\n  for (const field in obj) {\n    if (!allowedFields.includes(field)) {\n      throw new Error(`Invalid service config choice: unexpected field ${field}`);\n    }\n  }\n  return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n  if (!Array.isArray(obj)) {\n    throw new Error('Invalid service config list');\n  }\n  for (const config of obj) {\n    const validatedConfig = validateCanaryConfig(config);\n    /* For each field, we check if it is present, then only discard the\n     * config if the field value does not match the current client */\n    if (typeof validatedConfig.percentage === 'number' && percentage > validatedConfig.percentage) {\n      continue;\n    }\n    if (Array.isArray(validatedConfig.clientHostname)) {\n      let hostnameMatched = false;\n      for (const hostname of validatedConfig.clientHostname) {\n        if (hostname === os.hostname()) {\n          hostnameMatched = true;\n        }\n      }\n      if (!hostnameMatched) {\n        continue;\n      }\n    }\n    if (Array.isArray(validatedConfig.clientLanguage)) {\n      let languageMatched = false;\n      for (const language of validatedConfig.clientLanguage) {\n        if (language === CLIENT_LANGUAGE_STRING) {\n          languageMatched = true;\n        }\n      }\n      if (!languageMatched) {\n        continue;\n      }\n    }\n    return validatedConfig.serviceConfig;\n  }\n  throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n  for (const record of txtRecord) {\n    if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n      /* Treat the list of strings in this record as a single string and remove\n       * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n      const recordString = record.join('').substring('grpc_config='.length);\n      const recordJson = JSON.parse(recordString);\n      return validateAndSelectCanaryConfig(recordJson, percentage);\n    }\n  }\n  return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;","map":{"version":3,"names":["os","require","constants_1","DURATION_REGEX","CLIENT_LANGUAGE_STRING","validateName","obj","service","Error","method","undefined","validateRetryPolicy","Number","isInteger","maxAttempts","initialBackoff","test","maxBackoff","backoffMultiplier","Array","isArray","retryableStatusCodes","length","value","Object","values","Status","includes","toUpperCase","validateHedgingPolicy","hedgingDelay","nonFatalStatusCodes","result","validateMethodConfig","name","push","waitForReady","timeout","seconds","nanos","timeoutParts","substring","split","_a","maxRequestBytes","maxResponseBytes","retryPolicy","hedgingPolicy","validateRetryThrottling","maxTokens","tokenRatio","toFixed","exports","validateLoadBalancingConfig","keys","validateServiceConfig","loadBalancingConfig","methodConfig","loadBalancingPolicy","config","retryThrottling","seenMethodNames","seenName","validateCanaryConfig","serviceConfig","clientLanguage","lang","clientHostname","percentage","allowedFields","field","validateAndSelectCanaryConfig","validatedConfig","hostnameMatched","hostname","languageMatched","language","extractAndSelectServiceConfig","txtRecord","record","startsWith","recordString","join","recordJson","JSON","parse"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/service-config.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport * as os from 'os';\nimport { Status } from './constants';\nimport { Duration } from './duration';\n\nexport interface MethodConfigName {\n  service?: string;\n  method?: string;\n}\n\nexport interface RetryPolicy {\n  maxAttempts: number;\n  initialBackoff: string;\n  maxBackoff: string;\n  backoffMultiplier: number;\n  retryableStatusCodes: (Status | string)[];\n}\n\nexport interface HedgingPolicy {\n  maxAttempts: number;\n  hedgingDelay?: string;\n  nonFatalStatusCodes?: (Status | string)[];\n}\n\nexport interface MethodConfig {\n  name: MethodConfigName[];\n  waitForReady?: boolean;\n  timeout?: Duration;\n  maxRequestBytes?: number;\n  maxResponseBytes?: number;\n  retryPolicy?: RetryPolicy;\n  hedgingPolicy?: HedgingPolicy;\n}\n\nexport interface RetryThrottling {\n  maxTokens: number;\n  tokenRatio: number;\n}\n\nexport interface LoadBalancingConfig {\n  [key: string]: object;\n}\n\nexport interface ServiceConfig {\n  loadBalancingPolicy?: string;\n  loadBalancingConfig: LoadBalancingConfig[];\n  methodConfig: MethodConfig[];\n  retryThrottling?: RetryThrottling;\n}\n\nexport interface ServiceConfigCanaryConfig {\n  clientLanguage?: string[];\n  percentage?: number;\n  clientHostname?: string[];\n  serviceConfig: ServiceConfig;\n}\n\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\n\nfunction validateName(obj: any): MethodConfigName {\n  // In this context, and unset field and '' are considered the same\n  if ('service' in obj && obj.service !== '') {\n    if (typeof obj.service !== 'string') {\n      throw new Error(\n        `Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`\n      );\n    }\n    if ('method' in obj && obj.method !== '') {\n      if (typeof obj.method !== 'string') {\n        throw new Error(\n          `Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`\n        );\n      }\n      return {\n        service: obj.service,\n        method: obj.method,\n      };\n    } else {\n      return {\n        service: obj.service,\n      };\n    }\n  } else {\n    if ('method' in obj && obj.method !== undefined) {\n      throw new Error(\n        `Invalid method config name: method set with empty or unset service`\n      );\n    }\n    return {};\n  }\n}\n\nfunction validateRetryPolicy(obj: any): RetryPolicy {\n  if (\n    !('maxAttempts' in obj) ||\n    !Number.isInteger(obj.maxAttempts) ||\n    obj.maxAttempts < 2\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: maxAttempts must be an integer at least 2'\n    );\n  }\n  if (\n    !('initialBackoff' in obj) ||\n    typeof obj.initialBackoff !== 'string' ||\n    !DURATION_REGEX.test(obj.initialBackoff)\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s'\n    );\n  }\n  if (\n    !('maxBackoff' in obj) ||\n    typeof obj.maxBackoff !== 'string' ||\n    !DURATION_REGEX.test(obj.maxBackoff)\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s'\n    );\n  }\n  if (\n    !('backoffMultiplier' in obj) ||\n    typeof obj.backoffMultiplier !== 'number' ||\n    obj.backoffMultiplier <= 0\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: backoffMultiplier must be a number greater than 0'\n    );\n  }\n  if (\n    !('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: retryableStatusCodes is required'\n    );\n  }\n  if (obj.retryableStatusCodes.length === 0) {\n    throw new Error(\n      'Invalid method config retry policy: retryableStatusCodes must be non-empty'\n    );\n  }\n  for (const value of obj.retryableStatusCodes) {\n    if (typeof value === 'number') {\n      if (!Object.values(Status).includes(value)) {\n        throw new Error(\n          'Invalid method config retry policy: retryableStatusCodes value not in status code range'\n        );\n      }\n    } else if (typeof value === 'string') {\n      if (!Object.values(Status).includes(value.toUpperCase())) {\n        throw new Error(\n          'Invalid method config retry policy: retryableStatusCodes value not a status code name'\n        );\n      }\n    } else {\n      throw new Error(\n        'Invalid method config retry policy: retryableStatusCodes value must be a string or number'\n      );\n    }\n  }\n  return {\n    maxAttempts: obj.maxAttempts,\n    initialBackoff: obj.initialBackoff,\n    maxBackoff: obj.maxBackoff,\n    backoffMultiplier: obj.backoffMultiplier,\n    retryableStatusCodes: obj.retryableStatusCodes,\n  };\n}\n\nfunction validateHedgingPolicy(obj: any): HedgingPolicy {\n  if (\n    !('maxAttempts' in obj) ||\n    !Number.isInteger(obj.maxAttempts) ||\n    obj.maxAttempts < 2\n  ) {\n    throw new Error(\n      'Invalid method config hedging policy: maxAttempts must be an integer at least 2'\n    );\n  }\n  if (\n    'hedgingDelay' in obj &&\n    (typeof obj.hedgingDelay !== 'string' ||\n      !DURATION_REGEX.test(obj.hedgingDelay))\n  ) {\n    throw new Error(\n      'Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s'\n    );\n  }\n  if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n    for (const value of obj.nonFatalStatusCodes) {\n      if (typeof value === 'number') {\n        if (!Object.values(Status).includes(value)) {\n          throw new Error(\n            'Invalid method config hedging policy: nonFatalStatusCodes value not in status code range'\n          );\n        }\n      } else if (typeof value === 'string') {\n        if (!Object.values(Status).includes(value.toUpperCase())) {\n          throw new Error(\n            'Invalid method config hedging policy: nonFatalStatusCodes value not a status code name'\n          );\n        }\n      } else {\n        throw new Error(\n          'Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number'\n        );\n      }\n    }\n  }\n  const result: HedgingPolicy = {\n    maxAttempts: obj.maxAttempts,\n  };\n  if (obj.hedgingDelay) {\n    result.hedgingDelay = obj.hedgingDelay;\n  }\n  if (obj.nonFatalStatusCodes) {\n    result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n  }\n  return result;\n}\n\nfunction validateMethodConfig(obj: any): MethodConfig {\n  const result: MethodConfig = {\n    name: [],\n  };\n  if (!('name' in obj) || !Array.isArray(obj.name)) {\n    throw new Error('Invalid method config: invalid name array');\n  }\n  for (const name of obj.name) {\n    result.name.push(validateName(name));\n  }\n  if ('waitForReady' in obj) {\n    if (typeof obj.waitForReady !== 'boolean') {\n      throw new Error('Invalid method config: invalid waitForReady');\n    }\n    result.waitForReady = obj.waitForReady;\n  }\n  if ('timeout' in obj) {\n    if (typeof obj.timeout === 'object') {\n      if (\n        !('seconds' in obj.timeout) ||\n        !(typeof obj.timeout.seconds === 'number')\n      ) {\n        throw new Error('Invalid method config: invalid timeout.seconds');\n      }\n      if (\n        !('nanos' in obj.timeout) ||\n        !(typeof obj.timeout.nanos === 'number')\n      ) {\n        throw new Error('Invalid method config: invalid timeout.nanos');\n      }\n      result.timeout = obj.timeout;\n    } else if (\n      typeof obj.timeout === 'string' &&\n      DURATION_REGEX.test(obj.timeout)\n    ) {\n      const timeoutParts = obj.timeout\n        .substring(0, obj.timeout.length - 1)\n        .split('.');\n      result.timeout = {\n        seconds: timeoutParts[0] | 0,\n        nanos: (timeoutParts[1] ?? 0) | 0,\n      };\n    } else {\n      throw new Error('Invalid method config: invalid timeout');\n    }\n  }\n  if ('maxRequestBytes' in obj) {\n    if (typeof obj.maxRequestBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxRequestBytes = obj.maxRequestBytes;\n  }\n  if ('maxResponseBytes' in obj) {\n    if (typeof obj.maxResponseBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxResponseBytes = obj.maxResponseBytes;\n  }\n  if ('retryPolicy' in obj) {\n    if ('hedgingPolicy' in obj) {\n      throw new Error(\n        'Invalid method config: retryPolicy and hedgingPolicy cannot both be specified'\n      );\n    } else {\n      result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n    }\n  } else if ('hedgingPolicy' in obj) {\n    result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n  }\n  return result;\n}\n\nexport function validateRetryThrottling(obj: any): RetryThrottling {\n  if (\n    !('maxTokens' in obj) ||\n    typeof obj.maxTokens !== 'number' ||\n    obj.maxTokens <= 0 ||\n    obj.maxTokens > 1000\n  ) {\n    throw new Error(\n      'Invalid retryThrottling: maxTokens must be a number in (0, 1000]'\n    );\n  }\n  if (\n    !('tokenRatio' in obj) ||\n    typeof obj.tokenRatio !== 'number' ||\n    obj.tokenRatio <= 0\n  ) {\n    throw new Error(\n      'Invalid retryThrottling: tokenRatio must be a number greater than 0'\n    );\n  }\n  return {\n    maxTokens: +(obj.maxTokens as number).toFixed(3),\n    tokenRatio: +(obj.tokenRatio as number).toFixed(3),\n  };\n}\n\nfunction validateLoadBalancingConfig(obj: any): LoadBalancingConfig {\n  if (!(typeof obj === 'object' && obj !== null)) {\n    throw new Error(\n      `Invalid loadBalancingConfig: unexpected type ${typeof obj}`\n    );\n  }\n  const keys = Object.keys(obj);\n  if (keys.length > 1) {\n    throw new Error(\n      `Invalid loadBalancingConfig: unexpected multiple keys ${keys}`\n    );\n  }\n  if (keys.length === 0) {\n    throw new Error(\n      'Invalid loadBalancingConfig: load balancing policy name required'\n    );\n  }\n  return {\n    [keys[0]]: obj[keys[0]],\n  };\n}\n\nexport function validateServiceConfig(obj: any): ServiceConfig {\n  const result: ServiceConfig = {\n    loadBalancingConfig: [],\n    methodConfig: [],\n  };\n  if ('loadBalancingPolicy' in obj) {\n    if (typeof obj.loadBalancingPolicy === 'string') {\n      result.loadBalancingPolicy = obj.loadBalancingPolicy;\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingPolicy');\n    }\n  }\n  if ('loadBalancingConfig' in obj) {\n    if (Array.isArray(obj.loadBalancingConfig)) {\n      for (const config of obj.loadBalancingConfig) {\n        result.loadBalancingConfig.push(validateLoadBalancingConfig(config));\n      }\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingConfig');\n    }\n  }\n  if ('methodConfig' in obj) {\n    if (Array.isArray(obj.methodConfig)) {\n      for (const methodConfig of obj.methodConfig) {\n        result.methodConfig.push(validateMethodConfig(methodConfig));\n      }\n    }\n  }\n  if ('retryThrottling' in obj) {\n    result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n  }\n  // Validate method name uniqueness\n  const seenMethodNames: MethodConfigName[] = [];\n  for (const methodConfig of result.methodConfig) {\n    for (const name of methodConfig.name) {\n      for (const seenName of seenMethodNames) {\n        if (\n          name.service === seenName.service &&\n          name.method === seenName.method\n        ) {\n          throw new Error(\n            `Invalid service config: duplicate name ${name.service}/${name.method}`\n          );\n        }\n      }\n      seenMethodNames.push(name);\n    }\n  }\n  return result;\n}\n\nfunction validateCanaryConfig(obj: any): ServiceConfigCanaryConfig {\n  if (!('serviceConfig' in obj)) {\n    throw new Error('Invalid service config choice: missing service config');\n  }\n  const result: ServiceConfigCanaryConfig = {\n    serviceConfig: validateServiceConfig(obj.serviceConfig),\n  };\n  if ('clientLanguage' in obj) {\n    if (Array.isArray(obj.clientLanguage)) {\n      result.clientLanguage = [];\n      for (const lang of obj.clientLanguage) {\n        if (typeof lang === 'string') {\n          result.clientLanguage.push(lang);\n        } else {\n          throw new Error(\n            'Invalid service config choice: invalid clientLanguage'\n          );\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientLanguage');\n    }\n  }\n  if ('clientHostname' in obj) {\n    if (Array.isArray(obj.clientHostname)) {\n      result.clientHostname = [];\n      for (const lang of obj.clientHostname) {\n        if (typeof lang === 'string') {\n          result.clientHostname.push(lang);\n        } else {\n          throw new Error(\n            'Invalid service config choice: invalid clientHostname'\n          );\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientHostname');\n    }\n  }\n  if ('percentage' in obj) {\n    if (\n      typeof obj.percentage === 'number' &&\n      0 <= obj.percentage &&\n      obj.percentage <= 100\n    ) {\n      result.percentage = obj.percentage;\n    } else {\n      throw new Error('Invalid service config choice: invalid percentage');\n    }\n  }\n  // Validate that no unexpected fields are present\n  const allowedFields = [\n    'clientLanguage',\n    'percentage',\n    'clientHostname',\n    'serviceConfig',\n  ];\n  for (const field in obj) {\n    if (!allowedFields.includes(field)) {\n      throw new Error(\n        `Invalid service config choice: unexpected field ${field}`\n      );\n    }\n  }\n  return result;\n}\n\nfunction validateAndSelectCanaryConfig(\n  obj: any,\n  percentage: number\n): ServiceConfig {\n  if (!Array.isArray(obj)) {\n    throw new Error('Invalid service config list');\n  }\n  for (const config of obj) {\n    const validatedConfig = validateCanaryConfig(config);\n    /* For each field, we check if it is present, then only discard the\n     * config if the field value does not match the current client */\n    if (\n      typeof validatedConfig.percentage === 'number' &&\n      percentage > validatedConfig.percentage\n    ) {\n      continue;\n    }\n    if (Array.isArray(validatedConfig.clientHostname)) {\n      let hostnameMatched = false;\n      for (const hostname of validatedConfig.clientHostname) {\n        if (hostname === os.hostname()) {\n          hostnameMatched = true;\n        }\n      }\n      if (!hostnameMatched) {\n        continue;\n      }\n    }\n    if (Array.isArray(validatedConfig.clientLanguage)) {\n      let languageMatched = false;\n      for (const language of validatedConfig.clientLanguage) {\n        if (language === CLIENT_LANGUAGE_STRING) {\n          languageMatched = true;\n        }\n      }\n      if (!languageMatched) {\n        continue;\n      }\n    }\n    return validatedConfig.serviceConfig;\n  }\n  throw new Error('No matching service config found');\n}\n\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nexport function extractAndSelectServiceConfig(\n  txtRecord: string[][],\n  percentage: number\n): ServiceConfig | null {\n  for (const record of txtRecord) {\n    if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n      /* Treat the list of strings in this record as a single string and remove\n       * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n      const recordString = record.join('').substring('grpc_config='.length);\n      const recordJson: any = JSON.parse(recordString);\n      return validateAndSelectCanaryConfig(recordJson, percentage);\n    }\n  }\n  return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}