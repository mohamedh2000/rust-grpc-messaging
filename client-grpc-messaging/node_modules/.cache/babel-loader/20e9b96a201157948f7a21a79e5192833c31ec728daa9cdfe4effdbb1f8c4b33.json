{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n  constructor(child) {\n    this.child = child;\n    this.healthy = true;\n    this.healthListeners = new Set();\n    child.addHealthStateWatcher(childHealthy => {\n      /* A change to the child health state only affects this wrapper's overall\n       * health state if this wrapper is reporting healthy. */\n      if (this.healthy) {\n        this.updateHealthListeners();\n      }\n    });\n  }\n  updateHealthListeners() {\n    for (const listener of this.healthListeners) {\n      listener(this.isHealthy());\n    }\n  }\n  getConnectivityState() {\n    return this.child.getConnectivityState();\n  }\n  addConnectivityStateListener(listener) {\n    this.child.addConnectivityStateListener(listener);\n  }\n  removeConnectivityStateListener(listener) {\n    this.child.removeConnectivityStateListener(listener);\n  }\n  startConnecting() {\n    this.child.startConnecting();\n  }\n  getAddress() {\n    return this.child.getAddress();\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    this.child.throttleKeepalive(newKeepaliveTime);\n  }\n  ref() {\n    this.child.ref();\n  }\n  unref() {\n    this.child.unref();\n  }\n  getChannelzRef() {\n    return this.child.getChannelzRef();\n  }\n  isHealthy() {\n    return this.healthy && this.child.isHealthy();\n  }\n  addHealthStateWatcher(listener) {\n    this.healthListeners.add(listener);\n  }\n  removeHealthStateWatcher(listener) {\n    this.healthListeners.delete(listener);\n  }\n  setHealthy(healthy) {\n    if (healthy !== this.healthy) {\n      this.healthy = healthy;\n      /* A change to this wrapper's health state only affects the overall\n       * reported health state if the child is healthy. */\n      if (this.child.isHealthy()) {\n        this.updateHealthListeners();\n      }\n    }\n  }\n  getRealSubchannel() {\n    return this.child.getRealSubchannel();\n  }\n  realSubchannelEquals(other) {\n    return this.getRealSubchannel() === other.getRealSubchannel();\n  }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper;","map":{"version":3,"names":["BaseSubchannelWrapper","constructor","child","healthy","healthListeners","Set","addHealthStateWatcher","childHealthy","updateHealthListeners","listener","isHealthy","getConnectivityState","addConnectivityStateListener","removeConnectivityStateListener","startConnecting","getAddress","throttleKeepalive","newKeepaliveTime","ref","unref","getChannelzRef","add","removeHealthStateWatcher","delete","setHealthy","getRealSubchannel","realSubchannelEquals","other","exports"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/subchannel-interface.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport type { SubchannelRef } from './channelz';\nimport { ConnectivityState } from './connectivity-state';\nimport { Subchannel } from './subchannel';\n\nexport type ConnectivityStateListener = (\n  subchannel: SubchannelInterface,\n  previousState: ConnectivityState,\n  newState: ConnectivityState,\n  keepaliveTime: number,\n  errorMessage?: string\n) => void;\n\nexport type HealthListener = (healthy: boolean) => void;\n\n/**\n * This is an interface for load balancing policies to use to interact with\n * subchannels. This allows load balancing policies to wrap and unwrap\n * subchannels.\n *\n * Any load balancing policy that wraps subchannels must unwrap the subchannel\n * in the picker, so that other load balancing policies consistently have\n * access to their own wrapper objects.\n */\nexport interface SubchannelInterface {\n  getConnectivityState(): ConnectivityState;\n  addConnectivityStateListener(listener: ConnectivityStateListener): void;\n  removeConnectivityStateListener(listener: ConnectivityStateListener): void;\n  startConnecting(): void;\n  getAddress(): string;\n  throttleKeepalive(newKeepaliveTime: number): void;\n  ref(): void;\n  unref(): void;\n  getChannelzRef(): SubchannelRef;\n  isHealthy(): boolean;\n  addHealthStateWatcher(listener: HealthListener): void;\n  removeHealthStateWatcher(listener: HealthListener): void;\n  /**\n   * If this is a wrapper, return the wrapped subchannel, otherwise return this\n   */\n  getRealSubchannel(): Subchannel;\n  /**\n   * Returns true if this and other both proxy the same underlying subchannel.\n   * Can be used instead of directly accessing getRealSubchannel to allow mocks\n   * to avoid implementing getRealSubchannel\n   */\n  realSubchannelEquals(other: SubchannelInterface): boolean;\n}\n\nexport abstract class BaseSubchannelWrapper implements SubchannelInterface {\n  private healthy = true;\n  private healthListeners: Set<HealthListener> = new Set();\n  constructor(protected child: SubchannelInterface) {\n    child.addHealthStateWatcher(childHealthy => {\n      /* A change to the child health state only affects this wrapper's overall\n       * health state if this wrapper is reporting healthy. */\n      if (this.healthy) {\n        this.updateHealthListeners();\n      }\n    });\n  }\n\n  private updateHealthListeners(): void {\n    for (const listener of this.healthListeners) {\n      listener(this.isHealthy());\n    }\n  }\n\n  getConnectivityState(): ConnectivityState {\n    return this.child.getConnectivityState();\n  }\n  addConnectivityStateListener(listener: ConnectivityStateListener): void {\n    this.child.addConnectivityStateListener(listener);\n  }\n  removeConnectivityStateListener(listener: ConnectivityStateListener): void {\n    this.child.removeConnectivityStateListener(listener);\n  }\n  startConnecting(): void {\n    this.child.startConnecting();\n  }\n  getAddress(): string {\n    return this.child.getAddress();\n  }\n  throttleKeepalive(newKeepaliveTime: number): void {\n    this.child.throttleKeepalive(newKeepaliveTime);\n  }\n  ref(): void {\n    this.child.ref();\n  }\n  unref(): void {\n    this.child.unref();\n  }\n  getChannelzRef(): SubchannelRef {\n    return this.child.getChannelzRef();\n  }\n  isHealthy(): boolean {\n    return this.healthy && this.child.isHealthy();\n  }\n  addHealthStateWatcher(listener: HealthListener): void {\n    this.healthListeners.add(listener);\n  }\n  removeHealthStateWatcher(listener: HealthListener): void {\n    this.healthListeners.delete(listener);\n  }\n  protected setHealthy(healthy: boolean): void {\n    if (healthy !== this.healthy) {\n      this.healthy = healthy;\n      /* A change to this wrapper's health state only affects the overall\n       * reported health state if the child is healthy. */\n      if (this.child.isHealthy()) {\n        this.updateHealthListeners();\n      }\n    }\n  }\n  getRealSubchannel(): Subchannel {\n    return this.child.getRealSubchannel();\n  }\n  realSubchannelEquals(other: SubchannelInterface): boolean {\n    return this.getRealSubchannel() === other.getRealSubchannel();\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiEA,MAAsBA,qBAAqB;EAGzCC,YAAsBC,KAA0B;IAA1B,KAAAA,KAAK,GAALA,KAAK;IAFnB,KAAAC,OAAO,GAAG,IAAI;IACd,KAAAC,eAAe,GAAwB,IAAIC,GAAG,EAAE;IAEtDH,KAAK,CAACI,qBAAqB,CAACC,YAAY,IAAG;MACzC;;MAEA,IAAI,IAAI,CAACJ,OAAO,EAAE;QAChB,IAAI,CAACK,qBAAqB,EAAE;MAC9B;IACF,CAAC,CAAC;EACJ;EAEQA,qBAAqBA,CAAA;IAC3B,KAAK,MAAMC,QAAQ,IAAI,IAAI,CAACL,eAAe,EAAE;MAC3CK,QAAQ,CAAC,IAAI,CAACC,SAAS,EAAE,CAAC;IAC5B;EACF;EAEAC,oBAAoBA,CAAA;IAClB,OAAO,IAAI,CAACT,KAAK,CAACS,oBAAoB,EAAE;EAC1C;EACAC,4BAA4BA,CAACH,QAAmC;IAC9D,IAAI,CAACP,KAAK,CAACU,4BAA4B,CAACH,QAAQ,CAAC;EACnD;EACAI,+BAA+BA,CAACJ,QAAmC;IACjE,IAAI,CAACP,KAAK,CAACW,+BAA+B,CAACJ,QAAQ,CAAC;EACtD;EACAK,eAAeA,CAAA;IACb,IAAI,CAACZ,KAAK,CAACY,eAAe,EAAE;EAC9B;EACAC,UAAUA,CAAA;IACR,OAAO,IAAI,CAACb,KAAK,CAACa,UAAU,EAAE;EAChC;EACAC,iBAAiBA,CAACC,gBAAwB;IACxC,IAAI,CAACf,KAAK,CAACc,iBAAiB,CAACC,gBAAgB,CAAC;EAChD;EACAC,GAAGA,CAAA;IACD,IAAI,CAAChB,KAAK,CAACgB,GAAG,EAAE;EAClB;EACAC,KAAKA,CAAA;IACH,IAAI,CAACjB,KAAK,CAACiB,KAAK,EAAE;EACpB;EACAC,cAAcA,CAAA;IACZ,OAAO,IAAI,CAAClB,KAAK,CAACkB,cAAc,EAAE;EACpC;EACAV,SAASA,CAAA;IACP,OAAO,IAAI,CAACP,OAAO,IAAI,IAAI,CAACD,KAAK,CAACQ,SAAS,EAAE;EAC/C;EACAJ,qBAAqBA,CAACG,QAAwB;IAC5C,IAAI,CAACL,eAAe,CAACiB,GAAG,CAACZ,QAAQ,CAAC;EACpC;EACAa,wBAAwBA,CAACb,QAAwB;IAC/C,IAAI,CAACL,eAAe,CAACmB,MAAM,CAACd,QAAQ,CAAC;EACvC;EACUe,UAAUA,CAACrB,OAAgB;IACnC,IAAIA,OAAO,KAAK,IAAI,CAACA,OAAO,EAAE;MAC5B,IAAI,CAACA,OAAO,GAAGA,OAAO;MACtB;;MAEA,IAAI,IAAI,CAACD,KAAK,CAACQ,SAAS,EAAE,EAAE;QAC1B,IAAI,CAACF,qBAAqB,EAAE;MAC9B;IACF;EACF;EACAiB,iBAAiBA,CAAA;IACf,OAAO,IAAI,CAACvB,KAAK,CAACuB,iBAAiB,EAAE;EACvC;EACAC,oBAAoBA,CAACC,KAA0B;IAC7C,OAAO,IAAI,CAACF,iBAAiB,EAAE,KAAKE,KAAK,CAACF,iBAAiB,EAAE;EAC/D;;AAtEFG,OAAA,CAAA5B,qBAAA,GAAAA,qBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}