{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    /**\n     * The delay time at the start, and after each reset.\n     */\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    /**\n     * The exponential backoff multiplier.\n     */\n    this.multiplier = BACKOFF_MULTIPLIER;\n    /**\n     * The maximum delay time\n     */\n    this.maxDelay = MAX_BACKOFF_MS;\n    /**\n     * The maximum fraction by which the delay time can randomly vary after\n     * applying the multiplier.\n     */\n    this.jitter = BACKOFF_JITTER;\n    /**\n     * Indicates whether the timer is currently running.\n     */\n    this.running = false;\n    /**\n     * Indicates whether the timer should keep the Node process running if no\n     * other async operation is doing so.\n     */\n    this.hasRef = true;\n    /**\n     * The time that the currently running timer was started. Only valid if\n     * running is true.\n     */\n    this.startTime = new Date();\n    /**\n     * The approximate time that the currently running timer will end. Only valid\n     * if running is true.\n     */\n    this.endTime = new Date();\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n  runTimer(delay) {\n    var _a, _b;\n    this.endTime = this.startTime;\n    this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    var _a, _b;\n    this.hasRef = true;\n    (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    var _a, _b;\n    this.hasRef = false;\n    (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Get the approximate timestamp of when the timer will fire. Only valid if\n   * this.isRunning() is true.\n   */\n  getEndTime() {\n    return this.endTime;\n  }\n}\nexports.BackoffTimeout = BackoffTimeout;","map":{"version":3,"names":["INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","uniformRandom","min","max","Math","random","BackoffTimeout","constructor","callback","options","initialDelay","multiplier","maxDelay","jitter","running","hasRef","startTime","Date","endTime","nextDelay","timerId","setTimeout","clearTimeout","runTimer","delay","setMilliseconds","getMilliseconds","_b","_a","unref","call","runOnce","nextBackoff","jitterMagnitude","stop","reset","now","newEndTime","getTime","isRunning","ref","getEndTime","exports"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/backoff-timeout.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nexport interface BackoffOptions {\n  initialDelay?: number;\n  multiplier?: number;\n  jitter?: number;\n  maxDelay?: number;\n}\n\nexport class BackoffTimeout {\n  /**\n   * The delay time at the start, and after each reset.\n   */\n  private readonly initialDelay: number = INITIAL_BACKOFF_MS;\n  /**\n   * The exponential backoff multiplier.\n   */\n  private readonly multiplier: number = BACKOFF_MULTIPLIER;\n  /**\n   * The maximum delay time\n   */\n  private readonly maxDelay: number = MAX_BACKOFF_MS;\n  /**\n   * The maximum fraction by which the delay time can randomly vary after\n   * applying the multiplier.\n   */\n  private readonly jitter: number = BACKOFF_JITTER;\n  /**\n   * The delay time for the next time the timer runs.\n   */\n  private nextDelay: number;\n  /**\n   * The handle of the underlying timer. If running is false, this value refers\n   * to an object representing a timer that has ended, but it can still be\n   * interacted with without error.\n   */\n  private timerId: NodeJS.Timeout;\n  /**\n   * Indicates whether the timer is currently running.\n   */\n  private running = false;\n  /**\n   * Indicates whether the timer should keep the Node process running if no\n   * other async operation is doing so.\n   */\n  private hasRef = true;\n  /**\n   * The time that the currently running timer was started. Only valid if\n   * running is true.\n   */\n  private startTime: Date = new Date();\n  /**\n   * The approximate time that the currently running timer will end. Only valid\n   * if running is true.\n   */\n  private endTime: Date = new Date();\n\n  constructor(private callback: () => void, options?: BackoffOptions) {\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n\n  private runTimer(delay: number) {\n    this.endTime = this.startTime;\n    this.endTime.setMilliseconds(\n      this.endTime.getMilliseconds() + this.nextDelay\n    );\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      this.timerId.unref?.();\n    }\n  }\n\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(\n      this.nextDelay * this.multiplier,\n      this.maxDelay\n    );\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay =\n      nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    this.hasRef = true;\n    this.timerId.ref?.();\n  }\n\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    this.hasRef = false;\n    this.timerId.unref?.();\n  }\n\n  /**\n   * Get the approximate timestamp of when the timer will fire. Only valid if\n   * this.isRunning() is true.\n   */\n  getEndTime() {\n    return this.endTime;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}