{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = require(\"./metadata\");\nconst call_interface_1 = require(\"./call-interface\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n  withOnReceiveStatus(onReceiveStatus) {\n    this.status = onReceiveStatus;\n    return this;\n  }\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status\n    };\n  }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n  constructor() {\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n  withHalfClose(halfClose) {\n    this.halfClose = halfClose;\n    return this;\n  }\n  withCancel(cancel) {\n    this.cancel = cancel;\n    return this;\n  }\n  build() {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel\n    };\n  }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  }\n};\nclass InterceptingCall {\n  constructor(nextCall, requester) {\n    var _a, _b, _c, _d;\n    this.nextCall = nextCall;\n    /**\n     * Indicates that metadata has been passed to the requester's start\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMetadata = false;\n    /**\n     * Message context for a pending message that is waiting for\n     */\n    this.pendingMessageContext = null;\n    /**\n     * Indicates that a message has been passed to the requester's sendMessage\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n    this.pendingHalfClose = false;\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n  processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n  processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n  start(metadata, interceptingListener) {\n    var _a, _b, _c, _d, _e, _f;\n    const fullInterceptingListener = {\n      onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : metadata => {},\n      onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : message => {},\n      onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : status => {}\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      var _a, _b, _c;\n      this.processingMetadata = false;\n      let finalInterceptingListener;\n      if ((0, call_interface_1.isInterceptingListener)(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener = {\n          onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n          onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n          onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n        };\n        finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead() {\n    this.nextCall.startRead();\n  }\n  halfClose() {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n  var _a, _b;\n  const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n  const host = options.host;\n  const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n  constructor(call,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition) {\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n  cancelWithStatus(status, details) {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    let serialized;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(metadata, interceptingListener) {\n    let readError = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        var _a;\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n      },\n      onReceiveMessage: message => {\n        var _a;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: constants_1.Status.INTERNAL,\n            details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\n            metadata: new metadata_1.Metadata()\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (readError) {\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n        } else {\n          (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n        }\n      }\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose() {\n    this.call.halfClose();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call, methodDefinition) {\n    super(call, methodDefinition);\n  }\n  start(metadata, listener) {\n    var _a, _b;\n    let receivedMessage = false;\n    const wrapperListener = {\n      onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : metadata => {},\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: message => {\n        var _a;\n        receivedMessage = true;\n        (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (!receivedMessage) {\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n        }\n        (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n      }\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {}\nfunction getBottomInterceptingCall(channel, options,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\nfunction getInterceptingCall(interceptorArgs,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n  let interceptors = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n    return currentOptions => nextInterceptor(currentOptions, nextCall);\n  }, finalOptions => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n  return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;","map":{"version":3,"names":["metadata_1","require","call_interface_1","constants_1","error_1","InterceptorConfigurationError","Error","constructor","message","name","captureStackTrace","exports","ListenerBuilder","metadata","undefined","status","withOnReceiveMetadata","onReceiveMetadata","withOnReceiveMessage","onReceiveMessage","withOnReceiveStatus","onReceiveStatus","build","RequesterBuilder","start","halfClose","cancel","withStart","withSendMessage","sendMessage","withHalfClose","withCancel","defaultListener","next","defaultRequester","listener","InterceptingCall","nextCall","requester","processingMetadata","pendingMessageContext","processingMessage","pendingHalfClose","_a","_b","_c","_d","cancelWithStatus","details","getPeer","processPendingMessage","sendMessageWithContext","pendingMessage","processPendingHalfClose","interceptingListener","fullInterceptingListener","bind","_f","_e","md","finalInterceptingListener","isInterceptingListener","fullListener","InterceptingListenerImpl","context","finalMessage","startRead","getCall","channel","path","options","deadline","Infinity","host","parent","propagateFlags","propagate_flags","credentials","call","createCall","setCredentials","BaseInterceptingCall","methodDefinition","serialized","requestSerialize","e","Status","INTERNAL","getErrorMessage","readError","deserialized","responseDeserialize","code","Metadata","BaseUnaryInterceptingCall","receivedMessage","wrapperListener","BaseStreamingInterceptingCall","getBottomInterceptingCall","responseStream","getInterceptingCall","interceptorArgs","clientInterceptors","length","clientInterceptorProviders","callInterceptors","callInterceptorProviders","interceptors","concat","map","provider","filter","interceptor","interceptorOptions","Object","assign","method_definition","reduceRight","nextInterceptor","currentOptions","finalOptions"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/client-interceptors.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Metadata } from './metadata';\nimport {\n  StatusObject,\n  Listener,\n  MetadataListener,\n  MessageListener,\n  StatusListener,\n  FullListener,\n  InterceptingListener,\n  InterceptingListenerImpl,\n  isInterceptingListener,\n  MessageContext,\n  Call,\n} from './call-interface';\nimport { Status } from './constants';\nimport { Channel } from './channel';\nimport { CallOptions } from './client';\nimport { ClientMethodDefinition } from './make-client';\nimport { getErrorMessage } from './error';\n\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nexport class InterceptorConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\n\nexport interface MetadataRequester {\n  (\n    metadata: Metadata,\n    listener: InterceptingListener,\n    next: (\n      metadata: Metadata,\n      listener: InterceptingListener | Listener\n    ) => void\n  ): void;\n}\n\nexport interface MessageRequester {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface CloseRequester {\n  (next: () => void): void;\n}\n\nexport interface CancelRequester {\n  (next: () => void): void;\n}\n\n/**\n * An object with methods for intercepting and modifying outgoing call operations.\n */\nexport interface FullRequester {\n  start: MetadataRequester;\n  sendMessage: MessageRequester;\n  halfClose: CloseRequester;\n  cancel: CancelRequester;\n}\n\nexport type Requester = Partial<FullRequester>;\n\nexport class ListenerBuilder {\n  private metadata: MetadataListener | undefined = undefined;\n  private message: MessageListener | undefined = undefined;\n  private status: StatusListener | undefined = undefined;\n\n  withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage: MessageListener): this {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus: StatusListener): this {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build(): Listener {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status,\n    };\n  }\n}\n\nexport class RequesterBuilder {\n  private start: MetadataRequester | undefined = undefined;\n  private message: MessageRequester | undefined = undefined;\n  private halfClose: CloseRequester | undefined = undefined;\n  private cancel: CancelRequester | undefined = undefined;\n\n  withStart(start: MetadataRequester): this {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage: MessageRequester): this {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose: CloseRequester): this {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel: CancelRequester): this {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build(): Requester {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel,\n    };\n  }\n}\n\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener: FullListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  },\n};\n\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester: FullRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  },\n};\n\nexport interface InterceptorOptions extends CallOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  method_definition: ClientMethodDefinition<any, any>;\n}\n\nexport interface InterceptingCallInterface {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void;\n  startRead(): void;\n  halfClose(): void;\n}\n\nexport class InterceptingCall implements InterceptingCallInterface {\n  /**\n   * The requester that this InterceptingCall uses to modify outgoing operations\n   */\n  private requester: FullRequester;\n  /**\n   * Indicates that metadata has been passed to the requester's start\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMetadata = false;\n  /**\n   * Message context for a pending message that is waiting for\n   */\n  private pendingMessageContext: MessageContext | null = null;\n  private pendingMessage: any;\n  /**\n   * Indicates that a message has been passed to the requester's sendMessage\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMessage = false;\n  /**\n   * Indicates that a status was received but could not be propagated because\n   * a message was still being processed.\n   */\n  private pendingHalfClose = false;\n  constructor(\n    private nextCall: InterceptingCallInterface,\n    requester?: Requester\n  ) {\n    if (requester) {\n      this.requester = {\n        start: requester.start ?? defaultRequester.start,\n        sendMessage: requester.sendMessage ?? defaultRequester.sendMessage,\n        halfClose: requester.halfClose ?? defaultRequester.halfClose,\n        cancel: requester.cancel ?? defaultRequester.cancel,\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  private processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(\n        this.pendingMessageContext,\n        this.pendingMessage\n      );\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n\n  private processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    const fullInterceptingListener: InterceptingListener = {\n      onReceiveMetadata:\n        interceptingListener?.onReceiveMetadata?.bind(interceptingListener) ??\n        (metadata => {}),\n      onReceiveMessage:\n        interceptingListener?.onReceiveMessage?.bind(interceptingListener) ??\n        (message => {}),\n      onReceiveStatus:\n        interceptingListener?.onReceiveStatus?.bind(interceptingListener) ??\n        (status => {}),\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      this.processingMetadata = false;\n      let finalInterceptingListener: InterceptingListener;\n      if (isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener: FullListener = {\n          onReceiveMetadata:\n            listener.onReceiveMetadata ?? defaultListener.onReceiveMetadata,\n          onReceiveMessage:\n            listener.onReceiveMessage ?? defaultListener.onReceiveMessage,\n          onReceiveStatus:\n            listener.onReceiveStatus ?? defaultListener.onReceiveStatus,\n        };\n        finalInterceptingListener = new InterceptingListenerImpl(\n          fullListener,\n          fullInterceptingListener\n        );\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead(): void {\n    this.nextCall.startRead();\n  }\n  halfClose(): void {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n}\n\nfunction getCall(channel: Channel, path: string, options: CallOptions): Call {\n  const deadline = options.deadline ?? Infinity;\n  const host = options.host;\n  const parent = options.parent ?? null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall implements InterceptingCallInterface {\n  constructor(\n    protected call: Call,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected methodDefinition: ClientMethodDefinition<any, any>\n  ) {}\n  cancelWithStatus(status: Status, details: string): void {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    let serialized: Buffer;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(\n        Status.INTERNAL,\n        `Request message serialization failure: ${getErrorMessage(e)}`\n      );\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    let readError: StatusObject | null = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        interceptingListener?.onReceiveMetadata?.(metadata);\n      },\n      onReceiveMessage: message => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized: any;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: Status.INTERNAL,\n            details: `Response message parsing error: ${getErrorMessage(e)}`,\n            metadata: new Metadata(),\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        interceptingListener?.onReceiveMessage?.(deserialized);\n      },\n      onReceiveStatus: status => {\n        if (readError) {\n          interceptingListener?.onReceiveStatus?.(readError);\n        } else {\n          interceptingListener?.onReceiveStatus?.(status);\n        }\n      },\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose(): void {\n    this.call.halfClose();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface\n{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call: Call, methodDefinition: ClientMethodDefinition<any, any>) {\n    super(call, methodDefinition);\n  }\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void {\n    let receivedMessage = false;\n    const wrapperListener: InterceptingListener = {\n      onReceiveMetadata:\n        listener?.onReceiveMetadata?.bind(listener) ?? (metadata => {}),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: (message: any) => {\n        receivedMessage = true;\n        listener?.onReceiveMessage?.(message);\n      },\n      onReceiveStatus: (status: StatusObject) => {\n        if (!receivedMessage) {\n          listener?.onReceiveMessage?.(null);\n        }\n        listener?.onReceiveStatus?.(status);\n      },\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {}\n\nfunction getBottomInterceptingCall(\n  channel: Channel,\n  options: InterceptorOptions,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>\n) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nexport interface NextCall {\n  (options: InterceptorOptions): InterceptingCallInterface;\n}\n\nexport interface Interceptor {\n  (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;\n}\n\nexport interface InterceptorProvider {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;\n}\n\nexport interface InterceptorArguments {\n  clientInterceptors: Interceptor[];\n  clientInterceptorProviders: InterceptorProvider[];\n  callInterceptors: Interceptor[];\n  callInterceptorProviders: InterceptorProvider[];\n}\n\nexport function getInterceptingCall(\n  interceptorArgs: InterceptorArguments,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>,\n  options: CallOptions,\n  channel: Channel\n): InterceptingCallInterface {\n  if (\n    interceptorArgs.clientInterceptors.length > 0 &&\n    interceptorArgs.clientInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as options ' +\n        'to the client constructor. Only one of these is allowed.'\n    );\n  }\n  if (\n    interceptorArgs.callInterceptors.length > 0 &&\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as call ' +\n        'options. Only one of these is allowed.'\n    );\n  }\n  let interceptors: Interceptor[] = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (\n    interceptorArgs.callInterceptors.length > 0 ||\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.callInterceptors,\n        interceptorArgs.callInterceptorProviders.map(provider =>\n          provider(methodDefinition)\n        )\n      )\n      .filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.clientInterceptors,\n        interceptorArgs.clientInterceptorProviders.map(provider =>\n          provider(methodDefinition)\n        )\n      )\n      .filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition,\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall: NextCall = interceptors.reduceRight<NextCall>(\n    (nextCall: NextCall, nextInterceptor: Interceptor) => {\n      return currentOptions => nextInterceptor(currentOptions, nextCall);\n    },\n    (finalOptions: InterceptorOptions) =>\n      getBottomInterceptingCall(channel, finalOptions, methodDefinition)\n  );\n  return getCall(interceptorOptions);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}