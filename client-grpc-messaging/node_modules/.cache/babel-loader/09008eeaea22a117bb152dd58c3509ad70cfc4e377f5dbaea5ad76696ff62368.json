{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst resolver_1 = require(\"./resolver\");\nconst http = require(\"http\");\nconst tls = require(\"tls\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst url_1 = require(\"url\");\nconst resolver_dns_1 = require(\"./resolver-dns\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl;\n  try {\n    proxyUrl = new url_1.URL(proxyEnv);\n  } catch (e) {\n    (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n    return {};\n  }\n  let userCred = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result = {\n    address: `${hostname}:${port}`\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n  return result;\n}\nfunction getNoProxyHostList() {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\nfunction mapProxyName(target, options) {\n  var _a;\n  const noProxyResult = {\n    target: target,\n    extraOptions: {}\n  };\n  if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\n      return noProxyResult;\n    }\n  }\n  const extraOptions = {\n    'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target)\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address\n    },\n    extraOptions: extraOptions\n  };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n  var _a;\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'];\n  const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve({});\n  }\n  const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\n  if (splitHostPost === null) {\n    return Promise.resolve({});\n  }\n  const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\n  const options = {\n    method: 'CONNECT',\n    path: hostPort\n  };\n  const headers = {\n    Host: hostPort\n  };\n  // Connect to the subchannel address as a proxy\n  if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n  }\n  options.headers = headers;\n  const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      var _a;\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace('Successfully connected to ' + options.path + ' through proxy ' + proxyAddressString);\n        // The HTTP client may have already read a few bytes of the proxied\n        // connection. If that's the case, put them back into the socket.\n        // See https://github.com/grpc/grpc-node/issues/2744.\n        if (head.length > 0) {\n          socket.unshift(head);\n        }\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);\n          const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n          const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n          const cts = tls.connect(Object.assign({\n            host: remoteHost,\n            servername: remoteHost,\n            socket: socket\n          }, connectionOptions), () => {\n            trace('Successfully established a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString);\n            resolve({\n              socket: cts,\n              realTarget: parsedTarget\n            });\n          });\n          cts.on('error', error => {\n            trace('Failed to establish a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString + ' with error ' + error.message);\n            reject();\n          });\n        } else {\n          trace('Successfully established a plaintext connection to ' + options.path + ' through proxy ' + proxyAddressString);\n          resolve({\n            socket,\n            realTarget: parsedTarget\n          });\n        }\n      } else {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' + options.path + ' through proxy ' + proxyAddressString + ' with status ' + res.statusCode);\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' + proxyAddressString + ' with error ' + err.message);\n      reject();\n    });\n    request.end();\n  });\n}\nexports.getProxiedConnection = getProxiedConnection;","map":{"version":3,"names":["logging_1","require","constants_1","resolver_1","http","tls","logging","subchannel_address_1","uri_parser_1","url_1","resolver_dns_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","getProxyInfo","proxyEnv","envVar","process","env","grpc_proxy","https_proxy","http_proxy","proxyUrl","URL","e","log","ERROR","protocol","userCred","username","password","INFO","decodeURIComponent","hostname","port","result","address","creds","getNoProxyHostList","noProxyStr","no_grpc_proxy","no_proxy","split","mapProxyName","target","options","noProxyResult","extraOptions","_a","scheme","proxyInfo","hostPort","splitHostPort","path","serverHost","host","uriToString","exports","getProxiedConnection","channelOptions","connectionOptions","Promise","resolve","realTarget","parsedTarget","parseUri","splitHostPost","DEFAULT_PORT","method","headers","Host","isTcpSubchannelAddress","socketPath","Buffer","from","toString","proxyAddressString","subchannelAddressToString","reject","request","once","res","socket","head","removeAllListeners","statusCode","length","unshift","targetPath","getDefaultAuthority","remoteHost","cts","connect","Object","assign","servername","on","error","message","err","end"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/http_proxy.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nimport { getDefaultAuthority } from './resolver';\nimport { Socket } from 'net';\nimport * as http from 'http';\nimport * as tls from 'tls';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { URL } from 'url';\nimport { DEFAULT_PORT } from './resolver-dns';\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface ProxyInfo {\n  address?: string;\n  creds?: string;\n}\n\nfunction getProxyInfo(): ProxyInfo {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl: URL;\n  try {\n    proxyUrl = new URL(proxyEnv);\n  } catch (e) {\n    log(LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    log(\n      LogVerbosity.ERROR,\n      `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`\n    );\n    return {};\n  }\n  let userCred: string | null = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      log(LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result: ProxyInfo = {\n    address: `${hostname}:${port}`,\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace(\n    'Proxy server ' + result.address + ' set by environment variable ' + envVar\n  );\n  return result;\n}\n\nfunction getNoProxyHostList(): string[] {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr: string | undefined = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\nexport interface ProxyMapResult {\n  target: GrpcUri;\n  extraOptions: ChannelOptions;\n}\n\nexport function mapProxyName(\n  target: GrpcUri,\n  options: ChannelOptions\n): ProxyMapResult {\n  const noProxyResult: ProxyMapResult = {\n    target: target,\n    extraOptions: {},\n  };\n  if ((options['grpc.enable_http_proxy'] ?? 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = splitHostPort(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace(\n        'Not using proxy for target in no_proxy list: ' + uriToString(target)\n      );\n      return noProxyResult;\n    }\n  }\n  const extraOptions: ChannelOptions = {\n    'grpc.http_connect_target': uriToString(target),\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address,\n    },\n    extraOptions: extraOptions,\n  };\n}\n\nexport interface ProxyConnectionResult {\n  socket?: Socket;\n  realTarget?: GrpcUri;\n}\n\nexport function getProxiedConnection(\n  address: SubchannelAddress,\n  channelOptions: ChannelOptions,\n  connectionOptions: tls.ConnectionOptions\n): Promise<ProxyConnectionResult> {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'] as string;\n  const parsedTarget = parseUri(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const splitHostPost = splitHostPort(parsedTarget.path);\n  if (splitHostPost === null) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const hostPort = `${splitHostPost.host}:${\n    splitHostPost.port ?? DEFAULT_PORT\n  }`;\n  const options: http.RequestOptions = {\n    method: 'CONNECT',\n    path: hostPort,\n  };\n  const headers: http.OutgoingHttpHeaders = {\n    Host: hostPort,\n  };\n  // Connect to the subchannel address as a proxy\n  if (isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] =\n      'Basic ' +\n      Buffer.from(channelOptions['grpc.http_connect_creds'] as string).toString(\n        'base64'\n      );\n  }\n  options.headers = headers;\n  const proxyAddressString = subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise<ProxyConnectionResult>((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace(\n          'Successfully connected to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString\n        );\n        // The HTTP client may have already read a few bytes of the proxied\n        // connection. If that's the case, put them back into the socket.\n        // See https://github.com/grpc/grpc-node/issues/2744.\n        if (head.length > 0) {\n          socket.unshift(head);\n        }\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = getDefaultAuthority(parsedTarget);\n          const hostPort = splitHostPort(targetPath);\n          const remoteHost = hostPort?.host ?? targetPath;\n\n          const cts = tls.connect(\n            {\n              host: remoteHost,\n              servername: remoteHost,\n              socket: socket,\n              ...connectionOptions,\n            },\n            () => {\n              trace(\n                'Successfully established a TLS connection to ' +\n                  options.path +\n                  ' through proxy ' +\n                  proxyAddressString\n              );\n              resolve({ socket: cts, realTarget: parsedTarget });\n            }\n          );\n          cts.on('error', (error: Error) => {\n            trace(\n              'Failed to establish a TLS connection to ' +\n                options.path +\n                ' through proxy ' +\n                proxyAddressString +\n                ' with error ' +\n                error.message\n            );\n            reject();\n          });\n        } else {\n          trace(\n            'Successfully established a plaintext connection to ' +\n              options.path +\n              ' through proxy ' +\n              proxyAddressString\n          );\n          resolve({\n            socket,\n            realTarget: parsedTarget,\n          });\n        }\n      } else {\n        log(\n          LogVerbosity.ERROR,\n          'Failed to connect to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString +\n            ' with status ' +\n            res.statusCode\n        );\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      log(\n        LogVerbosity.ERROR,\n        'Failed to connect to proxy ' +\n          proxyAddressString +\n          ' with error ' +\n          err.message\n      );\n      reject();\n    });\n    request.end();\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}