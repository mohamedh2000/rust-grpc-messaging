{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\nconst events_1 = require(\"events\");\nconst stream_1 = require(\"stream\");\nconst constants_1 = require(\"./constants\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nfunction callErrorFromStatus(status, callerStack) {\n  const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n  const error = new Error(message);\n  const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n  return Object.assign(new Error(message), status, {\n    stack\n  });\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n  constructor() {\n    super();\n  }\n  cancel() {\n    var _a;\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n  }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n  constructor(deserialize) {\n    super({\n      objectMode: true\n    });\n    this.deserialize = deserialize;\n  }\n  cancel() {\n    var _a;\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n  }\n  _read(_size) {\n    var _a;\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n  }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n  constructor(serialize) {\n    super({\n      objectMode: true\n    });\n    this.serialize = serialize;\n  }\n  cancel() {\n    var _a;\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n  }\n  _write(chunk, encoding, cb) {\n    var _a;\n    const context = {\n      callback: cb\n    };\n    const flags = Number(encoding);\n    if (!Number.isNaN(flags)) {\n      context.flags = flags;\n    }\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n  }\n  _final(cb) {\n    var _a;\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n    cb();\n  }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n  constructor(serialize, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n  }\n  cancel() {\n    var _a;\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n  }\n  _read(_size) {\n    var _a;\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n  }\n  _write(chunk, encoding, cb) {\n    var _a;\n    const context = {\n      callback: cb\n    };\n    const flags = Number(encoding);\n    if (!Number.isNaN(flags)) {\n      context.flags = flags;\n    }\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n  }\n  _final(cb) {\n    var _a;\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n    cb();\n  }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;","map":{"version":3,"names":["events_1","require","stream_1","constants_1","callErrorFromStatus","status","callerStack","message","code","Status","details","error","Error","stack","Object","assign","exports","ClientUnaryCallImpl","EventEmitter","constructor","cancel","_a","call","cancelWithStatus","CANCELLED","getPeer","_b","ClientReadableStreamImpl","Readable","deserialize","objectMode","_read","_size","startRead","ClientWritableStreamImpl","Writable","serialize","_write","chunk","encoding","cb","context","callback","flags","Number","isNaN","sendMessageWithContext","_final","halfClose","ClientDuplexStreamImpl","Duplex"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { EventEmitter } from 'events';\nimport { Duplex, Readable, Writable } from 'stream';\n\nimport { StatusObject, MessageContext } from './call-interface';\nimport { Status } from './constants';\nimport { EmitterAugmentation1 } from './events';\nimport { Metadata } from './metadata';\nimport { ObjectReadable, ObjectWritable, WriteCallback } from './object-stream';\nimport { InterceptingCallInterface } from './client-interceptors';\n\n/**\n * A type extending the built-in Error object with additional fields.\n */\nexport type ServiceError = StatusObject & Error;\n\n/**\n * A base type for all user-facing values returned by client-side method calls.\n */\nexport type SurfaceCall = {\n  call?: InterceptingCallInterface;\n  cancel(): void;\n  getPeer(): string;\n} & EmitterAugmentation1<'metadata', Metadata> &\n  EmitterAugmentation1<'status', StatusObject> &\n  EventEmitter;\n\n/**\n * A type representing the return value of a unary method call.\n */\nexport type ClientUnaryCall = SurfaceCall;\n\n/**\n * A type representing the return value of a server stream method call.\n */\nexport type ClientReadableStream<ResponseType> = {\n  deserialize: (chunk: Buffer) => ResponseType;\n} & SurfaceCall &\n  ObjectReadable<ResponseType>;\n\n/**\n * A type representing the return value of a client stream method call.\n */\nexport type ClientWritableStream<RequestType> = {\n  serialize: (value: RequestType) => Buffer;\n} & SurfaceCall &\n  ObjectWritable<RequestType>;\n\n/**\n * A type representing the return value of a bidirectional stream method call.\n */\nexport type ClientDuplexStream<RequestType, ResponseType> =\n  ClientWritableStream<RequestType> & ClientReadableStream<ResponseType>;\n\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nexport function callErrorFromStatus(\n  status: StatusObject,\n  callerStack: string\n): ServiceError {\n  const message = `${status.code} ${Status[status.code]}: ${status.details}`;\n  const error = new Error(message);\n  const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n  return Object.assign(new Error(message), status, { stack });\n}\n\nexport class ClientUnaryCallImpl\n  extends EventEmitter\n  implements ClientUnaryCall\n{\n  public call?: InterceptingCallInterface;\n  constructor() {\n    super();\n  }\n\n  cancel(): void {\n    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer(): string {\n    return this.call?.getPeer() ?? 'unknown';\n  }\n}\n\nexport class ClientReadableStreamImpl<ResponseType>\n  extends Readable\n  implements ClientReadableStream<ResponseType>\n{\n  public call?: InterceptingCallInterface;\n  constructor(readonly deserialize: (chunk: Buffer) => ResponseType) {\n    super({ objectMode: true });\n  }\n\n  cancel(): void {\n    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer(): string {\n    return this.call?.getPeer() ?? 'unknown';\n  }\n\n  _read(_size: number): void {\n    this.call?.startRead();\n  }\n}\n\nexport class ClientWritableStreamImpl<RequestType>\n  extends Writable\n  implements ClientWritableStream<RequestType>\n{\n  public call?: InterceptingCallInterface;\n  constructor(readonly serialize: (value: RequestType) => Buffer) {\n    super({ objectMode: true });\n  }\n\n  cancel(): void {\n    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer(): string {\n    return this.call?.getPeer() ?? 'unknown';\n  }\n\n  _write(chunk: RequestType, encoding: string, cb: WriteCallback) {\n    const context: MessageContext = {\n      callback: cb,\n    };\n    const flags = Number(encoding);\n    if (!Number.isNaN(flags)) {\n      context.flags = flags;\n    }\n    this.call?.sendMessageWithContext(context, chunk);\n  }\n\n  _final(cb: Function) {\n    this.call?.halfClose();\n    cb();\n  }\n}\n\nexport class ClientDuplexStreamImpl<RequestType, ResponseType>\n  extends Duplex\n  implements ClientDuplexStream<RequestType, ResponseType>\n{\n  public call?: InterceptingCallInterface;\n  constructor(\n    readonly serialize: (value: RequestType) => Buffer,\n    readonly deserialize: (chunk: Buffer) => ResponseType\n  ) {\n    super({ objectMode: true });\n  }\n\n  cancel(): void {\n    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer(): string {\n    return this.call?.getPeer() ?? 'unknown';\n  }\n\n  _read(_size: number): void {\n    this.call?.startRead();\n  }\n\n  _write(chunk: RequestType, encoding: string, cb: WriteCallback) {\n    const context: MessageContext = {\n      callback: cb,\n    };\n    const flags = Number(encoding);\n    if (!Number.isNaN(flags)) {\n      context.flags = flags;\n    }\n    this.call?.sendMessageWithContext(context, chunk);\n  }\n\n  _final(cb: Function) {\n    this.call?.halfClose();\n    cb();\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,QAAA,GAAAD,OAAA;AAGA,MAAAE,WAAA,GAAAF,OAAA;AAiDA;;;;;;AAMA,SAAgBG,mBAAmBA,CACjCC,MAAoB,EACpBC,WAAmB;EAEnB,MAAMC,OAAO,GAAG,GAAGF,MAAM,CAACG,IAAI,IAAIL,WAAA,CAAAM,MAAM,CAACJ,MAAM,CAACG,IAAI,CAAC,KAAKH,MAAM,CAACK,OAAO,EAAE;EAC1E,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAACL,OAAO,CAAC;EAChC,MAAMM,KAAK,GAAG,GAAGF,KAAK,CAACE,KAAK,kBAAkBP,WAAW,EAAE;EAC3D,OAAOQ,MAAM,CAACC,MAAM,CAAC,IAAIH,KAAK,CAACL,OAAO,CAAC,EAAEF,MAAM,EAAE;IAAEQ;EAAK,CAAE,CAAC;AAC7D;AARAG,OAAA,CAAAZ,mBAAA,GAAAA,mBAAA;AAUA,MAAaa,mBACX,SAAQjB,QAAA,CAAAkB,YAAY;EAIpBC,YAAA;IACE,KAAK,EAAE;EACT;EAEAC,MAAMA,CAAA;;IACJ,CAAAC,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,gBAAgB,CAACpB,WAAA,CAAAM,MAAM,CAACe,SAAS,EAAE,qBAAqB,CAAC;EACtE;EAEAC,OAAOA,CAAA;;IACL,OAAO,CAAAC,EAAA,IAAAL,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEI,OAAO,EAAE,cAAAC,EAAA,cAAAA,EAAA,GAAI,SAAS;EAC1C;;AAfFV,OAAA,CAAAC,mBAAA,GAAAA,mBAAA;AAkBA,MAAaU,wBACX,SAAQzB,QAAA,CAAA0B,QAAQ;EAIhBT,YAAqBU,WAA4C;IAC/D,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAI,CAAE,CAAC;IADR,KAAAD,WAAW,GAAXA,WAAW;EAEhC;EAEAT,MAAMA,CAAA;;IACJ,CAAAC,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,gBAAgB,CAACpB,WAAA,CAAAM,MAAM,CAACe,SAAS,EAAE,qBAAqB,CAAC;EACtE;EAEAC,OAAOA,CAAA;;IACL,OAAO,CAAAC,EAAA,IAAAL,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEI,OAAO,EAAE,cAAAC,EAAA,cAAAA,EAAA,GAAI,SAAS;EAC1C;EAEAK,KAAKA,CAACC,KAAa;;IACjB,CAAAX,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEY,SAAS,EAAE;EACxB;;AAnBFjB,OAAA,CAAAW,wBAAA,GAAAA,wBAAA;AAsBA,MAAaO,wBACX,SAAQhC,QAAA,CAAAiC,QAAQ;EAIhBhB,YAAqBiB,SAAyC;IAC5D,KAAK,CAAC;MAAEN,UAAU,EAAE;IAAI,CAAE,CAAC;IADR,KAAAM,SAAS,GAATA,SAAS;EAE9B;EAEAhB,MAAMA,CAAA;;IACJ,CAAAC,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,gBAAgB,CAACpB,WAAA,CAAAM,MAAM,CAACe,SAAS,EAAE,qBAAqB,CAAC;EACtE;EAEAC,OAAOA,CAAA;;IACL,OAAO,CAAAC,EAAA,IAAAL,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEI,OAAO,EAAE,cAAAC,EAAA,cAAAA,EAAA,GAAI,SAAS;EAC1C;EAEAW,MAAMA,CAACC,KAAkB,EAAEC,QAAgB,EAAEC,EAAiB;;IAC5D,MAAMC,OAAO,GAAmB;MAC9BC,QAAQ,EAAEF;KACX;IACD,MAAMG,KAAK,GAAGC,MAAM,CAACL,QAAQ,CAAC;IAC9B,IAAI,CAACK,MAAM,CAACC,KAAK,CAACF,KAAK,CAAC,EAAE;MACxBF,OAAO,CAACE,KAAK,GAAGA,KAAK;IACvB;IACA,CAAAtB,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEyB,sBAAsB,CAACL,OAAO,EAAEH,KAAK,CAAC;EACnD;EAEAS,MAAMA,CAACP,EAAY;;IACjB,CAAAnB,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAE2B,SAAS,EAAE;IACtBR,EAAE,EAAE;EACN;;AA/BFxB,OAAA,CAAAkB,wBAAA,GAAAA,wBAAA;AAkCA,MAAae,sBACX,SAAQ/C,QAAA,CAAAgD,MAAM;EAId/B,YACWiB,SAAyC,EACzCP,WAA4C;IAErD,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAI,CAAE,CAAC;IAHlB,KAAAM,SAAS,GAATA,SAAS;IACT,KAAAP,WAAW,GAAXA,WAAW;EAGtB;EAEAT,MAAMA,CAAA;;IACJ,CAAAC,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,gBAAgB,CAACpB,WAAA,CAAAM,MAAM,CAACe,SAAS,EAAE,qBAAqB,CAAC;EACtE;EAEAC,OAAOA,CAAA;;IACL,OAAO,CAAAC,EAAA,IAAAL,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEI,OAAO,EAAE,cAAAC,EAAA,cAAAA,EAAA,GAAI,SAAS;EAC1C;EAEAK,KAAKA,CAACC,KAAa;;IACjB,CAAAX,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEY,SAAS,EAAE;EACxB;EAEAI,MAAMA,CAACC,KAAkB,EAAEC,QAAgB,EAAEC,EAAiB;;IAC5D,MAAMC,OAAO,GAAmB;MAC9BC,QAAQ,EAAEF;KACX;IACD,MAAMG,KAAK,GAAGC,MAAM,CAACL,QAAQ,CAAC;IAC9B,IAAI,CAACK,MAAM,CAACC,KAAK,CAACF,KAAK,CAAC,EAAE;MACxBF,OAAO,CAACE,KAAK,GAAGA,KAAK;IACvB;IACA,CAAAtB,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEyB,sBAAsB,CAACL,OAAO,EAAEH,KAAK,CAAC;EACnD;EAEAS,MAAMA,CAACP,EAAY;;IACjB,CAAAnB,EAAA,OAAI,CAACC,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAE2B,SAAS,EAAE;IACtBR,EAAE,EAAE;EACN;;AAtCFxB,OAAA,CAAAiC,sBAAA,GAAAA,sBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}