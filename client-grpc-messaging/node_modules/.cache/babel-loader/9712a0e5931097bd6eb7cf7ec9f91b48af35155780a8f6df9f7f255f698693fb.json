{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getServerInterceptingCall = exports.BaseServerInterceptingCall = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.isInterceptingServerListener = exports.ServerListenerBuilder = void 0;\nconst metadata_1 = require(\"./metadata\");\nconst constants_1 = require(\"./constants\");\nconst http2 = require(\"http2\");\nconst error_1 = require(\"./error\");\nconst zlib = require(\"zlib\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'server_call';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nclass ServerListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n  withOnReceiveHalfClose(onReceiveHalfClose) {\n    this.halfClose = onReceiveHalfClose;\n    return this;\n  }\n  withOnCancel(onCancel) {\n    this.cancel = onCancel;\n    return this;\n  }\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveHalfClose: this.halfClose,\n      onCancel: this.cancel\n    };\n  }\n}\nexports.ServerListenerBuilder = ServerListenerBuilder;\nfunction isInterceptingServerListener(listener) {\n  return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\nexports.isInterceptingServerListener = isInterceptingServerListener;\nclass InterceptingServerListenerImpl {\n  constructor(listener, nextListener) {\n    this.listener = listener;\n    this.nextListener = nextListener;\n    /**\n     * Once the call is cancelled, ignore all other events.\n     */\n    this.cancelled = false;\n    this.processingMetadata = false;\n    this.hasPendingMessage = false;\n    this.pendingMessage = null;\n    this.processingMessage = false;\n    this.hasPendingHalfClose = false;\n  }\n  processPendingMessage() {\n    if (this.hasPendingMessage) {\n      this.nextListener.onReceiveMessage(this.pendingMessage);\n      this.pendingMessage = null;\n      this.hasPendingMessage = false;\n    }\n  }\n  processPendingHalfClose() {\n    if (this.hasPendingHalfClose) {\n      this.nextListener.onReceiveHalfClose();\n      this.hasPendingHalfClose = false;\n    }\n  }\n  onReceiveMetadata(metadata) {\n    if (this.cancelled) {\n      return;\n    }\n    this.processingMetadata = true;\n    this.listener.onReceiveMetadata(metadata, interceptedMetadata => {\n      this.processingMetadata = false;\n      if (this.cancelled) {\n        return;\n      }\n      this.nextListener.onReceiveMetadata(interceptedMetadata);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  onReceiveMessage(message) {\n    if (this.cancelled) {\n      return;\n    }\n    this.processingMessage = true;\n    this.listener.onReceiveMessage(message, msg => {\n      this.processingMessage = false;\n      if (this.cancelled) {\n        return;\n      }\n      if (this.processingMetadata) {\n        this.pendingMessage = msg;\n        this.hasPendingMessage = true;\n      } else {\n        this.nextListener.onReceiveMessage(msg);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  onReceiveHalfClose() {\n    if (this.cancelled) {\n      return;\n    }\n    this.listener.onReceiveHalfClose(() => {\n      if (this.cancelled) {\n        return;\n      }\n      if (this.processingMetadata || this.processingMessage) {\n        this.hasPendingHalfClose = true;\n      } else {\n        this.nextListener.onReceiveHalfClose();\n      }\n    });\n  }\n  onCancel() {\n    this.cancelled = true;\n    this.listener.onCancel();\n    this.nextListener.onCancel();\n  }\n}\nclass ResponderBuilder {\n  constructor() {\n    this.start = undefined;\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n  withSendMetadata(sendMetadata) {\n    this.metadata = sendMetadata;\n    return this;\n  }\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n  withSendStatus(sendStatus) {\n    this.status = sendStatus;\n    return this;\n  }\n  build() {\n    return {\n      start: this.start,\n      sendMetadata: this.metadata,\n      sendMessage: this.message,\n      sendStatus: this.status\n    };\n  }\n}\nexports.ResponderBuilder = ResponderBuilder;\nconst defaultServerListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveHalfClose: next => {\n    next();\n  },\n  onCancel: () => {}\n};\nconst defaultResponder = {\n  start: next => {\n    next();\n  },\n  sendMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  sendStatus: (status, next) => {\n    next(status);\n  }\n};\nclass ServerInterceptingCall {\n  constructor(nextCall, responder) {\n    var _a, _b, _c, _d;\n    this.nextCall = nextCall;\n    this.processingMetadata = false;\n    this.processingMessage = false;\n    this.pendingMessage = null;\n    this.pendingMessageCallback = null;\n    this.pendingStatus = null;\n    this.responder = {\n      start: (_a = responder === null || responder === void 0 ? void 0 : responder.start) !== null && _a !== void 0 ? _a : defaultResponder.start,\n      sendMetadata: (_b = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null && _b !== void 0 ? _b : defaultResponder.sendMetadata,\n      sendMessage: (_c = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null && _c !== void 0 ? _c : defaultResponder.sendMessage,\n      sendStatus: (_d = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null && _d !== void 0 ? _d : defaultResponder.sendStatus\n    };\n  }\n  processPendingMessage() {\n    if (this.pendingMessageCallback) {\n      this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);\n      this.pendingMessage = null;\n      this.pendingMessageCallback = null;\n    }\n  }\n  processPendingStatus() {\n    if (this.pendingStatus) {\n      this.nextCall.sendStatus(this.pendingStatus);\n      this.pendingStatus = null;\n    }\n  }\n  start(listener) {\n    this.responder.start(interceptedListener => {\n      var _a, _b, _c, _d;\n      const fullInterceptedListener = {\n        onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultServerListener.onReceiveMetadata,\n        onReceiveMessage: (_b = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultServerListener.onReceiveMessage,\n        onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null && _c !== void 0 ? _c : defaultServerListener.onReceiveHalfClose,\n        onCancel: (_d = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null && _d !== void 0 ? _d : defaultServerListener.onCancel\n      };\n      const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);\n      this.nextCall.start(finalInterceptingListener);\n    });\n  }\n  sendMetadata(metadata) {\n    this.processingMetadata = true;\n    this.responder.sendMetadata(metadata, interceptedMetadata => {\n      this.processingMetadata = false;\n      this.nextCall.sendMetadata(interceptedMetadata);\n      this.processPendingMessage();\n      this.processPendingStatus();\n    });\n  }\n  sendMessage(message, callback) {\n    this.processingMessage = true;\n    this.responder.sendMessage(message, interceptedMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessage = interceptedMessage;\n        this.pendingMessageCallback = callback;\n      } else {\n        this.nextCall.sendMessage(interceptedMessage, callback);\n      }\n    });\n  }\n  sendStatus(status) {\n    this.responder.sendStatus(status, interceptedStatus => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingStatus = interceptedStatus;\n      } else {\n        this.nextCall.sendStatus(interceptedStatus);\n      }\n    });\n  }\n  startRead() {\n    this.nextCall.startRead();\n  }\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n  getDeadline() {\n    return this.nextCall.getDeadline();\n  }\n  getHost() {\n    return this.nextCall.getHost();\n  }\n}\nexports.ServerInterceptingCall = ServerInterceptingCall;\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultCompressionHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity'\n};\nconst defaultResponseHeaders = {\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\nclass BaseServerInterceptingCall {\n  constructor(stream, headers, callEventTracker, handler, options) {\n    var _a;\n    this.stream = stream;\n    this.callEventTracker = callEventTracker;\n    this.handler = handler;\n    this.listener = null;\n    this.deadlineTimer = null;\n    this.deadline = Infinity;\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.cancelled = false;\n    this.metadataSent = false;\n    this.wantTrailers = false;\n    this.cancelNotified = false;\n    this.incomingEncoding = 'identity';\n    this.readQueue = [];\n    this.isReadPending = false;\n    this.receivedHalfClose = false;\n    this.streamEnded = false;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n      if (this.callEventTracker && !this.streamEnded) {\n        this.streamEnded = true;\n        this.callEventTracker.onStreamEnd(false);\n        this.callEventTracker.onCallEnd({\n          code: constants_1.Status.CANCELLED,\n          details: 'Stream closed before sending status',\n          metadata: null\n        });\n      }\n      this.notifyOnCancel();\n    });\n    this.stream.on('data', data => {\n      this.handleDataFrame(data);\n    });\n    this.stream.pause();\n    this.stream.on('end', () => {\n      this.handleEndEvent();\n    });\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n    this.host = (_a = headers[':authority']) !== null && _a !== void 0 ? _a : headers.host;\n    this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace('Request to ' + this.handler.path + ' received headers ' + JSON.stringify(metadata.toJSON()));\n    }\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n    if (timeoutHeader.length > 0) {\n      this.handleTimeoutHeader(timeoutHeader[0]);\n    }\n    const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);\n    if (encodingHeader.length > 0) {\n      this.incomingEncoding = encodingHeader[0];\n    }\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(GRPC_TIMEOUT_HEADER);\n    metadata.remove(GRPC_ENCODING_HEADER);\n    metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    this.metadata = metadata;\n  }\n  handleTimeoutHeader(timeoutHeader) {\n    const match = timeoutHeader.toString().match(DEADLINE_REGEX);\n    if (match === null) {\n      const status = {\n        code: constants_1.Status.INTERNAL,\n        details: `Invalid ${GRPC_TIMEOUT_HEADER} value \"${timeoutHeader}\"`,\n        metadata: null\n      };\n      // Wait for the constructor to complete before sending the error.\n      process.nextTick(() => {\n        this.sendStatus(status);\n      });\n      return;\n    }\n    const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n    const now = new Date();\n    this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n    this.deadlineTimer = setTimeout(() => {\n      const status = {\n        code: constants_1.Status.DEADLINE_EXCEEDED,\n        details: 'Deadline exceeded',\n        metadata: null\n      };\n      this.sendStatus(status);\n    }, timeout);\n  }\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {\n      this.notifyOnCancel();\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n  notifyOnCancel() {\n    if (this.cancelNotified) {\n      return;\n    }\n    this.cancelNotified = true;\n    this.cancelled = true;\n    process.nextTick(() => {\n      var _a;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onCancel();\n    });\n    if (this.deadlineTimer) {\n      clearTimeout(this.deadlineTimer);\n    }\n    // Flush incoming data frames\n    this.stream.resume();\n  }\n  /**\n   * A server handler can start sending messages without explicitly sending\n   * metadata. In that case, we need to send headers before sending any\n   * messages. This function does that if necessary.\n   */\n  maybeSendMetadata() {\n    if (!this.metadataSent) {\n      this.sendMetadata(new metadata_1.Metadata());\n    }\n  }\n  /**\n   * Serialize a message to a length-delimited byte string.\n   * @param value\n   * @returns\n   */\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value);\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    /* Note: response compression is currently not supported, so this\n     * compressed bit is always 0. */\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  decompressMessage(message, encoding) {\n    const messageContents = message.subarray(5);\n    if (encoding === 'identity') {\n      return messageContents;\n    } else if (encoding === 'deflate' || encoding === 'gzip') {\n      let decompresser;\n      if (encoding === 'deflate') {\n        decompresser = zlib.createInflate();\n      } else {\n        decompresser = zlib.createGunzip();\n      }\n      return new Promise((resolve, reject) => {\n        let totalLength = 0;\n        const messageParts = [];\n        decompresser.on('data', chunk => {\n          messageParts.push(chunk);\n          totalLength += chunk.byteLength;\n          if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\n            decompresser.destroy();\n            reject({\n              code: constants_1.Status.RESOURCE_EXHAUSTED,\n              details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\n            });\n          }\n        });\n        decompresser.on('end', () => {\n          resolve(Buffer.concat(messageParts));\n        });\n        decompresser.write(messageContents);\n        decompresser.end();\n      });\n    } else {\n      return Promise.reject({\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `Received message compressed with unsupported encoding \"${encoding}\"`\n      });\n    }\n  }\n  async decompressAndMaybePush(queueEntry) {\n    if (queueEntry.type !== 'COMPRESSED') {\n      throw new Error(`Invalid queue entry type: ${queueEntry.type}`);\n    }\n    const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;\n    const compressedMessageEncoding = compressed ? this.incomingEncoding : 'identity';\n    let decompressedMessage;\n    try {\n      decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);\n    } catch (err) {\n      this.sendStatus(err);\n      return;\n    }\n    try {\n      queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);\n    } catch (err) {\n      this.sendStatus({\n        code: constants_1.Status.INTERNAL,\n        details: `Error deserializing request: ${err.message}`\n      });\n      return;\n    }\n    queueEntry.type = 'READABLE';\n    this.maybePushNextMessage();\n  }\n  maybePushNextMessage() {\n    if (this.listener && this.isReadPending && this.readQueue.length > 0 && this.readQueue[0].type !== 'COMPRESSED') {\n      this.isReadPending = false;\n      const nextQueueEntry = this.readQueue.shift();\n      if (nextQueueEntry.type === 'READABLE') {\n        this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);\n      } else {\n        // nextQueueEntry.type === 'HALF_CLOSE'\n        this.listener.onReceiveHalfClose();\n      }\n    }\n  }\n  handleDataFrame(data) {\n    var _a;\n    if (this.checkCancelled()) {\n      return;\n    }\n    trace('Request to ' + this.handler.path + ' received data frame of size ' + data.length);\n    let rawMessages;\n    try {\n      rawMessages = this.decoder.write(data);\n    } catch (e) {\n      this.sendStatus({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: e.message\n      });\n      return;\n    }\n    for (const messageBytes of rawMessages) {\n      this.stream.pause();\n      const queueEntry = {\n        type: 'COMPRESSED',\n        compressedMessage: messageBytes,\n        parsedMessage: null\n      };\n      this.readQueue.push(queueEntry);\n      this.decompressAndMaybePush(queueEntry);\n      (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageReceived();\n    }\n  }\n  handleEndEvent() {\n    this.readQueue.push({\n      type: 'HALF_CLOSE',\n      compressedMessage: null,\n      parsedMessage: null\n    });\n    this.receivedHalfClose = true;\n    this.maybePushNextMessage();\n  }\n  start(listener) {\n    trace('Request to ' + this.handler.path + ' start called');\n    if (this.checkCancelled()) {\n      return;\n    }\n    this.listener = listener;\n    listener.onReceiveMetadata(this.metadata);\n  }\n  sendMetadata(metadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.metadataSent) {\n      return;\n    }\n    this.metadataSent = true;\n    const custom = metadata ? metadata.toHttp2Headers() : null;\n    const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n  sendMessage(message, callback) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    let response;\n    try {\n      response = this.serializeMessage(message);\n    } catch (e) {\n      this.sendStatus({\n        code: constants_1.Status.INTERNAL,\n        details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,\n        metadata: null\n      });\n      return;\n    }\n    if (this.maxSendMessageSize !== -1 && response.length - 5 > this.maxSendMessageSize) {\n      this.sendStatus({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,\n        metadata: null\n      });\n      return;\n    }\n    this.maybeSendMetadata();\n    trace('Request to ' + this.handler.path + ' sent data frame of size ' + response.length);\n    this.stream.write(response, error => {\n      var _a;\n      if (error) {\n        this.sendStatus({\n          code: constants_1.Status.INTERNAL,\n          details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,\n          metadata: null\n        });\n        return;\n      }\n      (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n      callback();\n    });\n  }\n  sendStatus(status) {\n    var _a, _b;\n    if (this.checkCancelled()) {\n      return;\n    }\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[status.code] + ' details: ' + status.details);\n    if (this.metadataSent) {\n      if (!this.wantTrailers) {\n        this.wantTrailers = true;\n        this.stream.once('wantTrailers', () => {\n          var _a;\n          if (this.callEventTracker && !this.streamEnded) {\n            this.streamEnded = true;\n            this.callEventTracker.onStreamEnd(true);\n            this.callEventTracker.onCallEnd(status);\n          }\n          const trailersToSend = Object.assign({\n            [GRPC_STATUS_HEADER]: status.code,\n            [GRPC_MESSAGE_HEADER]: encodeURI(status.details)\n          }, (_a = status.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n          this.stream.sendTrailers(trailersToSend);\n          this.notifyOnCancel();\n        });\n        this.stream.end();\n      } else {\n        this.notifyOnCancel();\n      }\n    } else {\n      if (this.callEventTracker && !this.streamEnded) {\n        this.streamEnded = true;\n        this.callEventTracker.onStreamEnd(true);\n        this.callEventTracker.onCallEnd(status);\n      }\n      // Trailers-only response\n      const trailersToSend = Object.assign(Object.assign({\n        [GRPC_STATUS_HEADER]: status.code,\n        [GRPC_MESSAGE_HEADER]: encodeURI(status.details)\n      }, defaultResponseHeaders), (_b = status.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\n      this.stream.respond(trailersToSend, {\n        endStream: true\n      });\n      this.notifyOnCancel();\n    }\n  }\n  startRead() {\n    trace('Request to ' + this.handler.path + ' startRead called');\n    if (this.checkCancelled()) {\n      return;\n    }\n    this.isReadPending = true;\n    if (this.readQueue.length === 0) {\n      if (!this.receivedHalfClose) {\n        this.stream.resume();\n      }\n    } else {\n      this.maybePushNextMessage();\n    }\n  }\n  getPeer() {\n    var _a;\n    const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\n    if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n  getDeadline() {\n    return this.deadline;\n  }\n  getHost() {\n    return this.host;\n  }\n}\nexports.BaseServerInterceptingCall = BaseServerInterceptingCall;\nfunction getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {\n  const methodDefinition = {\n    path: handler.path,\n    requestStream: handler.type === 'clientStream' || handler.type === 'bidi',\n    responseStream: handler.type === 'serverStream' || handler.type === 'bidi',\n    requestDeserialize: handler.deserialize,\n    responseSerialize: handler.serialize\n  };\n  const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);\n  return interceptors.reduce((call, interceptor) => {\n    return interceptor(methodDefinition, call);\n  }, baseCall);\n}\nexports.getServerInterceptingCall = getServerInterceptingCall;","map":{"version":3,"names":["metadata_1","require","constants_1","http2","error_1","zlib","stream_decoder_1","logging","TRACER_NAME","trace","text","LogVerbosity","DEBUG","ServerListenerBuilder","constructor","metadata","undefined","message","halfClose","cancel","withOnReceiveMetadata","onReceiveMetadata","withOnReceiveMessage","onReceiveMessage","withOnReceiveHalfClose","onReceiveHalfClose","withOnCancel","onCancel","build","exports","isInterceptingServerListener","listener","length","InterceptingServerListenerImpl","nextListener","cancelled","processingMetadata","hasPendingMessage","pendingMessage","processingMessage","hasPendingHalfClose","processPendingMessage","processPendingHalfClose","interceptedMetadata","msg","ResponderBuilder","start","status","withStart","withSendMetadata","sendMetadata","withSendMessage","sendMessage","withSendStatus","sendStatus","defaultServerListener","next","defaultResponder","ServerInterceptingCall","nextCall","responder","pendingMessageCallback","pendingStatus","_a","_b","_c","_d","processPendingStatus","interceptedListener","fullInterceptedListener","finalInterceptingListener","callback","interceptedMessage","interceptedStatus","startRead","getPeer","getDeadline","getHost","GRPC_ACCEPT_ENCODING_HEADER","GRPC_ENCODING_HEADER","GRPC_MESSAGE_HEADER","GRPC_STATUS_HEADER","GRPC_TIMEOUT_HEADER","DEADLINE_REGEX","deadlineUnitsToMs","H","M","S","m","u","n","defaultCompressionHeaders","defaultResponseHeaders","constants","HTTP2_HEADER_STATUS","HTTP_STATUS_OK","HTTP2_HEADER_CONTENT_TYPE","defaultResponseOptions","waitForTrailers","BaseServerInterceptingCall","stream","headers","callEventTracker","handler","options","deadlineTimer","deadline","Infinity","maxSendMessageSize","DEFAULT_MAX_SEND_MESSAGE_LENGTH","maxReceiveMessageSize","DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH","metadataSent","wantTrailers","cancelNotified","incomingEncoding","readQueue","isReadPending","receivedHalfClose","streamEnded","once","err","path","rstCode","onStreamEnd","onCallEnd","code","Status","CANCELLED","details","notifyOnCancel","on","data","handleDataFrame","pause","handleEndEvent","host","decoder","StreamDecoder","Metadata","fromHttp2Headers","isTracerEnabled","JSON","stringify","toJSON","timeoutHeader","get","handleTimeoutHeader","encodingHeader","remove","HTTP2_HEADER_ACCEPT_ENCODING","HTTP2_HEADER_TE","match","toString","INTERNAL","process","nextTick","timeout","now","Date","setMilliseconds","getMilliseconds","setTimeout","DEADLINE_EXCEEDED","checkCancelled","destroyed","closed","clearTimeout","resume","maybeSendMetadata","serializeMessage","value","messageBuffer","serialize","byteLength","output","Buffer","allocUnsafe","writeUInt8","writeUInt32BE","copy","decompressMessage","encoding","messageContents","subarray","decompresser","createInflate","createGunzip","Promise","resolve","reject","totalLength","messageParts","chunk","push","destroy","RESOURCE_EXHAUSTED","concat","write","end","UNIMPLEMENTED","decompressAndMaybePush","queueEntry","type","Error","compressed","compressedMessage","readUInt8","compressedMessageEncoding","decompressedMessage","parsedMessage","deserialize","maybePushNextMessage","nextQueueEntry","shift","rawMessages","e","messageBytes","addMessageReceived","custom","toHttp2Headers","Object","assign","respond","response","getErrorMessage","error","addMessageSent","trailersToSend","encodeURI","sendTrailers","endStream","socket","session","remoteAddress","remotePort","getServerInterceptingCall","interceptors","methodDefinition","requestStream","responseStream","requestDeserialize","responseSerialize","baseCall","reduce","call","interceptor"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/server-interceptors.ts"],"sourcesContent":["/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { PartialStatusObject } from './call-interface';\nimport { ServerMethodDefinition } from './make-client';\nimport { Metadata } from './metadata';\nimport { ChannelOptions } from './channel-options';\nimport { Handler, ServerErrorResponse } from './server-call';\nimport { Deadline } from './deadline';\nimport {\n  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,\n  DEFAULT_MAX_SEND_MESSAGE_LENGTH,\n  LogVerbosity,\n  Status,\n} from './constants';\nimport * as http2 from 'http2';\nimport { getErrorMessage } from './error';\nimport * as zlib from 'zlib';\nimport { StreamDecoder } from './stream-decoder';\nimport { CallEventTracker } from './transport';\nimport * as logging from './logging';\n\nconst TRACER_NAME = 'server_call';\n\nfunction trace(text: string) {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nexport interface ServerMetadataListener {\n  (metadata: Metadata, next: (metadata: Metadata) => void): void;\n}\n\nexport interface ServerMessageListener {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface ServerHalfCloseListener {\n  (next: () => void): void;\n}\n\nexport interface ServerCancelListener {\n  (): void;\n}\n\nexport interface FullServerListener {\n  onReceiveMetadata: ServerMetadataListener;\n  onReceiveMessage: ServerMessageListener;\n  onReceiveHalfClose: ServerHalfCloseListener;\n  onCancel: ServerCancelListener;\n}\n\nexport type ServerListener = Partial<FullServerListener>;\n\nexport class ServerListenerBuilder {\n  private metadata: ServerMetadataListener | undefined = undefined;\n  private message: ServerMessageListener | undefined = undefined;\n  private halfClose: ServerHalfCloseListener | undefined = undefined;\n  private cancel: ServerCancelListener | undefined = undefined;\n\n  withOnReceiveMetadata(onReceiveMetadata: ServerMetadataListener): this {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage: ServerMessageListener): this {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveHalfClose(onReceiveHalfClose: ServerHalfCloseListener): this {\n    this.halfClose = onReceiveHalfClose;\n    return this;\n  }\n\n  withOnCancel(onCancel: ServerCancelListener): this {\n    this.cancel = onCancel;\n    return this;\n  }\n\n  build(): ServerListener {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveHalfClose: this.halfClose,\n      onCancel: this.cancel,\n    };\n  }\n}\n\nexport interface InterceptingServerListener {\n  onReceiveMetadata(metadata: Metadata): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onReceiveMessage(message: any): void;\n  onReceiveHalfClose(): void;\n  onCancel(): void;\n}\n\nexport function isInterceptingServerListener(\n  listener: ServerListener | InterceptingServerListener\n): listener is InterceptingServerListener {\n  return (\n    listener.onReceiveMetadata !== undefined &&\n    listener.onReceiveMetadata.length === 1\n  );\n}\n\nclass InterceptingServerListenerImpl implements InterceptingServerListener {\n  /**\n   * Once the call is cancelled, ignore all other events.\n   */\n  private cancelled = false;\n  private processingMetadata = false;\n  private hasPendingMessage = false;\n  private pendingMessage: any = null;\n  private processingMessage = false;\n  private hasPendingHalfClose = false;\n\n  constructor(\n    private listener: FullServerListener,\n    private nextListener: InterceptingServerListener\n  ) {}\n\n  private processPendingMessage() {\n    if (this.hasPendingMessage) {\n      this.nextListener.onReceiveMessage(this.pendingMessage);\n      this.pendingMessage = null;\n      this.hasPendingMessage = false;\n    }\n  }\n\n  private processPendingHalfClose() {\n    if (this.hasPendingHalfClose) {\n      this.nextListener.onReceiveHalfClose();\n      this.hasPendingHalfClose = false;\n    }\n  }\n\n  onReceiveMetadata(metadata: Metadata): void {\n    if (this.cancelled) {\n      return;\n    }\n    this.processingMetadata = true;\n    this.listener.onReceiveMetadata(metadata, interceptedMetadata => {\n      this.processingMetadata = false;\n      if (this.cancelled) {\n        return;\n      }\n      this.nextListener.onReceiveMetadata(interceptedMetadata);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  onReceiveMessage(message: any): void {\n    if (this.cancelled) {\n      return;\n    }\n    this.processingMessage = true;\n    this.listener.onReceiveMessage(message, msg => {\n      this.processingMessage = false;\n      if (this.cancelled) {\n        return;\n      }\n      if (this.processingMetadata) {\n        this.pendingMessage = msg;\n        this.hasPendingMessage = true;\n      } else {\n        this.nextListener.onReceiveMessage(msg);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  onReceiveHalfClose(): void {\n    if (this.cancelled) {\n      return;\n    }\n    this.listener.onReceiveHalfClose(() => {\n      if (this.cancelled) {\n        return;\n      }\n      if (this.processingMetadata || this.processingMessage) {\n        this.hasPendingHalfClose = true;\n      } else {\n        this.nextListener.onReceiveHalfClose();\n      }\n    });\n  }\n  onCancel(): void {\n    this.cancelled = true;\n    this.listener.onCancel();\n    this.nextListener.onCancel();\n  }\n}\n\nexport interface StartResponder {\n  (next: (listener?: ServerListener) => void): void;\n}\n\nexport interface MetadataResponder {\n  (metadata: Metadata, next: (metadata: Metadata) => void): void;\n}\n\nexport interface MessageResponder {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface StatusResponder {\n  (\n    status: PartialStatusObject,\n    next: (status: PartialStatusObject) => void\n  ): void;\n}\n\nexport interface FullResponder {\n  start: StartResponder;\n  sendMetadata: MetadataResponder;\n  sendMessage: MessageResponder;\n  sendStatus: StatusResponder;\n}\n\nexport type Responder = Partial<FullResponder>;\n\nexport class ResponderBuilder {\n  private start: StartResponder | undefined = undefined;\n  private metadata: MetadataResponder | undefined = undefined;\n  private message: MessageResponder | undefined = undefined;\n  private status: StatusResponder | undefined = undefined;\n\n  withStart(start: StartResponder): this {\n    this.start = start;\n    return this;\n  }\n\n  withSendMetadata(sendMetadata: MetadataResponder): this {\n    this.metadata = sendMetadata;\n    return this;\n  }\n\n  withSendMessage(sendMessage: MessageResponder): this {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withSendStatus(sendStatus: StatusResponder): this {\n    this.status = sendStatus;\n    return this;\n  }\n\n  build(): Responder {\n    return {\n      start: this.start,\n      sendMetadata: this.metadata,\n      sendMessage: this.message,\n      sendStatus: this.status,\n    };\n  }\n}\n\nconst defaultServerListener: FullServerListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveHalfClose: next => {\n    next();\n  },\n  onCancel: () => {},\n};\n\nconst defaultResponder: FullResponder = {\n  start: next => {\n    next();\n  },\n  sendMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  sendStatus: (status, next) => {\n    next(status);\n  },\n};\n\nexport interface ServerInterceptingCallInterface {\n  /**\n   * Register the listener to handle inbound events.\n   */\n  start(listener: InterceptingServerListener): void;\n  /**\n   * Send response metadata.\n   */\n  sendMetadata(metadata: Metadata): void;\n  /**\n   * Send a response message.\n   */\n  sendMessage(message: any, callback: () => void): void;\n  /**\n   * End the call by sending this status.\n   */\n  sendStatus(status: PartialStatusObject): void;\n  /**\n   * Start a single read, eventually triggering either listener.onReceiveMessage or listener.onReceiveHalfClose.\n   */\n  startRead(): void;\n  /**\n   * Return the peer address of the client making the request, if known, or \"unknown\" otherwise\n   */\n  getPeer(): string;\n  /**\n   * Return the call deadline set by the client. The value is Infinity if there is no deadline.\n   */\n  getDeadline(): Deadline;\n  /**\n   * Return the host requested by the client in the \":authority\" header.\n   */\n  getHost(): string;\n}\n\nexport class ServerInterceptingCall implements ServerInterceptingCallInterface {\n  private responder: FullResponder;\n  private processingMetadata = false;\n  private processingMessage = false;\n  private pendingMessage: any = null;\n  private pendingMessageCallback: (() => void) | null = null;\n  private pendingStatus: PartialStatusObject | null = null;\n  constructor(\n    private nextCall: ServerInterceptingCallInterface,\n    responder?: Responder\n  ) {\n    this.responder = {\n      start: responder?.start ?? defaultResponder.start,\n      sendMetadata: responder?.sendMetadata ?? defaultResponder.sendMetadata,\n      sendMessage: responder?.sendMessage ?? defaultResponder.sendMessage,\n      sendStatus: responder?.sendStatus ?? defaultResponder.sendStatus,\n    };\n  }\n\n  private processPendingMessage() {\n    if (this.pendingMessageCallback) {\n      this.nextCall.sendMessage(\n        this.pendingMessage,\n        this.pendingMessageCallback\n      );\n      this.pendingMessage = null;\n      this.pendingMessageCallback = null;\n    }\n  }\n\n  private processPendingStatus() {\n    if (this.pendingStatus) {\n      this.nextCall.sendStatus(this.pendingStatus);\n      this.pendingStatus = null;\n    }\n  }\n\n  start(listener: InterceptingServerListener): void {\n    this.responder.start(interceptedListener => {\n      const fullInterceptedListener: FullServerListener = {\n        onReceiveMetadata:\n          interceptedListener?.onReceiveMetadata ??\n          defaultServerListener.onReceiveMetadata,\n        onReceiveMessage:\n          interceptedListener?.onReceiveMessage ??\n          defaultServerListener.onReceiveMessage,\n        onReceiveHalfClose:\n          interceptedListener?.onReceiveHalfClose ??\n          defaultServerListener.onReceiveHalfClose,\n        onCancel:\n          interceptedListener?.onCancel ?? defaultServerListener.onCancel,\n      };\n      const finalInterceptingListener = new InterceptingServerListenerImpl(\n        fullInterceptedListener,\n        listener\n      );\n      this.nextCall.start(finalInterceptingListener);\n    });\n  }\n  sendMetadata(metadata: Metadata): void {\n    this.processingMetadata = true;\n    this.responder.sendMetadata(metadata, interceptedMetadata => {\n      this.processingMetadata = false;\n      this.nextCall.sendMetadata(interceptedMetadata);\n      this.processPendingMessage();\n      this.processPendingStatus();\n    });\n  }\n  sendMessage(message: any, callback: () => void): void {\n    this.processingMessage = true;\n    this.responder.sendMessage(message, interceptedMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessage = interceptedMessage;\n        this.pendingMessageCallback = callback;\n      } else {\n        this.nextCall.sendMessage(interceptedMessage, callback);\n      }\n    });\n  }\n  sendStatus(status: PartialStatusObject): void {\n    this.responder.sendStatus(status, interceptedStatus => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingStatus = interceptedStatus;\n      } else {\n        this.nextCall.sendStatus(interceptedStatus);\n      }\n    });\n  }\n  startRead(): void {\n    this.nextCall.startRead();\n  }\n  getPeer(): string {\n    return this.nextCall.getPeer();\n  }\n  getDeadline(): Deadline {\n    return this.nextCall.getDeadline();\n  }\n  getHost(): string {\n    return this.nextCall.getHost();\n  }\n}\n\nexport interface ServerInterceptor {\n  (\n    methodDescriptor: ServerMethodDefinition<any, any>,\n    call: ServerInterceptingCallInterface\n  ): ServerInterceptingCall;\n}\n\ninterface DeadlineUnitIndexSignature {\n  [name: string]: number;\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs: DeadlineUnitIndexSignature = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001,\n};\n\nconst defaultCompressionHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n};\nconst defaultResponseHeaders = {\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true,\n} as http2.ServerStreamResponseOptions;\n\ntype ReadQueueEntryType = 'COMPRESSED' | 'READABLE' | 'HALF_CLOSE';\n\ninterface ReadQueueEntry {\n  type: ReadQueueEntryType;\n  compressedMessage: Buffer | null;\n  parsedMessage: any;\n}\n\nexport class BaseServerInterceptingCall\n  implements ServerInterceptingCallInterface\n{\n  private listener: InterceptingServerListener | null = null;\n  private metadata: Metadata;\n  private deadlineTimer: NodeJS.Timeout | null = null;\n  private deadline: Deadline = Infinity;\n  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n  private cancelled = false;\n  private metadataSent = false;\n  private wantTrailers = false;\n  private cancelNotified = false;\n  private incomingEncoding = 'identity';\n  private decoder: StreamDecoder;\n  private readQueue: ReadQueueEntry[] = [];\n  private isReadPending = false;\n  private receivedHalfClose = false;\n  private streamEnded = false;\n  private host: string;\n\n  constructor(\n    private readonly stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders,\n    private readonly callEventTracker: CallEventTracker | null,\n    private readonly handler: Handler<any, any>,\n    options: ChannelOptions\n  ) {\n    this.stream.once('error', (err: ServerErrorResponse) => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n\n    this.stream.once('close', () => {\n      trace(\n        'Request to method ' +\n          this.handler?.path +\n          ' stream closed with rstCode ' +\n          this.stream.rstCode\n      );\n\n      if (this.callEventTracker && !this.streamEnded) {\n        this.streamEnded = true;\n        this.callEventTracker.onStreamEnd(false);\n        this.callEventTracker.onCallEnd({\n          code: Status.CANCELLED,\n          details: 'Stream closed before sending status',\n          metadata: null,\n        });\n      }\n\n      this.notifyOnCancel();\n    });\n\n    this.stream.on('data', (data: Buffer) => {\n      this.handleDataFrame(data);\n    });\n    this.stream.pause();\n\n    this.stream.on('end', () => {\n      this.handleEndEvent();\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length']!;\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;\n    }\n\n    this.host = headers[':authority'] ?? headers.host!;\n    this.decoder = new StreamDecoder(this.maxReceiveMessageSize);\n\n    const metadata = Metadata.fromHttp2Headers(headers);\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace(\n        'Request to ' +\n          this.handler.path +\n          ' received headers ' +\n          JSON.stringify(metadata.toJSON())\n      );\n    }\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      this.handleTimeoutHeader(timeoutHeader[0] as string);\n    }\n\n    const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);\n\n    if (encodingHeader.length > 0) {\n      this.incomingEncoding = encodingHeader[0] as string;\n    }\n\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(GRPC_TIMEOUT_HEADER);\n    metadata.remove(GRPC_ENCODING_HEADER);\n    metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    this.metadata = metadata;\n  }\n\n  private handleTimeoutHeader(timeoutHeader: string) {\n    const match = timeoutHeader.toString().match(DEADLINE_REGEX);\n\n    if (match === null) {\n      const status: PartialStatusObject = {\n        code: Status.INTERNAL,\n        details: `Invalid ${GRPC_TIMEOUT_HEADER} value \"${timeoutHeader}\"`,\n        metadata: null,\n      };\n      // Wait for the constructor to complete before sending the error.\n      process.nextTick(() => {\n        this.sendStatus(status);\n      });\n      return;\n    }\n\n    const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n\n    const now = new Date();\n    this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n    this.deadlineTimer = setTimeout(() => {\n      const status: PartialStatusObject = {\n        code: Status.DEADLINE_EXCEEDED,\n        details: 'Deadline exceeded',\n        metadata: null,\n      };\n      this.sendStatus(status);\n    }, timeout);\n  }\n\n  private checkCancelled(): boolean {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {\n      this.notifyOnCancel();\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n  private notifyOnCancel() {\n    if (this.cancelNotified) {\n      return;\n    }\n    this.cancelNotified = true;\n    this.cancelled = true;\n    process.nextTick(() => {\n      this.listener?.onCancel();\n    });\n    if (this.deadlineTimer) {\n      clearTimeout(this.deadlineTimer);\n    }\n    // Flush incoming data frames\n    this.stream.resume();\n  }\n\n  /**\n   * A server handler can start sending messages without explicitly sending\n   * metadata. In that case, we need to send headers before sending any\n   * messages. This function does that if necessary.\n   */\n  private maybeSendMetadata() {\n    if (!this.metadataSent) {\n      this.sendMetadata(new Metadata());\n    }\n  }\n\n  /**\n   * Serialize a message to a length-delimited byte string.\n   * @param value\n   * @returns\n   */\n  private serializeMessage(value: any) {\n    const messageBuffer = this.handler.serialize(value);\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    /* Note: response compression is currently not supported, so this\n     * compressed bit is always 0. */\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  private decompressMessage(\n    message: Buffer,\n    encoding: string\n  ): Buffer | Promise<Buffer> {\n    const messageContents = message.subarray(5);\n    if (encoding === 'identity') {\n      return messageContents;\n    } else if (encoding === 'deflate' || encoding === 'gzip') {\n      let decompresser: zlib.Gunzip | zlib.Deflate;\n      if (encoding === 'deflate') {\n        decompresser = zlib.createInflate();\n      } else {\n        decompresser = zlib.createGunzip();\n      }\n      return new Promise((resolve, reject) => {\n        let totalLength = 0\n        const messageParts: Buffer[] = [];\n        decompresser.on('data', (chunk: Buffer) => {\n          messageParts.push(chunk);\n          totalLength += chunk.byteLength;\n          if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\n            decompresser.destroy();\n            reject({\n              code: Status.RESOURCE_EXHAUSTED,\n              details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\n            });\n          }\n        });\n        decompresser.on('end', () => {\n          resolve(Buffer.concat(messageParts));\n        });\n        decompresser.write(messageContents);\n        decompresser.end();\n      });\n    } else {\n      return Promise.reject({\n        code: Status.UNIMPLEMENTED,\n        details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n      });\n    }\n  }\n\n  private async decompressAndMaybePush(queueEntry: ReadQueueEntry) {\n    if (queueEntry.type !== 'COMPRESSED') {\n      throw new Error(`Invalid queue entry type: ${queueEntry.type}`);\n    }\n\n    const compressed = queueEntry.compressedMessage!.readUInt8(0) === 1;\n    const compressedMessageEncoding = compressed\n      ? this.incomingEncoding\n      : 'identity';\n    let decompressedMessage: Buffer;\n    try {\n      decompressedMessage = await this.decompressMessage(\n        queueEntry.compressedMessage!,\n        compressedMessageEncoding\n      );\n    } catch (err) {\n      this.sendStatus(err as PartialStatusObject);\n      return;\n    }\n    try {\n      queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);\n    } catch (err) {\n      this.sendStatus({\n        code: Status.INTERNAL,\n        details: `Error deserializing request: ${(err as Error).message}`,\n      });\n      return;\n    }\n    queueEntry.type = 'READABLE';\n    this.maybePushNextMessage();\n  }\n\n  private maybePushNextMessage() {\n    if (\n      this.listener &&\n      this.isReadPending &&\n      this.readQueue.length > 0 &&\n      this.readQueue[0].type !== 'COMPRESSED'\n    ) {\n      this.isReadPending = false;\n      const nextQueueEntry = this.readQueue.shift()!;\n      if (nextQueueEntry.type === 'READABLE') {\n        this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);\n      } else {\n        // nextQueueEntry.type === 'HALF_CLOSE'\n        this.listener.onReceiveHalfClose();\n      }\n    }\n  }\n\n  private handleDataFrame(data: Buffer) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    trace(\n      'Request to ' +\n        this.handler.path +\n        ' received data frame of size ' +\n        data.length\n    );\n    let rawMessages: Buffer[];\n    try {\n      rawMessages = this.decoder.write(data);\n    } catch (e) {\n      this.sendStatus({ code: Status.RESOURCE_EXHAUSTED, details: (e as Error).message });\n      return;\n    }\n\n    for (const messageBytes of rawMessages) {\n      this.stream.pause();\n      const queueEntry: ReadQueueEntry = {\n        type: 'COMPRESSED',\n        compressedMessage: messageBytes,\n        parsedMessage: null,\n      };\n      this.readQueue.push(queueEntry);\n      this.decompressAndMaybePush(queueEntry);\n      this.callEventTracker?.addMessageReceived();\n    }\n  }\n  private handleEndEvent() {\n    this.readQueue.push({\n      type: 'HALF_CLOSE',\n      compressedMessage: null,\n      parsedMessage: null,\n    });\n    this.receivedHalfClose = true;\n    this.maybePushNextMessage();\n  }\n  start(listener: InterceptingServerListener): void {\n    trace('Request to ' + this.handler.path + ' start called');\n    if (this.checkCancelled()) {\n      return;\n    }\n    this.listener = listener;\n    listener.onReceiveMetadata(this.metadata);\n  }\n  sendMetadata(metadata: Metadata): void {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = metadata ? metadata.toHttp2Headers() : null;\n    const headers = {\n      ...defaultResponseHeaders,\n      ...defaultCompressionHeaders,\n      ...custom,\n    };\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n  sendMessage(message: any, callback: () => void): void {\n    if (this.checkCancelled()) {\n      return;\n    }\n    let response: Buffer;\n    try {\n      response = this.serializeMessage(message);\n    } catch (e) {\n      this.sendStatus({\n        code: Status.INTERNAL,\n        details: `Error serializing response: ${getErrorMessage(e)}`,\n        metadata: null,\n      });\n      return;\n    }\n\n    if (\n      this.maxSendMessageSize !== -1 &&\n      response.length - 5 > this.maxSendMessageSize\n    ) {\n      this.sendStatus({\n        code: Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,\n        metadata: null,\n      });\n      return;\n    }\n    this.maybeSendMetadata();\n    trace(\n      'Request to ' +\n        this.handler.path +\n        ' sent data frame of size ' +\n        response.length\n    );\n    this.stream.write(response, error => {\n      if (error) {\n        this.sendStatus({\n          code: Status.INTERNAL,\n          details: `Error writing message: ${getErrorMessage(error)}`,\n          metadata: null,\n        });\n        return;\n      }\n      this.callEventTracker?.addMessageSent();\n      callback();\n    });\n  }\n  sendStatus(status: PartialStatusObject): void {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace(\n      'Request to method ' +\n        this.handler?.path +\n        ' ended with status code: ' +\n        Status[status.code] +\n        ' details: ' +\n        status.details\n    );\n\n    if (this.metadataSent) {\n      if (!this.wantTrailers) {\n        this.wantTrailers = true;\n        this.stream.once('wantTrailers', () => {\n          if (this.callEventTracker && !this.streamEnded) {\n            this.streamEnded = true;\n            this.callEventTracker.onStreamEnd(true);\n            this.callEventTracker.onCallEnd(status);\n          }\n          const trailersToSend = {\n            [GRPC_STATUS_HEADER]: status.code,\n            [GRPC_MESSAGE_HEADER]: encodeURI(status.details),\n            ...status.metadata?.toHttp2Headers(),\n          };\n\n          this.stream.sendTrailers(trailersToSend);\n          this.notifyOnCancel();\n        });\n        this.stream.end();\n      } else {\n        this.notifyOnCancel();\n      }\n    } else {\n      if (this.callEventTracker && !this.streamEnded) {\n        this.streamEnded = true;\n        this.callEventTracker.onStreamEnd(true);\n        this.callEventTracker.onCallEnd(status);\n      }\n      // Trailers-only response\n      const trailersToSend = {\n        [GRPC_STATUS_HEADER]: status.code,\n        [GRPC_MESSAGE_HEADER]: encodeURI(status.details),\n        ...defaultResponseHeaders,\n        ...status.metadata?.toHttp2Headers(),\n      };\n      this.stream.respond(trailersToSend, { endStream: true });\n      this.notifyOnCancel();\n    }\n  }\n  startRead(): void {\n    trace('Request to ' + this.handler.path + ' startRead called');\n    if (this.checkCancelled()) {\n      return;\n    }\n    this.isReadPending = true;\n    if (this.readQueue.length === 0) {\n      if (!this.receivedHalfClose) {\n        this.stream.resume();\n      }\n    } else {\n      this.maybePushNextMessage();\n    }\n  }\n  getPeer(): string {\n    const socket = this.stream.session?.socket;\n    if (socket?.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n  getDeadline(): Deadline {\n    return this.deadline;\n  }\n  getHost(): string {\n    return this.host;\n  }\n}\n\nexport function getServerInterceptingCall(\n  interceptors: ServerInterceptor[],\n  stream: http2.ServerHttp2Stream,\n  headers: http2.IncomingHttpHeaders,\n  callEventTracker: CallEventTracker | null,\n  handler: Handler<any, any>,\n  options: ChannelOptions\n) {\n  const methodDefinition: ServerMethodDefinition<any, any> = {\n    path: handler.path,\n    requestStream: handler.type === 'clientStream' || handler.type === 'bidi',\n    responseStream: handler.type === 'serverStream' || handler.type === 'bidi',\n    requestDeserialize: handler.deserialize,\n    responseSerialize: handler.serialize,\n  };\n  const baseCall = new BaseServerInterceptingCall(\n    stream,\n    headers,\n    callEventTracker,\n    handler,\n    options\n  );\n  return interceptors.reduce(\n    (call: ServerInterceptingCallInterface, interceptor: ServerInterceptor) => {\n      return interceptor(methodDefinition, call);\n    },\n    baseCall\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}