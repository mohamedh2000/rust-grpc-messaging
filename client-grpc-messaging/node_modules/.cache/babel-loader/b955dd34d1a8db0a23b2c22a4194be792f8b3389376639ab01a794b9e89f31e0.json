{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelConnector = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst channelz_1 = require(\"./channelz\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst logging = require(\"./logging\");\nconst resolver_1 = require(\"./resolver\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net = require(\"net\");\nconst subchannel_call_1 = require(\"./subchannel-call\");\nconst call_number_1 = require(\"./call-number\");\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\nconst clientVersion = require('../../package.json').version;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Http2Transport {\n  constructor(session, subchannelAddress, options,\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  remoteName) {\n    this.session = session;\n    this.options = options;\n    this.remoteName = remoteName;\n    /**\n     * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.\n     */\n    this.keepaliveTimer = null;\n    /**\n     * Indicates that the keepalive timer ran out while there were no active\n     * calls, and a ping should be sent the next time a call starts.\n     */\n    this.pendingSendKeepalivePing = false;\n    this.activeCalls = new Set();\n    this.disconnectListeners = [];\n    this.disconnectHandled = false;\n    this.channelzEnabled = true;\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    /* Populate subchannelAddressString and channelzRef before doing anything\n     * else, because they are used in the trace methods. */\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\n    } else {\n      this.streamTracker = new channelz_1.ChannelzCallTracker();\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    } else {\n      this.keepaliveTimeMs = -1;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    } else {\n      this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    session.once('close', () => {\n      this.trace('session closed');\n      this.handleDisconnect();\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      let tooManyPings = false;\n      /* See the last paragraph of\n       * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n      if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData && opaqueData.equals(tooManyPingsData)) {\n        tooManyPings = true;\n      }\n      this.trace('connection closed by GOAWAY with code ' + errorCode + ' and data ' + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\n      this.reportDisconnectToOwner(tooManyPings);\n    });\n    session.once('error', error => {\n      this.trace('connection closed with error ' + error.message);\n      this.handleDisconnect();\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n    /* Start the keepalive timer last, because this can trigger trace logs,\n     * which should only happen after everything else is set up. */\n    if (this.keepaliveWithoutCalls) {\n      this.maybeStartKeepalivePingTimer();\n    }\n  }\n  getChannelzInfo() {\n    var _a, _b, _c;\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  reportDisconnectToOwner(tooManyPings) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  handleDisconnect() {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.clearKeepaliveTimeout();\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n      this.session.destroy();\n    });\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n  canSendPing() {\n    return !this.session.destroyed && this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);\n  }\n  maybeSendPing() {\n    var _a, _b;\n    if (!this.canSendPing()) {\n      this.pendingSendKeepalivePing = true;\n      return;\n    }\n    if (this.keepaliveTimer) {\n      console.error('keepaliveTimeout is not null');\n      return;\n    }\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimer = setTimeout(() => {\n      this.keepaliveTimer = null;\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    let pingSendError = '';\n    try {\n      const pingSentSuccessfully = this.session.ping((err, duration, payload) => {\n        this.clearKeepaliveTimeout();\n        if (err) {\n          this.keepaliveTrace('Ping failed with error ' + err.message);\n          this.handleDisconnect();\n        } else {\n          this.keepaliveTrace('Received ping response');\n          this.maybeStartKeepalivePingTimer();\n        }\n      });\n      if (!pingSentSuccessfully) {\n        pingSendError = 'Ping returned false';\n      }\n    } catch (e) {\n      // grpc/grpc-node#2139\n      pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n    }\n    if (pingSendError) {\n      this.keepaliveTrace('Ping send failed: ' + pingSendError);\n      this.handleDisconnect();\n    }\n  }\n  /**\n   * Starts the keepalive ping timer if appropriate. If the timer already ran\n   * out while there were no active requests, instead send a ping immediately.\n   * If the ping timer is already running or a ping is currently in flight,\n   * instead do nothing and wait for them to resolve.\n   */\n  maybeStartKeepalivePingTimer() {\n    var _a, _b;\n    if (!this.canSendPing()) {\n      return;\n    }\n    if (this.pendingSendKeepalivePing) {\n      this.pendingSendKeepalivePing = false;\n      this.maybeSendPing();\n    } else if (!this.keepaliveTimer) {\n      this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n      this.keepaliveTimer = setTimeout(() => {\n        this.keepaliveTimer = null;\n        this.maybeSendPing();\n      }, this.keepaliveTimeMs);\n      (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n     * wait for those to resolve. */\n  }\n  /**\n   * Clears whichever keepalive timeout is currently active, if any.\n   */\n  clearKeepaliveTimeout() {\n    if (this.keepaliveTimer) {\n      clearTimeout(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n  }\n  removeActiveCall(call) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n    }\n  }\n  addActiveCall(call) {\n    this.activeCalls.add(call);\n    if (this.activeCalls.size === 1) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.maybeStartKeepalivePingTimer();\n      }\n    }\n  }\n  createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    this.internalsTrace('session.closed=' + this.session.closed + ' session.destroyed=' + this.session.destroyed + ' session.socket.destroyed=' + this.session.socket.destroyed);\n    let eventTracker;\n    // eslint-disable-next-line prefer-const\n    let call;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    }\n    call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n    this.addActiveCall(call);\n    return call;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n  getOptions() {\n    return this.options;\n  }\n  shutdown() {\n    this.session.close();\n    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n  }\n}\nclass Http2SubchannelConnector {\n  constructor(channelTarget) {\n    this.channelTarget = channelTarget;\n    this.session = null;\n    this.isShutdown = false;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);\n  }\n  createSession(address, credentials, options, proxyConnectionResult) {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    return new Promise((resolve, reject) => {\n      var _a, _b, _c, _d;\n      let remoteName;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n        this.trace('creating HTTP/2 session through proxy to ' + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\n      } else {\n        remoteName = null;\n        this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n      }\n      const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n      let connectionOptions = credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory = options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n          const originalCheckServerIdentity = (_b = connectionOptions.checkServerIdentity) !== null && _b !== void 0 ? _b : tls_1.checkServerIdentity;\n          connectionOptions.checkServerIdentity = (host, cert) => {\n            return originalCheckServerIdentity(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname = (_d = (_c = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _c === void 0 ? void 0 : _c.host) !== null && _d !== void 0 ? _d : 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n      connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), {\n        enableTrace: options['grpc-node.tls_enable_trace'] === 1\n      });\n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n      this.session = session;\n      let errorMessage = 'Failed to connect';\n      let reportedError = false;\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options, remoteName));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        // Leave time for error event to happen before rejecting\n        setImmediate(() => {\n          if (!reportedError) {\n            reportedError = true;\n            reject(`${errorMessage} (${new Date().toISOString()})`);\n          }\n        });\n      });\n      session.once('error', error => {\n        errorMessage = error.message;\n        this.trace('connection failed with error ' + errorMessage);\n        if (!reportedError) {\n          reportedError = true;\n          reject(`${errorMessage} (${new Date().toISOString()})`);\n        }\n      });\n    });\n  }\n  connect(address, credentials, options) {\n    var _a, _b, _c;\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions = credentials._getConnectionOptions() || {};\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n        const originalCheckServerIdentity = (_a = connectionOptions.checkServerIdentity) !== null && _a !== void 0 ? _a : tls_1.checkServerIdentity;\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return originalCheckServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = (0, resolver_1.getDefaultAuthority)((_b = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _b !== void 0 ? _b : {\n            path: 'localhost'\n          });\n          const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n          connectionOptions.servername = (_c = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _c !== void 0 ? _c : targetPath;\n        }\n      }\n      if (options['grpc-node.tls_enable_trace']) {\n        connectionOptions.enableTrace = true;\n      }\n    }\n    return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));\n  }\n  shutdown() {\n    var _a;\n    this.isShutdown = true;\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n    this.session = null;\n  }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector;","map":{"version":3,"names":["http2","require","tls_1","channelz_1","constants_1","http_proxy_1","logging","resolver_1","subchannel_address_1","uri_parser_1","net","subchannel_call_1","call_number_1","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","clientVersion","version","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","constants","KEEPALIVE_TIMEOUT_MS","tooManyPingsData","Buffer","from","Http2Transport","constructor","session","subchannelAddress","options","remoteName","keepaliveTimer","pendingSendKeepalivePing","activeCalls","Set","disconnectListeners","disconnectHandled","channelzEnabled","keepalivesSent","messagesSent","messagesReceived","lastMessageSentTimestamp","lastMessageReceivedTimestamp","subchannelAddressString","subchannelAddressToString","streamTracker","ChannelzCallTrackerStub","ChannelzCallTracker","channelzRef","registerChannelzSocket","getChannelzInfo","userAgent","filter","e","join","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveWithoutCalls","once","trace","handleDisconnect","errorCode","lastStreamID","opaqueData","tooManyPings","NGHTTP2_ENHANCE_YOUR_CALM","equals","toString","reportDisconnectToOwner","error","message","isTracerEnabled","on","settings","JSON","stringify","maybeStartKeepalivePingTimer","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","_a","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","streamsStarted","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","localFlowControlWindow","_b","state","localWindowSize","remoteFlowControlWindow","_c","remoteWindowSize","text","LogVerbosity","DEBUG","id","keepaliveTrace","flowControlTrace","internalsTrace","forEach","listener","clearKeepaliveTimeout","setImmediate","call","onDisconnect","destroy","addDisconnectListener","push","canSendPing","destroyed","size","maybeSendPing","console","setTimeout","unref","pingSendError","pingSentSuccessfully","ping","err","duration","payload","Error","clearTimeout","removeActiveCall","delete","addActiveCall","add","ref","createCall","metadata","host","method","subchannelCallStatsTracker","headers","toHttp2Headers","http2Stream","request","closed","eventTracker","addCallStarted","addMessageSent","Date","addMessageReceived","onCallEnd","status","onStreamEnd","success","addCallSucceeded","addCallFailed","Http2SubchannelCall","getNextCallNumber","getChannelzRef","getPeerName","getOptions","shutdown","close","unregisterChannelzRef","Http2SubchannelConnector","channelTarget","isShutdown","uriToString","createSession","address","credentials","proxyConnectionResult","Promise","reject","resolve","realTarget","targetAuthority","getDefaultAuthority","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","originalCheckServerIdentity","checkServerIdentity","cert","servername","authorityHostname","_d","splitHostPort","createConnection","authority","option","connect","Object","assign","enableTrace","errorMessage","reportedError","removeAllListeners","toISOString","ALPNProtocols","targetPath","parseUri","path","hostPort","getProxiedConnection","then","result","exports"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/transport.ts"],"sourcesContent":["/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport {\n  checkServerIdentity,\n  CipherNameAndProtocol,\n  ConnectionOptions,\n  PeerCertificate,\n  TLSSocket,\n} from 'tls';\nimport { PartialStatusObject } from './call-interface';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  ChannelzCallTracker,\n  ChannelzCallTrackerStub,\n  registerChannelzSocket,\n  SocketInfo,\n  SocketRef,\n  TlsInfo,\n  unregisterChannelzRef,\n} from './channelz';\nimport { LogVerbosity } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as logging from './logging';\nimport { getDefaultAuthority } from './resolver';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport * as net from 'net';\nimport {\n  Http2SubchannelCall,\n  SubchannelCall,\n  SubchannelCallInterceptingListener,\n} from './subchannel-call';\nimport { Metadata } from './metadata';\nimport { getNextCallNumber } from './call-number';\n\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\n\nconst clientVersion = require('../../package.json').version;\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface CallEventTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n  onCallEnd(status: PartialStatusObject): void;\n  onStreamEnd(success: boolean): void;\n}\n\nexport interface TransportDisconnectListener {\n  (tooManyPings: boolean): void;\n}\n\nexport interface Transport {\n  getChannelzRef(): SocketRef;\n  getPeerName(): string;\n  getOptions(): ChannelOptions;\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener,\n    subchannelCallStatsTracker: Partial<CallEventTracker>\n  ): SubchannelCall;\n  addDisconnectListener(listener: TransportDisconnectListener): void;\n  shutdown(): void;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nclass Http2Transport implements Transport {\n  /**\n   * The amount of time in between sending pings\n   */\n  private readonly keepaliveTimeMs: number;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private readonly keepaliveTimeoutMs: number;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private readonly keepaliveWithoutCalls: boolean;\n  /**\n   * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.\n   */\n  private keepaliveTimer: NodeJS.Timeout | null = null;\n  /**\n   * Indicates that the keepalive timer ran out while there were no active\n   * calls, and a ping should be sent the next time a call starts.\n   */\n  private pendingSendKeepalivePing = false;\n\n  private userAgent: string;\n\n  private activeCalls: Set<Http2SubchannelCall> = new Set();\n\n  private subchannelAddressString: string;\n\n  private disconnectListeners: TransportDisconnectListener[] = [];\n\n  private disconnectHandled = false;\n\n  // Channelz info\n  private channelzRef: SocketRef;\n  private readonly channelzEnabled: boolean = true;\n  private streamTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  constructor(\n    private session: http2.ClientHttp2Session,\n    subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    private remoteName: string | null\n  ) {\n    /* Populate subchannelAddressString and channelzRef before doing anything\n     * else, because they are used in the trace methods. */\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.streamTracker = new ChannelzCallTrackerStub();\n    } else {\n      this.streamTracker = new ChannelzCallTracker();\n    }\n\n    this.channelzRef = registerChannelzSocket(\n      this.subchannelAddressString,\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter(e => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    } else {\n      this.keepaliveTimeMs = -1;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    } else {\n      this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n\n    session.once('close', () => {\n      this.trace('session closed');\n      this.handleDisconnect();\n    });\n\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => {\n        let tooManyPings = false;\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (\n          errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n          opaqueData &&\n          opaqueData.equals(tooManyPingsData)\n        ) {\n          tooManyPings = true;\n        }\n        this.trace(\n          'connection closed by GOAWAY with code ' +\n            errorCode +\n            ' and data ' +\n            opaqueData?.toString()\n        );\n        this.reportDisconnectToOwner(tooManyPings);\n      }\n    );\n\n    session.once('error', error => {\n      this.trace('connection closed with error ' + (error as Error).message);\n      this.handleDisconnect();\n    });\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n\n    /* Start the keepalive timer last, because this can trigger trace logs,\n     * which should only happen after everything else is set up. */\n    if (this.keepaliveWithoutCalls) {\n      this.maybeStartKeepalivePingTimer();\n    }\n  }\n\n  private getChannelzInfo(): SocketInfo {\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.remoteAddress,\n          sessionSocket.remotePort\n        )\n      : null;\n    const localAddress = sessionSocket.localAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.localAddress,\n          sessionSocket.localPort\n        )\n      : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & { standardName?: string } =\n        tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate:\n          certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate:\n          peerCertificate && 'raw' in peerCertificate\n            ? peerCertificate.raw\n            : null,\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp:\n        this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null,\n    };\n    return socketInfo;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'keepalive',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      FLOW_CONTROL_TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'transport_internals',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  private reportDisconnectToOwner(tooManyPings: boolean) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  private handleDisconnect() {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.clearKeepaliveTimeout();\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n      this.session.destroy();\n    });\n  }\n\n  addDisconnectListener(listener: TransportDisconnectListener): void {\n    this.disconnectListeners.push(listener);\n  }\n\n  private canSendPing() {\n    return (\n      !this.session.destroyed &&\n      this.keepaliveTimeMs > 0 &&\n      (this.keepaliveWithoutCalls || this.activeCalls.size > 0)\n    );\n  }\n\n  private maybeSendPing() {\n    if (!this.canSendPing()) {\n      this.pendingSendKeepalivePing = true;\n      return;\n    }\n    if (this.keepaliveTimer) {\n      console.error('keepaliveTimeout is not null');\n      return;\n    }\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace(\n      'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'\n    );\n    this.keepaliveTimer = setTimeout(() => {\n      this.keepaliveTimer = null;\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    this.keepaliveTimer.unref?.();\n    let pingSendError = '';\n    try {\n      const pingSentSuccessfully = this.session.ping(\n        (err: Error | null, duration: number, payload: Buffer) => {\n          this.clearKeepaliveTimeout();\n          if (err) {\n            this.keepaliveTrace('Ping failed with error ' + err.message);\n            this.handleDisconnect();\n          } else {\n            this.keepaliveTrace('Received ping response');\n            this.maybeStartKeepalivePingTimer();\n          }\n        }\n      );\n      if (!pingSentSuccessfully) {\n        pingSendError = 'Ping returned false';\n      }\n    } catch (e) {\n      // grpc/grpc-node#2139\n      pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n    }\n    if (pingSendError) {\n      this.keepaliveTrace('Ping send failed: ' + pingSendError);\n      this.handleDisconnect();\n    }\n  }\n\n  /**\n   * Starts the keepalive ping timer if appropriate. If the timer already ran\n   * out while there were no active requests, instead send a ping immediately.\n   * If the ping timer is already running or a ping is currently in flight,\n   * instead do nothing and wait for them to resolve.\n   */\n  private maybeStartKeepalivePingTimer() {\n    if (!this.canSendPing()) {\n      return;\n    }\n    if (this.pendingSendKeepalivePing) {\n      this.pendingSendKeepalivePing = false;\n      this.maybeSendPing();\n    } else if (!this.keepaliveTimer) {\n      this.keepaliveTrace(\n        'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'\n      );\n      this.keepaliveTimer = setTimeout(() => {\n        this.keepaliveTimer = null;\n        this.maybeSendPing();\n      }, this.keepaliveTimeMs);\n      this.keepaliveTimer.unref?.();\n    }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n     * wait for those to resolve. */\n  }\n\n  /**\n   * Clears whichever keepalive timeout is currently active, if any.\n   */\n  private clearKeepaliveTimeout() {\n    if (this.keepaliveTimer) {\n      clearTimeout(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n  }\n\n  private removeActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n    }\n  }\n\n  private addActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.add(call);\n    if (this.activeCalls.size === 1) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.maybeStartKeepalivePingTimer();\n      }\n    }\n  }\n\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener,\n    subchannelCallStatsTracker: Partial<CallEventTracker>\n  ): Http2SubchannelCall {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session.state.localWindowSize +\n        ' remote window size: ' +\n        this.session.state.remoteWindowSize\n    );\n    this.internalsTrace(\n      'session.closed=' +\n        this.session.closed +\n        ' session.destroyed=' +\n        this.session.destroyed +\n        ' session.socket.destroyed=' +\n        this.session.socket.destroyed\n    );\n    let eventTracker: CallEventTracker;\n    // eslint-disable-next-line prefer-const\n    let call: Http2SubchannelCall;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        },\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        },\n      };\n    }\n    call = new Http2SubchannelCall(\n      http2Stream,\n      eventTracker,\n      listener,\n      this,\n      getNextCallNumber()\n    );\n    this.addActiveCall(call);\n    return call;\n  }\n\n  getChannelzRef(): SocketRef {\n    return this.channelzRef;\n  }\n\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n\n  shutdown() {\n    this.session.close();\n    unregisterChannelzRef(this.channelzRef);\n  }\n}\n\nexport interface SubchannelConnector {\n  connect(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions\n  ): Promise<Transport>;\n  shutdown(): void;\n}\n\nexport class Http2SubchannelConnector implements SubchannelConnector {\n  private session: http2.ClientHttp2Session | null = null;\n  private isShutdown = false;\n  constructor(private channelTarget: GrpcUri) {}\n\n  private trace(text: string) {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      uriToString(this.channelTarget) + ' ' + text\n    );\n  }\n\n  private createSession(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions,\n    proxyConnectionResult: ProxyConnectionResult\n  ): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n\n    return new Promise<Http2Transport>((resolve, reject) => {\n      let remoteName: string | null;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = uriToString(proxyConnectionResult.realTarget);\n        this.trace(\n          'creating HTTP/2 session through proxy to ' +\n            uriToString(proxyConnectionResult.realTarget)\n        );\n      } else {\n        remoteName = null;\n        this.trace(\n          'creating HTTP/2 session to ' + subchannelAddressToString(address)\n        );\n      }\n      const targetAuthority = getDefaultAuthority(\n        proxyConnectionResult.realTarget ?? this.channelTarget\n      );\n      let connectionOptions: http2.SecureClientSessionOptions =\n        credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory =\n          options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride =\n            options['grpc.ssl_target_name_override']!;\n          const originalCheckServerIdentity =\n            connectionOptions.checkServerIdentity ?? checkServerIdentity;\n          connectionOptions.checkServerIdentity = (\n            host: string,\n            cert: PeerCertificate\n          ): Error | undefined => {\n            return originalCheckServerIdentity(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname =\n            splitHostPort(targetAuthority)?.host ?? 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket!;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n\n      connectionOptions = {\n        ...connectionOptions,\n        ...address,\n        enableTrace: options['grpc-node.tls_enable_trace'] === 1,\n      };\n\n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(\n        addressScheme + targetAuthority,\n        connectionOptions\n      );\n      this.session = session;\n      let errorMessage = 'Failed to connect';\n      let reportedError = false;\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options, remoteName));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        // Leave time for error event to happen before rejecting\n        setImmediate(() => {\n          if (!reportedError) {\n            reportedError = true;\n            reject(`${errorMessage} (${new Date().toISOString()})`);\n          }\n        });\n      });\n      session.once('error', error => {\n        errorMessage = (error as Error).message;\n        this.trace('connection failed with error ' + errorMessage);\n        if (!reportedError) {\n          reportedError = true;\n          reject(`${errorMessage} (${new Date().toISOString()})`);\n        }\n      });\n    });\n  }\n\n  connect(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions\n  ): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override']!;\n        const originalCheckServerIdentity =\n          connectionOptions.checkServerIdentity ?? checkServerIdentity;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return originalCheckServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n      if (options['grpc-node.tls_enable_trace']) {\n        connectionOptions.enableTrace = true;\n      }\n    }\n\n    return getProxiedConnection(address, options, connectionOptions).then(\n      result => this.createSession(address, credentials, options, result)\n    );\n  }\n\n  shutdown(): void {\n    this.isShutdown = true;\n    this.session?.close();\n    this.session = null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}