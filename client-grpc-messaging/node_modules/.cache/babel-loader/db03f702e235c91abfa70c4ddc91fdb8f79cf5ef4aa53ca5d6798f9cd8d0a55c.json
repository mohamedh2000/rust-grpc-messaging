{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.DEFAULT_PORT = void 0;\nconst resolver_1 = require(\"./resolver\");\nconst dns_1 = require(\"dns\");\nconst service_config_1 = require(\"./service-config\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net_1 = require(\"net\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst environment_1 = require(\"./environment\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nexports.DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n  constructor(target, listener, channelOptions) {\n    var _a, _b, _c;\n    this.target = target;\n    this.listener = listener;\n    this.pendingLookupPromise = null;\n    this.pendingTxtPromise = null;\n    this.latestLookupResult = null;\n    this.latestServiceConfig = null;\n    this.latestServiceConfigError = null;\n    this.continueResolving = false;\n    this.isNextResolutionTimerRunning = false;\n    this.isServiceConfigEnabled = true;\n    this.returnedIpResult = false;\n    this.alternativeResolver = new dns_1.promises.Resolver();\n    trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\n    if (target.authority) {\n      this.alternativeResolver.setServers([target.authority]);\n    }\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n    if (hostPort === null) {\n      this.ipResult = null;\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\n        this.ipResult = [{\n          addresses: [{\n            host: hostPort.host,\n            port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT\n          }]\n        }];\n        this.dnsHostname = null;\n        this.port = null;\n      } else {\n        this.ipResult = null;\n        this.dnsHostname = hostPort.host;\n        this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\n      }\n    }\n    this.percentage = Math.random() * 100;\n    if (channelOptions['grpc.service_config_disable_resolution'] === 1) {\n      this.isServiceConfigEnabled = false;\n    }\n    this.defaultResolutionError = {\n      code: constants_1.Status.UNAVAILABLE,\n      details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\n      metadata: new metadata_1.Metadata()\n    };\n    const backoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, backoffOptions);\n    this.backoff.unref();\n    this.minTimeBetweenResolutionsMs = (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n    this.nextResolutionTimer = setTimeout(() => {}, 0);\n    clearTimeout(this.nextResolutionTimer);\n  }\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT lookups\n   */\n  startResolution() {\n    if (this.ipResult !== null) {\n      if (!this.returnedIpResult) {\n        trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));\n        setImmediate(() => {\n          this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n        });\n        this.returnedIpResult = true;\n      }\n      this.backoff.stop();\n      this.backoff.reset();\n      this.stopNextResolutionTimer();\n      return;\n    }\n    if (this.dnsHostname === null) {\n      trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));\n      setImmediate(() => {\n        this.listener.onError({\n          code: constants_1.Status.UNAVAILABLE,\n          details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,\n          metadata: new metadata_1.Metadata()\n        });\n      });\n      this.stopNextResolutionTimer();\n    } else {\n      if (this.pendingLookupPromise !== null) {\n        return;\n      }\n      trace('Looking up DNS hostname ' + this.dnsHostname);\n      /* We clear out latestLookupResult here to ensure that it contains the\n       * latest result since the last time we started resolving. That way, the\n       * TXT resolution handler can use it, but only if it finishes second. We\n       * don't clear out any previous service config results because it's\n       * better to use a service config that's slightly out of date than to\n       * revert to an effectively blank one. */\n      this.latestLookupResult = null;\n      const hostname = this.dnsHostname;\n      this.pendingLookupPromise = this.lookup(hostname);\n      this.pendingLookupPromise.then(addressList => {\n        if (this.pendingLookupPromise === null) {\n          return;\n        }\n        this.pendingLookupPromise = null;\n        this.backoff.reset();\n        this.backoff.stop();\n        this.latestLookupResult = addressList.map(address => ({\n          addresses: [address]\n        }));\n        const allAddressesString = '[' + addressList.map(addr => addr.host + ':' + addr.port).join(',') + ']';\n        trace('Resolved addresses for target ' + (0, uri_parser_1.uriToString)(this.target) + ': ' + allAddressesString);\n        if (this.latestLookupResult.length === 0) {\n          this.listener.onError(this.defaultResolutionError);\n          return;\n        }\n        /* If the TXT lookup has not yet finished, both of the last two\n         * arguments will be null, which is the equivalent of getting an\n         * empty TXT response. When the TXT lookup does finish, its handler\n         * can update the service config by using the same address list */\n        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n      }, err => {\n        if (this.pendingLookupPromise === null) {\n          return;\n        }\n        trace('Resolution error for target ' + (0, uri_parser_1.uriToString)(this.target) + ': ' + err.message);\n        this.pendingLookupPromise = null;\n        this.stopNextResolutionTimer();\n        this.listener.onError(this.defaultResolutionError);\n      });\n      /* If there already is a still-pending TXT resolution, we can just use\n       * that result when it comes in */\n      if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n        /* We handle the TXT query promise differently than the others because\n         * the name resolution attempt as a whole is a success even if the TXT\n         * lookup fails */\n        this.pendingTxtPromise = this.resolveTxt(hostname);\n        this.pendingTxtPromise.then(txtRecord => {\n          if (this.pendingTxtPromise === null) {\n            return;\n          }\n          this.pendingTxtPromise = null;\n          try {\n            this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\n          } catch (err) {\n            this.latestServiceConfigError = {\n              code: constants_1.Status.UNAVAILABLE,\n              details: `Parsing service config failed with error ${err.message}`,\n              metadata: new metadata_1.Metadata()\n            };\n          }\n          if (this.latestLookupResult !== null) {\n            /* We rely here on the assumption that calling this function with\n             * identical parameters will be essentialy idempotent, and calling\n             * it with the same address list and a different service config\n             * should result in a fast and seamless switchover. */\n            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n          }\n        }, err => {\n          /* If TXT lookup fails we should do nothing, which means that we\n           * continue to use the result of the most recent successful lookup,\n           * or the default null config object if there has never been a\n           * successful lookup. We do not set the latestServiceConfigError\n           * here because that is specifically used for response validation\n           * errors. We still need to handle this error so that it does not\n           * bubble up as an unhandled promise rejection. */\n        });\n      }\n    }\n  }\n  async lookup(hostname) {\n    if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\n      trace('Using alternative DNS resolver.');\n      const records = await Promise.allSettled([this.alternativeResolver.resolve4(hostname), this.alternativeResolver.resolve6(hostname)]);\n      if (records.every(result => result.status === 'rejected')) {\n        throw new Error(records[0].reason);\n      }\n      return records.reduce((acc, result) => {\n        return result.status === 'fulfilled' ? [...acc, ...result.value] : acc;\n      }, []).map(addr => ({\n        host: addr,\n        port: +this.port\n      }));\n    }\n    /* We lookup both address families here and then split them up later\n     * because when looking up a single family, dns.lookup outputs an error\n     * if the name exists but there are no records for that family, and that\n     * error is indistinguishable from other kinds of errors */\n    const addressList = await dns_1.promises.lookup(hostname, {\n      all: true\n    });\n    return addressList.map(addr => ({\n      host: addr.address,\n      port: +this.port\n    }));\n  }\n  async resolveTxt(hostname) {\n    if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\n      trace('Using alternative DNS resolver.');\n      return this.alternativeResolver.resolveTxt(hostname);\n    }\n    return dns_1.promises.resolveTxt(hostname);\n  }\n  startNextResolutionTimer() {\n    var _a, _b;\n    clearTimeout(this.nextResolutionTimer);\n    this.nextResolutionTimer = setTimeout(() => {\n      this.stopNextResolutionTimer();\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, this.minTimeBetweenResolutionsMs);\n    (_b = (_a = this.nextResolutionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.isNextResolutionTimerRunning = true;\n  }\n  stopNextResolutionTimer() {\n    clearTimeout(this.nextResolutionTimer);\n    this.isNextResolutionTimerRunning = false;\n  }\n  startResolutionWithBackoff() {\n    if (this.pendingLookupPromise === null) {\n      this.continueResolving = false;\n      this.backoff.runOnce();\n      this.startNextResolutionTimer();\n      this.startResolution();\n    }\n  }\n  updateResolution() {\n    /* If there is a pending lookup, just let it finish. Otherwise, if the\n     * nextResolutionTimer or backoff timer is running, set the\n     * continueResolving flag to resolve when whichever of those timers\n     * fires. Otherwise, start resolving immediately. */\n    if (this.pendingLookupPromise === null) {\n      if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n        if (this.isNextResolutionTimerRunning) {\n          trace('resolution update delayed by \"min time between resolutions\" rate limit');\n        } else {\n          trace('resolution update delayed by backoff timer until ' + this.backoff.getEndTime().toISOString());\n        }\n        this.continueResolving = true;\n      } else {\n        this.startResolutionWithBackoff();\n      }\n    }\n  }\n  /**\n   * Reset the resolver to the same state it had when it was created. In-flight\n   * DNS requests cannot be cancelled, but they are discarded and their results\n   * will be ignored.\n   */\n  destroy() {\n    this.continueResolving = false;\n    this.backoff.reset();\n    this.backoff.stop();\n    this.stopNextResolutionTimer();\n    this.pendingLookupPromise = null;\n    this.pendingTxtPromise = null;\n    this.latestLookupResult = null;\n    this.latestServiceConfig = null;\n    this.latestServiceConfigError = null;\n    this.returnedIpResult = false;\n  }\n  /**\n   * Get the default authority for the given target. For IP targets, that is\n   * the IP address. For DNS targets, it is the hostname.\n   * @param target\n   */\n  static getDefaultAuthority(target) {\n    return target.path;\n  }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n  (0, resolver_1.registerResolver)('dns', DnsResolver);\n  (0, resolver_1.registerDefaultScheme)('dns');\n}\nexports.setup = setup;","map":{"version":3,"names":["resolver_1","require","dns_1","service_config_1","constants_1","metadata_1","logging","constants_2","uri_parser_1","net_1","backoff_timeout_1","environment_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","exports","DEFAULT_PORT","DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS","DnsResolver","constructor","target","listener","channelOptions","pendingLookupPromise","pendingTxtPromise","latestLookupResult","latestServiceConfig","latestServiceConfigError","continueResolving","isNextResolutionTimerRunning","isServiceConfigEnabled","returnedIpResult","alternativeResolver","promises","Resolver","uriToString","authority","setServers","hostPort","splitHostPort","path","ipResult","dnsHostname","port","isIPv4","host","isIPv6","addresses","_a","_b","percentage","Math","random","defaultResolutionError","code","Status","UNAVAILABLE","details","metadata","Metadata","backoffOptions","initialDelay","maxDelay","backoff","BackoffTimeout","startResolutionWithBackoff","unref","minTimeBetweenResolutionsMs","_c","nextResolutionTimer","setTimeout","clearTimeout","startResolution","setImmediate","onSuccessfulResolution","stop","reset","stopNextResolutionTimer","onError","hostname","lookup","then","addressList","map","address","allAddressesString","addr","join","length","err","message","resolveTxt","txtRecord","extractAndSelectServiceConfig","GRPC_NODE_USE_ALTERNATIVE_RESOLVER","records","Promise","allSettled","resolve4","resolve6","every","result","status","Error","reason","reduce","acc","value","all","startNextResolutionTimer","call","runOnce","updateResolution","isRunning","getEndTime","toISOString","destroy","getDefaultAuthority","setup","registerResolver","registerDefaultScheme"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/resolver-dns.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Resolver,\n  ResolverListener,\n  registerResolver,\n  registerDefaultScheme,\n} from './resolver';\nimport { promises as dns } from 'dns';\nimport { extractAndSelectServiceConfig, ServiceConfig } from './service-config';\nimport { Status } from './constants';\nimport { StatusObject } from './call-interface';\nimport { Metadata } from './metadata';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { Endpoint, TcpSubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString, splitHostPort } from './uri-parser';\nimport { isIPv6, isIPv4 } from 'net';\nimport { ChannelOptions } from './channel-options';\nimport { BackoffOptions, BackoffTimeout } from './backoff-timeout';\nimport { GRPC_NODE_USE_ALTERNATIVE_RESOLVER } from './environment';\n\nconst TRACER_NAME = 'dns_resolver';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nexport const DEFAULT_PORT = 443;\n\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30_000;\n\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver implements Resolver {\n  private readonly ipResult: Endpoint[] | null;\n  private readonly dnsHostname: string | null;\n  private readonly port: number | null;\n  /**\n   * Minimum time between resolutions, measured as the time between starting\n   * successive resolution requests. Only applies to successful resolutions.\n   * Failures are handled by the backoff timer.\n   */\n  private readonly minTimeBetweenResolutionsMs: number;\n  private pendingLookupPromise: Promise<TcpSubchannelAddress[]> | null = null;\n  private pendingTxtPromise: Promise<string[][]> | null = null;\n  private latestLookupResult: Endpoint[] | null = null;\n  private latestServiceConfig: ServiceConfig | null = null;\n  private latestServiceConfigError: StatusObject | null = null;\n  private percentage: number;\n  private defaultResolutionError: StatusObject;\n  private backoff: BackoffTimeout;\n  private continueResolving = false;\n  private nextResolutionTimer: NodeJS.Timeout;\n  private isNextResolutionTimerRunning = false;\n  private isServiceConfigEnabled = true;\n  private returnedIpResult = false;\n  private alternativeResolver = new dns.Resolver();\n\n  constructor(\n    private target: GrpcUri,\n    private listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ) {\n    trace('Resolver constructed for target ' + uriToString(target));\n    if (target.authority) {\n      this.alternativeResolver.setServers([target.authority]);\n    }\n    const hostPort = splitHostPort(target.path);\n    if (hostPort === null) {\n      this.ipResult = null;\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      if (isIPv4(hostPort.host) || isIPv6(hostPort.host)) {\n        this.ipResult = [\n          {\n            addresses: [\n              {\n                host: hostPort.host,\n                port: hostPort.port ?? DEFAULT_PORT,\n              },\n            ],\n          },\n        ];\n        this.dnsHostname = null;\n        this.port = null;\n      } else {\n        this.ipResult = null;\n        this.dnsHostname = hostPort.host;\n        this.port = hostPort.port ?? DEFAULT_PORT;\n      }\n    }\n    this.percentage = Math.random() * 100;\n\n    if (channelOptions['grpc.service_config_disable_resolution'] === 1) {\n      this.isServiceConfigEnabled = false;\n    }\n\n    this.defaultResolutionError = {\n      code: Status.UNAVAILABLE,\n      details: `Name resolution failed for target ${uriToString(this.target)}`,\n      metadata: new Metadata(),\n    };\n\n    const backoffOptions: BackoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n    };\n\n    this.backoff = new BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, backoffOptions);\n    this.backoff.unref();\n\n    this.minTimeBetweenResolutionsMs =\n      channelOptions['grpc.dns_min_time_between_resolutions_ms'] ??\n      DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n    this.nextResolutionTimer = setTimeout(() => {}, 0);\n    clearTimeout(this.nextResolutionTimer);\n  }\n\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT lookups\n   */\n  private startResolution() {\n    if (this.ipResult !== null) {\n      if (!this.returnedIpResult) {\n        trace('Returning IP address for target ' + uriToString(this.target));\n        setImmediate(() => {\n          this.listener.onSuccessfulResolution(\n            this.ipResult!,\n            null,\n            null,\n            null,\n            {}\n          );\n        });\n        this.returnedIpResult = true;\n      }\n      this.backoff.stop();\n      this.backoff.reset();\n      this.stopNextResolutionTimer();\n      return;\n    }\n    if (this.dnsHostname === null) {\n      trace('Failed to parse DNS address ' + uriToString(this.target));\n      setImmediate(() => {\n        this.listener.onError({\n          code: Status.UNAVAILABLE,\n          details: `Failed to parse DNS address ${uriToString(this.target)}`,\n          metadata: new Metadata(),\n        });\n      });\n      this.stopNextResolutionTimer();\n    } else {\n      if (this.pendingLookupPromise !== null) {\n        return;\n      }\n      trace('Looking up DNS hostname ' + this.dnsHostname);\n      /* We clear out latestLookupResult here to ensure that it contains the\n       * latest result since the last time we started resolving. That way, the\n       * TXT resolution handler can use it, but only if it finishes second. We\n       * don't clear out any previous service config results because it's\n       * better to use a service config that's slightly out of date than to\n       * revert to an effectively blank one. */\n      this.latestLookupResult = null;\n      const hostname: string = this.dnsHostname;\n      this.pendingLookupPromise = this.lookup(hostname);\n      this.pendingLookupPromise.then(\n        addressList => {\n          if (this.pendingLookupPromise === null) {\n            return;\n          }\n          this.pendingLookupPromise = null;\n          this.backoff.reset();\n          this.backoff.stop();\n          this.latestLookupResult = addressList.map(address => ({\n            addresses: [address],\n          }));\n          const allAddressesString: string =\n            '[' +\n            addressList.map(addr => addr.host + ':' + addr.port).join(',') +\n            ']';\n          trace(\n            'Resolved addresses for target ' +\n              uriToString(this.target) +\n              ': ' +\n              allAddressesString\n          );\n          if (this.latestLookupResult.length === 0) {\n            this.listener.onError(this.defaultResolutionError);\n            return;\n          }\n          /* If the TXT lookup has not yet finished, both of the last two\n           * arguments will be null, which is the equivalent of getting an\n           * empty TXT response. When the TXT lookup does finish, its handler\n           * can update the service config by using the same address list */\n          this.listener.onSuccessfulResolution(\n            this.latestLookupResult,\n            this.latestServiceConfig,\n            this.latestServiceConfigError,\n            null,\n            {}\n          );\n        },\n        err => {\n          if (this.pendingLookupPromise === null) {\n            return;\n          }\n          trace(\n            'Resolution error for target ' +\n              uriToString(this.target) +\n              ': ' +\n              (err as Error).message\n          );\n          this.pendingLookupPromise = null;\n          this.stopNextResolutionTimer();\n          this.listener.onError(this.defaultResolutionError);\n        }\n      );\n      /* If there already is a still-pending TXT resolution, we can just use\n       * that result when it comes in */\n      if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n        /* We handle the TXT query promise differently than the others because\n         * the name resolution attempt as a whole is a success even if the TXT\n         * lookup fails */\n        this.pendingTxtPromise = this.resolveTxt(hostname);\n        this.pendingTxtPromise.then(\n          txtRecord => {\n            if (this.pendingTxtPromise === null) {\n              return;\n            }\n            this.pendingTxtPromise = null;\n            try {\n              this.latestServiceConfig = extractAndSelectServiceConfig(\n                txtRecord,\n                this.percentage\n              );\n            } catch (err) {\n              this.latestServiceConfigError = {\n                code: Status.UNAVAILABLE,\n                details: `Parsing service config failed with error ${\n                  (err as Error).message\n                }`,\n                metadata: new Metadata(),\n              };\n            }\n            if (this.latestLookupResult !== null) {\n              /* We rely here on the assumption that calling this function with\n               * identical parameters will be essentialy idempotent, and calling\n               * it with the same address list and a different service config\n               * should result in a fast and seamless switchover. */\n              this.listener.onSuccessfulResolution(\n                this.latestLookupResult,\n                this.latestServiceConfig,\n                this.latestServiceConfigError,\n                null,\n                {}\n              );\n            }\n          },\n          err => {\n            /* If TXT lookup fails we should do nothing, which means that we\n             * continue to use the result of the most recent successful lookup,\n             * or the default null config object if there has never been a\n             * successful lookup. We do not set the latestServiceConfigError\n             * here because that is specifically used for response validation\n             * errors. We still need to handle this error so that it does not\n             * bubble up as an unhandled promise rejection. */\n          }\n        );\n      }\n    }\n  }\n\n  private async lookup(hostname: string): Promise<TcpSubchannelAddress[]> {\n    if (GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\n      trace('Using alternative DNS resolver.');\n\n      const records = await Promise.allSettled([\n        this.alternativeResolver.resolve4(hostname),\n        this.alternativeResolver.resolve6(hostname),\n      ]);\n\n      if (records.every(result => result.status === 'rejected')) {\n        throw new Error((records[0] as PromiseRejectedResult).reason);\n      }\n\n      return records\n        .reduce<string[]>((acc, result) => {\n          return result.status === 'fulfilled'\n            ? [...acc, ...result.value]\n            : acc;\n        }, [])\n        .map(addr => ({\n          host: addr,\n          port: +this.port!,\n        }));\n    }\n\n    /* We lookup both address families here and then split them up later\n     * because when looking up a single family, dns.lookup outputs an error\n     * if the name exists but there are no records for that family, and that\n     * error is indistinguishable from other kinds of errors */\n    const addressList = await dns.lookup(hostname, { all: true });\n    return addressList.map(addr => ({ host: addr.address, port: +this.port! }));\n  }\n\n  private async resolveTxt(hostname: string): Promise<string[][]> {\n    if (GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\n      trace('Using alternative DNS resolver.');\n      return this.alternativeResolver.resolveTxt(hostname);\n    }\n\n    return dns.resolveTxt(hostname);\n  }\n\n  private startNextResolutionTimer() {\n    clearTimeout(this.nextResolutionTimer);\n    this.nextResolutionTimer = setTimeout(() => {\n      this.stopNextResolutionTimer();\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, this.minTimeBetweenResolutionsMs);\n    this.nextResolutionTimer.unref?.();\n    this.isNextResolutionTimerRunning = true;\n  }\n\n  private stopNextResolutionTimer() {\n    clearTimeout(this.nextResolutionTimer);\n    this.isNextResolutionTimerRunning = false;\n  }\n\n  private startResolutionWithBackoff() {\n    if (this.pendingLookupPromise === null) {\n      this.continueResolving = false;\n      this.backoff.runOnce();\n      this.startNextResolutionTimer();\n      this.startResolution();\n    }\n  }\n\n  updateResolution() {\n    /* If there is a pending lookup, just let it finish. Otherwise, if the\n     * nextResolutionTimer or backoff timer is running, set the\n     * continueResolving flag to resolve when whichever of those timers\n     * fires. Otherwise, start resolving immediately. */\n    if (this.pendingLookupPromise === null) {\n      if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n        if (this.isNextResolutionTimerRunning) {\n          trace(\n            'resolution update delayed by \"min time between resolutions\" rate limit'\n          );\n        } else {\n          trace(\n            'resolution update delayed by backoff timer until ' +\n              this.backoff.getEndTime().toISOString()\n          );\n        }\n        this.continueResolving = true;\n      } else {\n        this.startResolutionWithBackoff();\n      }\n    }\n  }\n\n  /**\n   * Reset the resolver to the same state it had when it was created. In-flight\n   * DNS requests cannot be cancelled, but they are discarded and their results\n   * will be ignored.\n   */\n  destroy() {\n    this.continueResolving = false;\n    this.backoff.reset();\n    this.backoff.stop();\n    this.stopNextResolutionTimer();\n    this.pendingLookupPromise = null;\n    this.pendingTxtPromise = null;\n    this.latestLookupResult = null;\n    this.latestServiceConfig = null;\n    this.latestServiceConfigError = null;\n    this.returnedIpResult = false;\n  }\n\n  /**\n   * Get the default authority for the given target. For IP targets, that is\n   * the IP address. For DNS targets, it is the hostname.\n   * @param target\n   */\n  static getDefaultAuthority(target: GrpcUri): string {\n    return target.path;\n  }\n}\n\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nexport function setup(): void {\n  registerResolver('dns', DnsResolver);\n  registerDefaultScheme('dns');\n}\n\nexport interface DnsUrl {\n  host: string;\n  port?: string;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}