{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function (ReadState) {\n  ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n  ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n  ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n  constructor(maxReadMessageLength) {\n    this.maxReadMessageLength = maxReadMessageLength;\n    this.readState = ReadState.NO_DATA;\n    this.readCompressFlag = Buffer.alloc(1);\n    this.readPartialSize = Buffer.alloc(4);\n    this.readSizeRemaining = 4;\n    this.readMessageSize = 0;\n    this.readPartialMessage = [];\n    this.readMessageRemaining = 0;\n  }\n  write(data) {\n    let readHead = 0;\n    let toRead;\n    const result = [];\n    while (readHead < data.length) {\n      switch (this.readState) {\n        case ReadState.NO_DATA:\n          this.readCompressFlag = data.slice(readHead, readHead + 1);\n          readHead += 1;\n          this.readState = ReadState.READING_SIZE;\n          this.readPartialSize.fill(0);\n          this.readSizeRemaining = 4;\n          this.readMessageSize = 0;\n          this.readMessageRemaining = 0;\n          this.readPartialMessage = [];\n          break;\n        case ReadState.READING_SIZE:\n          toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n          data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n          this.readSizeRemaining -= toRead;\n          readHead += toRead;\n          // readSizeRemaining >=0 here\n          if (this.readSizeRemaining === 0) {\n            this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n            if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\n              throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\n            }\n            this.readMessageRemaining = this.readMessageSize;\n            if (this.readMessageRemaining > 0) {\n              this.readState = ReadState.READING_MESSAGE;\n            } else {\n              const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n              this.readState = ReadState.NO_DATA;\n              result.push(message);\n            }\n          }\n          break;\n        case ReadState.READING_MESSAGE:\n          toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n          this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n          this.readMessageRemaining -= toRead;\n          readHead += toRead;\n          // readMessageRemaining >=0 here\n          if (this.readMessageRemaining === 0) {\n            // At this point, we have read a full message\n            const framedMessageBuffers = [this.readCompressFlag, this.readPartialSize].concat(this.readPartialMessage);\n            const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n            this.readState = ReadState.NO_DATA;\n            result.push(framedMessage);\n          }\n          break;\n        default:\n          throw new Error('Unexpected read state');\n      }\n    }\n    return result;\n  }\n}\nexports.StreamDecoder = StreamDecoder;","map":{"version":3,"names":["ReadState","StreamDecoder","constructor","maxReadMessageLength","readState","NO_DATA","readCompressFlag","Buffer","alloc","readPartialSize","readSizeRemaining","readMessageSize","readPartialMessage","readMessageRemaining","write","data","readHead","toRead","result","length","slice","READING_SIZE","fill","Math","min","copy","readUInt32BE","Error","READING_MESSAGE","message","concat","push","framedMessageBuffers","framedMessage","exports"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/stream-decoder.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nenum ReadState {\n  NO_DATA,\n  READING_SIZE,\n  READING_MESSAGE,\n}\n\nexport class StreamDecoder {\n  private readState: ReadState = ReadState.NO_DATA;\n  private readCompressFlag: Buffer = Buffer.alloc(1);\n  private readPartialSize: Buffer = Buffer.alloc(4);\n  private readSizeRemaining = 4;\n  private readMessageSize = 0;\n  private readPartialMessage: Buffer[] = [];\n  private readMessageRemaining = 0;\n\n  constructor(private maxReadMessageLength: number) {}\n\n  write(data: Buffer): Buffer[] {\n    let readHead = 0;\n    let toRead: number;\n    const result: Buffer[] = [];\n\n    while (readHead < data.length) {\n      switch (this.readState) {\n        case ReadState.NO_DATA:\n          this.readCompressFlag = data.slice(readHead, readHead + 1);\n          readHead += 1;\n          this.readState = ReadState.READING_SIZE;\n          this.readPartialSize.fill(0);\n          this.readSizeRemaining = 4;\n          this.readMessageSize = 0;\n          this.readMessageRemaining = 0;\n          this.readPartialMessage = [];\n          break;\n        case ReadState.READING_SIZE:\n          toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n          data.copy(\n            this.readPartialSize,\n            4 - this.readSizeRemaining,\n            readHead,\n            readHead + toRead\n          );\n          this.readSizeRemaining -= toRead;\n          readHead += toRead;\n          // readSizeRemaining >=0 here\n          if (this.readSizeRemaining === 0) {\n            this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n            if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\n              throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\n            }\n            this.readMessageRemaining = this.readMessageSize;\n            if (this.readMessageRemaining > 0) {\n              this.readState = ReadState.READING_MESSAGE;\n            } else {\n              const message = Buffer.concat(\n                [this.readCompressFlag, this.readPartialSize],\n                5\n              );\n\n              this.readState = ReadState.NO_DATA;\n              result.push(message);\n            }\n          }\n          break;\n        case ReadState.READING_MESSAGE:\n          toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n          this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n          this.readMessageRemaining -= toRead;\n          readHead += toRead;\n          // readMessageRemaining >=0 here\n          if (this.readMessageRemaining === 0) {\n            // At this point, we have read a full message\n            const framedMessageBuffers = [\n              this.readCompressFlag,\n              this.readPartialSize,\n            ].concat(this.readPartialMessage);\n            const framedMessage = Buffer.concat(\n              framedMessageBuffers,\n              this.readMessageSize + 5\n            );\n\n            this.readState = ReadState.NO_DATA;\n            result.push(framedMessage);\n          }\n          break;\n        default:\n          throw new Error('Unexpected read state');\n      }\n    }\n\n    return result;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}