{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_2 = require(\"./subchannel-address\");\nconst net_1 = require(\"net\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n  constructor(shuffleAddressList) {\n    this.shuffleAddressList = shuffleAddressList;\n  }\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {\n        shuffleAddressList: this.shuffleAddressList\n      }\n    };\n  }\n  getShuffleAddressList() {\n    return this.shuffleAddressList;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    if ('shuffleAddressList' in obj && !(typeof obj.shuffleAddressList === 'boolean')) {\n      throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\n    }\n    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n  }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n  constructor(subchannel) {\n    this.subchannel = subchannel;\n  }\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nfunction shuffled(list) {\n  const result = list.slice();\n  for (let i = result.length - 1; i > 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result;\n}\nexports.shuffled = shuffled;\n/**\n * Interleave addresses in addressList by family in accordance with RFC-8304 section 4\n * @param addressList\n * @returns\n */\nfunction interleaveAddressFamilies(addressList) {\n  const result = [];\n  const ipv6Addresses = [];\n  const ipv4Addresses = [];\n  const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);\n  for (const address of addressList) {\n    if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {\n      ipv6Addresses.push(address);\n    } else {\n      ipv4Addresses.push(address);\n    }\n  }\n  const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;\n  const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;\n  for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {\n    if (i < firstList.length) {\n      result.push(firstList[i]);\n    }\n    if (i < secondList.length) {\n      result.push(secondList[i]);\n    }\n  }\n  return result;\n}\nconst REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';\nclass PickFirstLoadBalancer {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(channelControlHelper, options) {\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n    this.children = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n    this.currentPick = null;\n    /**\n     * Listener callback attached to each subchannel in the `subchannels` list\n     * while establishing a connection.\n     */\n    this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\n      this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n    };\n    this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();\n    /**\n     * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n     * subchannels have failed to connect at least once, and it stays in that\n     * mode until a connection attempt is successful. While in sticky TF mode,\n     * the LB policy continuously attempts to connect to all of its subchannels.\n     */\n    this.stickyTransientFailureMode = false;\n    /**\n     * The most recent error reported by any subchannel as it transitioned to\n     * TRANSIENT_FAILURE.\n     */\n    this.lastError = null;\n    this.latestAddressList = null;\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n    this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];\n  }\n  allChildrenHaveReportedTF() {\n    return this.children.every(child => child.hasReportedTransientFailure);\n  }\n  resetChildrenReportedTF() {\n    this.children.every(child => child.hasReportedTransientFailure = false);\n  }\n  calculateAndReportNewState() {\n    if (this.currentPick) {\n      if (this.reportHealthStatus && !this.currentPick.isHealthy()) {\n        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n          details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`\n        }));\n      } else {\n        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));\n      }\n    } else if (this.children.length === 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    } else {\n      if (this.stickyTransientFailureMode) {\n        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n          details: `No connection established. Last error: ${this.lastError}`\n        }));\n      } else {\n        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n      }\n    }\n  }\n  requestReresolution() {\n    this.channelControlHelper.requestReresolution();\n  }\n  maybeEnterStickyTransientFailureMode() {\n    if (!this.allChildrenHaveReportedTF()) {\n      return;\n    }\n    this.requestReresolution();\n    this.resetChildrenReportedTF();\n    if (this.stickyTransientFailureMode) {\n      return;\n    }\n    this.stickyTransientFailureMode = true;\n    for (const {\n      subchannel\n    } of this.children) {\n      subchannel.startConnecting();\n    }\n    this.calculateAndReportNewState();\n  }\n  removeCurrentPick() {\n    if (this.currentPick !== null) {\n      this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n      this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);\n      // Unref last, to avoid triggering listeners\n      this.currentPick.unref();\n      this.currentPick = null;\n    }\n  }\n  onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n    var _a;\n    if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n      if (newState !== connectivity_state_1.ConnectivityState.READY) {\n        this.removeCurrentPick();\n        this.calculateAndReportNewState();\n      }\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (subchannel.realSubchannelEquals(child.subchannel)) {\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n          this.pickSubchannel(child.subchannel);\n        }\n        if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n          child.hasReportedTransientFailure = true;\n          if (errorMessage) {\n            this.lastError = errorMessage;\n          }\n          this.maybeEnterStickyTransientFailureMode();\n          if (index === this.currentSubchannelIndex) {\n            this.startNextSubchannelConnecting(index + 1);\n          }\n        }\n        child.subchannel.startConnecting();\n        return;\n      }\n    }\n  }\n  startNextSubchannelConnecting(startIndex) {\n    clearTimeout(this.connectionDelayTimeout);\n    for (const [index, child] of this.children.entries()) {\n      if (index >= startIndex) {\n        const subchannelState = child.subchannel.getConnectivityState();\n        if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.maybeEnterStickyTransientFailureMode();\n  }\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  startConnecting(subchannelIndex) {\n    var _a, _b;\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n      trace('Start connecting to subchannel with address ' + this.children[subchannelIndex].subchannel.getAddress());\n      process.nextTick(() => {\n        var _a;\n        (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting(subchannelIndex + 1);\n    }, CONNECTION_DELAY_INTERVAL_MS);\n    (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Declare that the specified subchannel should be used to make requests.\n   * This functions the same independent of whether subchannel is a member of\n   * this.children and whether it is equal to this.currentPick.\n   * Prerequisite: subchannel.getConnectivityState() === READY.\n   * @param subchannel\n   */\n  pickSubchannel(subchannel) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    this.stickyTransientFailureMode = false;\n    /* Ref before removeCurrentPick and resetSubchannelList to avoid the\n     * refcount dropping to 0 during this process. */\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.removeCurrentPick();\n    this.resetSubchannelList();\n    subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);\n    this.currentPick = subchannel;\n    clearTimeout(this.connectionDelayTimeout);\n    this.calculateAndReportNewState();\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList() {\n    for (const child of this.children) {\n      /* Always remoev the connectivity state listener. If the subchannel is\n         getting picked, it will be re-added then. */\n      child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      /* Refs are counted independently for the children list and the\n       * currentPick, so we call unref whether or not the child is the\n       * currentPick. Channelz child references are also refcounted, so\n       * removeChannelzChild can be handled the same way. */\n      child.subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n    }\n    this.currentSubchannelIndex = 0;\n    this.children = [];\n  }\n  connectToAddressList(addressList) {\n    trace('connectToAddressList([' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\n    const newChildrenList = addressList.map(address => ({\n      subchannel: this.channelControlHelper.createSubchannel(address, {}),\n      hasReportedTransientFailure: false\n    }));\n    for (const {\n      subchannel\n    } of newChildrenList) {\n      if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      }\n    }\n    /* Ref each subchannel before resetting the list, to ensure that\n     * subchannels shared between the list don't drop to 0 refs during the\n     * transition. */\n    for (const {\n      subchannel\n    } of newChildrenList) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    this.resetSubchannelList();\n    this.children = newChildrenList;\n    for (const {\n      subchannel\n    } of this.children) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    for (const child of this.children) {\n      if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        child.hasReportedTransientFailure = true;\n      }\n    }\n    this.startNextSubchannelConnecting(0);\n    this.calculateAndReportNewState();\n  }\n  updateAddressList(endpointList, lbConfig) {\n    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n      return;\n    }\n    /* Previously, an update would be discarded if it was identical to the\n     * previous update, to minimize churn. Now the DNS resolver is\n     * rate-limited, so that is less of a concern. */\n    if (lbConfig.getShuffleAddressList()) {\n      endpointList = shuffled(endpointList);\n    }\n    const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));\n    trace('updateAddressList([' + rawAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\n    if (rawAddressList.length === 0) {\n      throw new Error('No addresses in endpoint list passed to pick_first');\n    }\n    const addressList = interleaveAddressFamilies(rawAddressList);\n    this.latestAddressList = addressList;\n    this.connectToAddressList(addressList);\n  }\n  exitIdle() {\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\n      this.connectToAddressList(this.latestAddressList);\n    }\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n    this.removeCurrentPick();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nconst LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);\n/**\n * This class handles the leaf load balancing operations for a single endpoint.\n * It is a thin wrapper around a PickFirstLoadBalancer with a different API\n * that more closely reflects how it will be used as a leaf balancer.\n */\nclass LeafLoadBalancer {\n  constructor(endpoint, channelControlHelper, options) {\n    this.endpoint = endpoint;\n    this.latestState = connectivity_state_1.ConnectivityState.IDLE;\n    const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\n      updateState: (connectivityState, picker) => {\n        this.latestState = connectivityState;\n        this.latestPicker = picker;\n        channelControlHelper.updateState(connectivityState, picker);\n      }\n    });\n    this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper, Object.assign(Object.assign({}, options), {\n      [REPORT_HEALTH_STATUS_OPTION_NAME]: true\n    }));\n    this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);\n  }\n  startConnecting() {\n    this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);\n  }\n  /**\n   * Update the endpoint associated with this LeafLoadBalancer to a new\n   * endpoint. Does not trigger connection establishment if a connection\n   * attempt is not already in progress.\n   * @param newEndpoint\n   */\n  updateEndpoint(newEndpoint) {\n    this.endpoint = newEndpoint;\n    if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {\n      this.startConnecting();\n    }\n  }\n  getConnectivityState() {\n    return this.latestState;\n  }\n  getPicker() {\n    return this.latestPicker;\n  }\n  getEndpoint() {\n    return this.endpoint;\n  }\n  exitIdle() {\n    this.pickFirstBalancer.exitIdle();\n  }\n  destroy() {\n    this.pickFirstBalancer.destroy();\n  }\n}\nexports.LeafLoadBalancer = LeafLoadBalancer;\nfunction setup() {\n  (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n  (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\nexports.setup = setup;","map":{"version":3,"names":["load_balancer_1","require","connectivity_state_1","picker_1","subchannel_address_1","logging","constants_1","subchannel_address_2","net_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","CONNECTION_DELAY_INTERVAL_MS","PickFirstLoadBalancingConfig","constructor","shuffleAddressList","getLoadBalancerName","toJsonObject","getShuffleAddressList","createFromJson","obj","Error","exports","PickFirstPicker","subchannel","pick","pickArgs","pickResultType","PickResultType","COMPLETE","status","onCallStarted","onCallEnded","shuffled","list","result","slice","i","length","j","Math","floor","random","temp","interleaveAddressFamilies","addressList","ipv6Addresses","ipv4Addresses","ipv6First","isTcpSubchannelAddress","isIPv6","host","address","push","firstList","secondList","max","REPORT_HEALTH_STATUS_OPTION_NAME","PickFirstLoadBalancer","channelControlHelper","options","children","currentState","ConnectivityState","IDLE","currentSubchannelIndex","currentPick","subchannelStateListener","previousState","newState","keepaliveTime","errorMessage","onSubchannelStateUpdate","pickedSubchannelHealthListener","calculateAndReportNewState","stickyTransientFailureMode","lastError","latestAddressList","connectionDelayTimeout","setTimeout","clearTimeout","reportHealthStatus","allChildrenHaveReportedTF","every","child","hasReportedTransientFailure","resetChildrenReportedTF","isHealthy","updateState","TRANSIENT_FAILURE","UnavailablePicker","details","getAddress","READY","QueuePicker","CONNECTING","requestReresolution","maybeEnterStickyTransientFailureMode","startConnecting","removeCurrentPick","removeConnectivityStateListener","removeChannelzChild","getChannelzRef","removeHealthStateWatcher","unref","_a","realSubchannelEquals","index","entries","pickSubchannel","startNextSubchannelConnecting","startIndex","subchannelState","getConnectivityState","subchannelIndex","process","nextTick","_b","call","ref","addChannelzChild","resetSubchannelList","addConnectivityStateListener","addHealthStateWatcher","picker","connectToAddressList","map","subchannelAddressToString","newChildrenList","createSubchannel","updateAddressList","endpointList","lbConfig","rawAddressList","concat","endpoint","addresses","exitIdle","resetBackoff","destroy","getTypeName","LEAF_CONFIG","LeafLoadBalancer","latestState","childChannelControlHelper","createChildChannelControlHelper","connectivityState","latestPicker","pickFirstBalancer","Object","assign","updateEndpoint","newEndpoint","getPicker","getEndpoint","setup","registerLoadBalancerType","registerDefaultLoadBalancerType"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/load-balancer-pick-first.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  TypedLoadBalancingConfig,\n  registerDefaultLoadBalancerType,\n  registerLoadBalancerType,\n  createChildChannelControlHelper,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport { Endpoint, SubchannelAddress, subchannelAddressToString } from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport {\n  SubchannelInterface,\n  ConnectivityStateListener,\n  HealthListener,\n} from './subchannel-interface';\nimport { isTcpSubchannelAddress } from './subchannel-address';\nimport { isIPv6 } from 'net';\nimport { ChannelOptions } from './channel-options';\n\nconst TRACER_NAME = 'pick_first';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'pick_first';\n\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n\nexport class PickFirstLoadBalancingConfig implements TypedLoadBalancingConfig {\n  constructor(private readonly shuffleAddressList: boolean) {}\n\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {\n        shuffleAddressList: this.shuffleAddressList,\n      },\n    };\n  }\n\n  getShuffleAddressList() {\n    return this.shuffleAddressList;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    if (\n      'shuffleAddressList' in obj &&\n      !(typeof obj.shuffleAddressList === 'boolean')\n    ) {\n      throw new Error(\n        'pick_first config field shuffleAddressList must be a boolean if provided'\n      );\n    }\n    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n  }\n}\n\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker implements Picker {\n  constructor(private subchannel: SubchannelInterface) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null,\n    };\n  }\n}\n\ninterface SubchannelChild {\n  subchannel: SubchannelInterface;\n  hasReportedTransientFailure: boolean;\n}\n\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nexport function shuffled<T>(list: T[]): T[] {\n  const result = list.slice();\n  for (let i = result.length - 1; i > 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result;\n}\n\n/**\n * Interleave addresses in addressList by family in accordance with RFC-8304 section 4\n * @param addressList\n * @returns\n */\nfunction interleaveAddressFamilies(\n  addressList: SubchannelAddress[]\n): SubchannelAddress[] {\n  const result: SubchannelAddress[] = [];\n  const ipv6Addresses: SubchannelAddress[] = [];\n  const ipv4Addresses: SubchannelAddress[] = [];\n  const ipv6First =\n    isTcpSubchannelAddress(addressList[0]) && isIPv6(addressList[0].host);\n  for (const address of addressList) {\n    if (isTcpSubchannelAddress(address) && isIPv6(address.host)) {\n      ipv6Addresses.push(address);\n    } else {\n      ipv4Addresses.push(address);\n    }\n  }\n  const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;\n  const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;\n  for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {\n    if (i < firstList.length) {\n      result.push(firstList[i]);\n    }\n    if (i < secondList.length) {\n      result.push(secondList[i]);\n    }\n  }\n  return result;\n}\n\nconst REPORT_HEALTH_STATUS_OPTION_NAME =\n  'grpc-node.internal.pick-first.report_health_status';\n\nexport class PickFirstLoadBalancer implements LoadBalancer {\n  /**\n   * The list of subchannels this load balancer is currently attempting to\n   * connect to.\n   */\n  private children: SubchannelChild[] = [];\n  /**\n   * The current connectivity state of the load balancer.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The index within the `subchannels` array of the subchannel with the most\n   * recently started connection attempt.\n   */\n  private currentSubchannelIndex = 0;\n  /**\n   * The currently picked subchannel used for making calls. Populated if\n   * and only if the load balancer's current state is READY. In that case,\n   * the subchannel's current state is also READY.\n   */\n  private currentPick: SubchannelInterface | null = null;\n  /**\n   * Listener callback attached to each subchannel in the `subchannels` list\n   * while establishing a connection.\n   */\n  private subchannelStateListener: ConnectivityStateListener = (\n    subchannel,\n    previousState,\n    newState,\n    keepaliveTime,\n    errorMessage\n  ) => {\n    this.onSubchannelStateUpdate(\n      subchannel,\n      previousState,\n      newState,\n      errorMessage\n    );\n  };\n\n  private pickedSubchannelHealthListener: HealthListener = () =>\n    this.calculateAndReportNewState();\n  /**\n   * Timer reference for the timer tracking when to start\n   */\n  private connectionDelayTimeout: NodeJS.Timeout;\n\n  /**\n   * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n   * subchannels have failed to connect at least once, and it stays in that\n   * mode until a connection attempt is successful. While in sticky TF mode,\n   * the LB policy continuously attempts to connect to all of its subchannels.\n   */\n  private stickyTransientFailureMode = false;\n\n  private reportHealthStatus: boolean;\n\n  /**\n   * The most recent error reported by any subchannel as it transitioned to\n   * TRANSIENT_FAILURE.\n   */\n  private lastError: string | null = null;\n\n  private latestAddressList: SubchannelAddress[] | null = null;\n\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(\n    private readonly channelControlHelper: ChannelControlHelper,\n    options: ChannelOptions\n  ) {\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n    this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];\n  }\n\n  private allChildrenHaveReportedTF(): boolean {\n    return this.children.every(child => child.hasReportedTransientFailure);\n  }\n\n  private resetChildrenReportedTF() {\n    this.children.every(child => child.hasReportedTransientFailure = false);\n  }\n\n  private calculateAndReportNewState() {\n    if (this.currentPick) {\n      if (this.reportHealthStatus && !this.currentPick.isHealthy()) {\n        this.updateState(\n          ConnectivityState.TRANSIENT_FAILURE,\n          new UnavailablePicker({\n            details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`,\n          })\n        );\n      } else {\n        this.updateState(\n          ConnectivityState.READY,\n          new PickFirstPicker(this.currentPick)\n        );\n      }\n    } else if (this.children.length === 0) {\n      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    } else {\n      if (this.stickyTransientFailureMode) {\n        this.updateState(\n          ConnectivityState.TRANSIENT_FAILURE,\n          new UnavailablePicker({\n            details: `No connection established. Last error: ${this.lastError}`,\n          })\n        );\n      } else {\n        this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n      }\n    }\n  }\n\n  private requestReresolution() {\n    this.channelControlHelper.requestReresolution();\n  }\n\n  private maybeEnterStickyTransientFailureMode() {\n    if (!this.allChildrenHaveReportedTF()) {\n      return;\n    }\n    this.requestReresolution();\n    this.resetChildrenReportedTF();\n    if (this.stickyTransientFailureMode) {\n      return;\n    }\n    this.stickyTransientFailureMode = true;\n    for (const { subchannel } of this.children) {\n      subchannel.startConnecting();\n    }\n    this.calculateAndReportNewState();\n  }\n\n  private removeCurrentPick() {\n    if (this.currentPick !== null) {\n      this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(\n        this.currentPick.getChannelzRef()\n      );\n      this.currentPick.removeHealthStateWatcher(\n        this.pickedSubchannelHealthListener\n      );\n      // Unref last, to avoid triggering listeners\n      this.currentPick.unref();\n      this.currentPick = null;\n    }\n  }\n\n  private onSubchannelStateUpdate(\n    subchannel: SubchannelInterface,\n    previousState: ConnectivityState,\n    newState: ConnectivityState,\n    errorMessage?: string\n  ) {\n    if (this.currentPick?.realSubchannelEquals(subchannel)) {\n      if (newState !== ConnectivityState.READY) {\n        this.removeCurrentPick();\n        this.calculateAndReportNewState();\n      }\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (subchannel.realSubchannelEquals(child.subchannel)) {\n        if (newState === ConnectivityState.READY) {\n          this.pickSubchannel(child.subchannel);\n        }\n        if (newState === ConnectivityState.TRANSIENT_FAILURE) {\n          child.hasReportedTransientFailure = true;\n          if (errorMessage) {\n            this.lastError = errorMessage;\n          }\n          this.maybeEnterStickyTransientFailureMode();\n          if (index === this.currentSubchannelIndex) {\n            this.startNextSubchannelConnecting(index + 1);\n          }\n        }\n        child.subchannel.startConnecting();\n        return;\n      }\n    }\n  }\n\n  private startNextSubchannelConnecting(startIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    for (const [index, child] of this.children.entries()) {\n      if (index >= startIndex) {\n        const subchannelState = child.subchannel.getConnectivityState();\n        if (\n          subchannelState === ConnectivityState.IDLE ||\n          subchannelState === ConnectivityState.CONNECTING\n        ) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.maybeEnterStickyTransientFailureMode();\n  }\n\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  private startConnecting(subchannelIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (\n      this.children[subchannelIndex].subchannel.getConnectivityState() ===\n      ConnectivityState.IDLE\n    ) {\n      trace(\n        'Start connecting to subchannel with address ' +\n          this.children[subchannelIndex].subchannel.getAddress()\n      );\n      process.nextTick(() => {\n        this.children[subchannelIndex]?.subchannel.startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting(subchannelIndex + 1);\n    }, CONNECTION_DELAY_INTERVAL_MS);\n    this.connectionDelayTimeout.unref?.();\n  }\n\n  /**\n   * Declare that the specified subchannel should be used to make requests.\n   * This functions the same independent of whether subchannel is a member of\n   * this.children and whether it is equal to this.currentPick.\n   * Prerequisite: subchannel.getConnectivityState() === READY.\n   * @param subchannel\n   */\n  private pickSubchannel(subchannel: SubchannelInterface) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    this.stickyTransientFailureMode = false;\n    /* Ref before removeCurrentPick and resetSubchannelList to avoid the\n     * refcount dropping to 0 during this process. */\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.removeCurrentPick();\n    this.resetSubchannelList();\n    subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);\n    this.currentPick = subchannel;\n    clearTimeout(this.connectionDelayTimeout);\n    this.calculateAndReportNewState();\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList() {\n    for (const child of this.children) {\n      /* Always remoev the connectivity state listener. If the subchannel is\n         getting picked, it will be re-added then. */\n      child.subchannel.removeConnectivityStateListener(\n        this.subchannelStateListener\n      );\n      /* Refs are counted independently for the children list and the\n       * currentPick, so we call unref whether or not the child is the\n       * currentPick. Channelz child references are also refcounted, so\n       * removeChannelzChild can be handled the same way. */\n      child.subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(\n        child.subchannel.getChannelzRef()\n      );\n    }\n    this.currentSubchannelIndex = 0;\n    this.children = [];\n  }\n\n  private connectToAddressList(addressList: SubchannelAddress[]) {\n    trace('connectToAddressList([' + addressList.map(address => subchannelAddressToString(address)) + '])');\n    const newChildrenList = addressList.map(address => ({\n      subchannel: this.channelControlHelper.createSubchannel(address, {}),\n      hasReportedTransientFailure: false,\n    }));\n    for (const { subchannel } of newChildrenList) {\n      if (subchannel.getConnectivityState() === ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      }\n    }\n    /* Ref each subchannel before resetting the list, to ensure that\n     * subchannels shared between the list don't drop to 0 refs during the\n     * transition. */\n    for (const { subchannel } of newChildrenList) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    this.resetSubchannelList();\n    this.children = newChildrenList;\n    for (const { subchannel } of this.children) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    for (const child of this.children) {\n      if (\n        child.subchannel.getConnectivityState() ===\n        ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        child.hasReportedTransientFailure = true;\n      }\n    }\n    this.startNextSubchannelConnecting(0);\n    this.calculateAndReportNewState();\n  }\n\n  updateAddressList(\n    endpointList: Endpoint[],\n    lbConfig: TypedLoadBalancingConfig\n  ): void {\n    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n      return;\n    }\n    /* Previously, an update would be discarded if it was identical to the\n     * previous update, to minimize churn. Now the DNS resolver is\n     * rate-limited, so that is less of a concern. */\n    if (lbConfig.getShuffleAddressList()) {\n      endpointList = shuffled(endpointList);\n    }\n    const rawAddressList = ([] as SubchannelAddress[]).concat(\n      ...endpointList.map(endpoint => endpoint.addresses)\n    );\n    trace('updateAddressList([' + rawAddressList.map(address => subchannelAddressToString(address)) + '])');\n    if (rawAddressList.length === 0) {\n      throw new Error('No addresses in endpoint list passed to pick_first');\n    }\n    const addressList = interleaveAddressFamilies(rawAddressList);\n    this.latestAddressList = addressList;\n    this.connectToAddressList(addressList);\n  }\n\n  exitIdle() {\n    if (\n      this.currentState === ConnectivityState.IDLE &&\n      this.latestAddressList\n    ) {\n      this.connectToAddressList(this.latestAddressList);\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n    this.removeCurrentPick();\n  }\n\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nconst LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);\n\n/**\n * This class handles the leaf load balancing operations for a single endpoint.\n * It is a thin wrapper around a PickFirstLoadBalancer with a different API\n * that more closely reflects how it will be used as a leaf balancer.\n */\nexport class LeafLoadBalancer {\n  private pickFirstBalancer: PickFirstLoadBalancer;\n  private latestState: ConnectivityState = ConnectivityState.IDLE;\n  private latestPicker: Picker;\n  constructor(\n    private endpoint: Endpoint,\n    channelControlHelper: ChannelControlHelper,\n    options: ChannelOptions\n  ) {\n    const childChannelControlHelper = createChildChannelControlHelper(\n      channelControlHelper,\n      {\n        updateState: (connectivityState, picker) => {\n          this.latestState = connectivityState;\n          this.latestPicker = picker;\n          channelControlHelper.updateState(connectivityState, picker);\n        },\n      }\n    );\n    this.pickFirstBalancer = new PickFirstLoadBalancer(\n      childChannelControlHelper,\n      { ...options, [REPORT_HEALTH_STATUS_OPTION_NAME]: true }\n    );\n    this.latestPicker = new QueuePicker(this.pickFirstBalancer);\n  }\n\n  startConnecting() {\n    this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);\n  }\n\n  /**\n   * Update the endpoint associated with this LeafLoadBalancer to a new\n   * endpoint. Does not trigger connection establishment if a connection\n   * attempt is not already in progress.\n   * @param newEndpoint\n   */\n  updateEndpoint(newEndpoint: Endpoint) {\n    this.endpoint = newEndpoint;\n    if (this.latestState !== ConnectivityState.IDLE) {\n      this.startConnecting();\n    }\n  }\n\n  getConnectivityState() {\n    return this.latestState;\n  }\n\n  getPicker() {\n    return this.latestPicker;\n  }\n\n  getEndpoint() {\n    return this.endpoint;\n  }\n\n  exitIdle() {\n    this.pickFirstBalancer.exitIdle();\n  }\n\n  destroy() {\n    this.pickFirstBalancer.destroy();\n  }\n}\n\nexport function setup(): void {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    PickFirstLoadBalancer,\n    PickFirstLoadBalancingConfig\n  );\n  registerDefaultLoadBalancerType(TYPE_NAME);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}