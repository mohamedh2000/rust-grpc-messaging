{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelCredentials = void 0;\nconst tls_1 = require(\"tls\");\nconst call_credentials_1 = require(\"./call-credentials\");\nconst tls_helpers_1 = require(\"./tls-helpers\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nclass ChannelCredentials {\n  constructor(callCredentials) {\n    this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n  }\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n  _getCallCredentials() {\n    return this.callCredentials;\n  }\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n    var _a;\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error('Private key must be given with accompanying certificate chain');\n    }\n    if (!privateKey && certChain) {\n      throw new Error('Certificate chain must be given with accompanying private key');\n    }\n    const secureContext = (0, tls_1.createSecureContext)({\n      ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n      key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n      cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n      ciphers: tls_helpers_1.CIPHER_SUITES\n    });\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createFromSecureContext(secureContext, verifyOptions) {\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure() {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor() {\n    super();\n  }\n  compose(callCredentials) {\n    throw new Error('Cannot compose insecure credentials');\n  }\n  _getConnectionOptions() {\n    return null;\n  }\n  _isSecure() {\n    return false;\n  }\n  _equals(other) {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(secureContext, verifyOptions) {\n    super();\n    this.secureContext = secureContext;\n    this.verifyOptions = verifyOptions;\n    this.connectionOptions = {\n      secureContext\n    };\n    // Node asserts that this option is a function, so we cannot pass undefined\n    if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n  }\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n  _getConnectionOptions() {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return Object.assign({}, this.connectionOptions);\n  }\n  _isSecure() {\n    return true;\n  }\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n    } else {\n      return false;\n    }\n  }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(channelCredentials, callCreds) {\n    super(callCreds);\n    this.channelCredentials = channelCredentials;\n  }\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n  }\n  _getConnectionOptions() {\n    return this.channelCredentials._getConnectionOptions();\n  }\n  _isSecure() {\n    return true;\n  }\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n    } else {\n      return false;\n    }\n  }\n}","map":{"version":3,"names":["tls_1","require","call_credentials_1","tls_helpers_1","verifyIsBufferOrNull","obj","friendlyName","Buffer","TypeError","ChannelCredentials","constructor","callCredentials","CallCredentials","createEmpty","_getCallCredentials","createSsl","rootCerts","privateKey","certChain","verifyOptions","Error","secureContext","createSecureContext","ca","_a","getDefaultRootsData","undefined","key","cert","ciphers","CIPHER_SUITES","SecureChannelCredentialsImpl","createFromSecureContext","createInsecure","InsecureChannelCredentialsImpl","exports","compose","_getConnectionOptions","_isSecure","_equals","other","connectionOptions","checkServerIdentity","combinedCallCredentials","ComposedChannelCredentialsImpl","Object","assign","channelCredentials","callCreds"],"sources":["/Users/husseinmohamed/Desktop/Learn_Rust/projects/grpc-project/client-grpc-messaging/node_modules/@grpc/grpc-js/src/channel-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ConnectionOptions,\n  createSecureContext,\n  PeerCertificate,\n  SecureContext,\n} from 'tls';\n\nimport { CallCredentials } from './call-credentials';\nimport { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj: any, friendlyName: string): void {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n\n/**\n * A callback that will receive the expected hostname and presented peer\n * certificate as parameters. The callback should return an error to\n * indicate that the presented certificate is considered invalid and\n * otherwise returned undefined.\n */\nexport type CheckServerIdentityCallback = (\n  hostname: string,\n  cert: PeerCertificate\n) => Error | undefined;\n\n/**\n * Additional peer verification options that can be set when creating\n * SSL credentials.\n */\nexport interface VerifyOptions {\n  /**\n   * If set, this callback will be invoked after the usual hostname verification\n   * has been performed on the peer certificate.\n   */\n  checkServerIdentity?: CheckServerIdentityCallback;\n}\n\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nexport abstract class ChannelCredentials {\n  protected callCredentials: CallCredentials;\n\n  protected constructor(callCredentials?: CallCredentials) {\n    this.callCredentials = callCredentials || CallCredentials.createEmpty();\n  }\n  /**\n   * Returns a copy of this object with the included set of per-call credentials\n   * expanded to include callCredentials.\n   * @param callCredentials A CallCredentials object to associate with this\n   * instance.\n   */\n  abstract compose(callCredentials: CallCredentials): ChannelCredentials;\n\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n  _getCallCredentials(): CallCredentials {\n    return this.callCredentials;\n  }\n\n  /**\n   * Gets a SecureContext object generated from input parameters if this\n   * instance was created with createSsl, or null if this instance was created\n   * with createInsecure.\n   */\n  abstract _getConnectionOptions(): ConnectionOptions | null;\n\n  /**\n   * Indicates whether this credentials object creates a secure channel.\n   */\n  abstract _isSecure(): boolean;\n\n  /**\n   * Check whether two channel credentials objects are equal. Two secure\n   * credentials are equal if they were constructed with the same parameters.\n   * @param other The other ChannelCredentials Object\n   */\n  abstract _equals(other: ChannelCredentials): boolean;\n\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createSsl(\n    rootCerts?: Buffer | null,\n    privateKey?: Buffer | null,\n    certChain?: Buffer | null,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error(\n        'Private key must be given with accompanying certificate chain'\n      );\n    }\n    if (!privateKey && certChain) {\n      throw new Error(\n        'Certificate chain must be given with accompanying private key'\n      );\n    }\n    const secureContext = createSecureContext({\n      ca: rootCerts ?? getDefaultRootsData() ?? undefined,\n      key: privateKey ?? undefined,\n      cert: certChain ?? undefined,\n      ciphers: CIPHER_SUITES,\n    });\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions ?? {});\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createFromSecureContext(\n    secureContext: SecureContext,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions ?? {});\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure(): ChannelCredentials {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor() {\n    super();\n  }\n\n  compose(callCredentials: CallCredentials): never {\n    throw new Error('Cannot compose insecure credentials');\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return null;\n  }\n  _isSecure(): boolean {\n    return false;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  connectionOptions: ConnectionOptions;\n\n  constructor(\n    private secureContext: SecureContext,\n    private verifyOptions: VerifyOptions\n  ) {\n    super();\n    this.connectionOptions = {\n      secureContext,\n    };\n    // Node asserts that this option is a function, so we cannot pass undefined\n    if (verifyOptions?.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity =\n        verifyOptions.checkServerIdentity;\n    }\n  }\n\n  compose(callCredentials: CallCredentials): ChannelCredentials {\n    const combinedCallCredentials =\n      this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return { ...this.connectionOptions };\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return (\n        this.secureContext === other.secureContext &&\n        this.verifyOptions.checkServerIdentity ===\n          other.verifyOptions.checkServerIdentity\n      );\n    } else {\n      return false;\n    }\n  }\n}\n\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(\n    private channelCredentials: SecureChannelCredentialsImpl,\n    callCreds: CallCredentials\n  ) {\n    super(callCreds);\n  }\n  compose(callCredentials: CallCredentials) {\n    const combinedCallCredentials =\n      this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(\n      this.channelCredentials,\n      combinedCallCredentials\n    );\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return this.channelCredentials._getConnectionOptions();\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return (\n        this.channelCredentials._equals(other.channelCredentials) &&\n        this.callCredentials._equals(other.callCredentials)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}